"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/data/enrichers/onChainPoolDataEnricher.ts




var _viem = require('viem');

// src/entities/token.ts
var Token = class {
  constructor(chainId, address, decimals, symbol, name, wrapped) {
    __publicField(this, "chainId");
    __publicField(this, "address");
    __publicField(this, "decimals");
    __publicField(this, "symbol");
    __publicField(this, "name");
    __publicField(this, "wrapped");
    this.chainId = chainId;
    this.address = address.toLowerCase();
    this.decimals = decimals;
    this.symbol = symbol;
    this.name = name;
    this.wrapped = wrapped ? wrapped.toLowerCase() : address.toLowerCase();
  }
  isEqual(token) {
    return this.chainId === token.chainId && this.address === token.address;
  }
  isUnderlyingEqual(token) {
    return this.chainId === token.chainId && this.wrapped === token.wrapped;
  }
  isSameAddress(address) {
    return this.address === address.toLowerCase();
  }
  toInputToken() {
    return {
      address: this.address,
      decimals: this.decimals
    };
  }
};

// src/utils/constants.ts














var _chains = require('viem/chains');
var ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
var NATIVE_ADDRESS = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee";
var MAX_UINT112 = 5192296858534827628530496329220095n;
var MAX_UINT256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935n;
var PREMINTED_STABLE_BPT = 2596148429267413814265248164610048n;
var DECIMAL_SCALES = {
  0: 1n,
  1: 10n,
  2: 100n,
  3: 1000n,
  4: 10000n,
  5: 100000n,
  6: 1000000n,
  7: 10000000n,
  8: 100000000n,
  9: 1000000000n,
  10: 10000000000n,
  11: 100000000000n,
  12: 1000000000000n,
  13: 10000000000000n,
  14: 100000000000000n,
  15: 1000000000000000n,
  16: 10000000000000000n,
  17: 100000000000000000n,
  18: 1000000000000000000n
};
var SECONDS_PER_YEAR = 31536000n;
var ChainId = /* @__PURE__ */ ((ChainId9) => {
  ChainId9[ChainId9["MAINNET"] = 1] = "MAINNET";
  ChainId9[ChainId9["GOERLI"] = 5] = "GOERLI";
  ChainId9[ChainId9["OPTIMISM"] = 10] = "OPTIMISM";
  ChainId9[ChainId9["BSC"] = 56] = "BSC";
  ChainId9[ChainId9["GNOSIS_CHAIN"] = 100] = "GNOSIS_CHAIN";
  ChainId9[ChainId9["POLYGON"] = 137] = "POLYGON";
  ChainId9[ChainId9["ZKSYNC_TESTNET"] = 280] = "ZKSYNC_TESTNET";
  ChainId9[ChainId9["ZKSYNC"] = 324] = "ZKSYNC";
  ChainId9[ChainId9["ZKEVM"] = 1101] = "ZKEVM";
  ChainId9[ChainId9["ARBITRUM_ONE"] = 42161] = "ARBITRUM_ONE";
  ChainId9[ChainId9["AVALANCHE"] = 43114] = "AVALANCHE";
  ChainId9[ChainId9["BASE_GOERLI"] = 84531] = "BASE_GOERLI";
  ChainId9[ChainId9["FANTOM"] = 250] = "FANTOM";
  return ChainId9;
})(ChainId || {});
var CHAINS = {
  [1 /* MAINNET */]: _chains.mainnet,
  [5 /* GOERLI */]: _chains.goerli,
  [10 /* OPTIMISM */]: _chains.optimism,
  [56 /* BSC */]: _chains.bsc,
  [100 /* GNOSIS_CHAIN */]: _chains.gnosis,
  [137 /* POLYGON */]: _chains.polygon,
  [280 /* ZKSYNC_TESTNET */]: _chains.zkSyncTestnet,
  [324 /* ZKSYNC */]: _chains.zkSync,
  [1101 /* ZKEVM */]: _chains.polygonZkEvm,
  [42161 /* ARBITRUM_ONE */]: _chains.arbitrum,
  [43114 /* AVALANCHE */]: _chains.avalanche,
  [84531 /* BASE_GOERLI */]: _chains.baseGoerli,
  [250 /* FANTOM */]: _chains.fantom
};
var SUBGRAPH_URLS = {
  [1 /* MAINNET */]: "https://api.thegraph.com/subgraphs/name/balancer-labs/balancer-v2",
  [5 /* GOERLI */]: "https://api.thegraph.com/subgraphs/name/balancer-labs/balancer-goerli-v2",
  [10 /* OPTIMISM */]: "https://api.thegraph.com/subgraphs/name/balancer-labs/balancer-optimism-v2",
  [100 /* GNOSIS_CHAIN */]: "https://api.thegraph.com/subgraphs/name/balancer-labs/balancer-gnosis-chain-v2",
  [137 /* POLYGON */]: "https://api.thegraph.com/subgraphs/name/balancer-labs/balancer-polygon-v2",
  [280 /* ZKSYNC_TESTNET */]: "https://api.thegraph.com/subgraphs/name/balancer-labs/balancer-zktestnet-v2",
  [324 /* ZKSYNC */]: "https://api.thegraph.com/subgraphs/name/balancer-labs/balancer-zksync-v2",
  [1101 /* ZKEVM */]: "https://api.thegraph.com/subgraphs/name/balancer-labs/balancer-zkevm-v2",
  [42161 /* ARBITRUM_ONE */]: "https://api.thegraph.com/subgraphs/name/balancer-labs/balancer-arbitrum-v2",
  [43114 /* AVALANCHE */]: "https://api.thegraph.com/subgraphs/name/balancer-labs/balancer-avalanche-v2",
  [84531 /* BASE_GOERLI */]: "https://api.thegraph.com/subgraphs/name/balancer-labs/balancer-base-goerli-v2",
  [250 /* FANTOM */]: "https://api.thegraph.com/subgraphs/name/beethovenxfi/beethovenx-v2-fantom"
};
var BATCHSIZE = {
  [42161 /* ARBITRUM_ONE */]: 800,
  [43114 /* AVALANCHE */]: 800,
  [100 /* GNOSIS_CHAIN */]: 800,
  [1 /* MAINNET */]: 800,
  [10 /* OPTIMISM */]: 800,
  [137 /* POLYGON */]: 800,
  [1101 /* ZKEVM */]: 128,
  [250 /* FANTOM */]: 128
};
var BALANCER_VAULT = "0xBA12222222228d8Ba445958a75a0704d566BF2C8";
var BALANCER_RELAYER = {
  [1 /* MAINNET */]: "0x35Cea9e57A393ac66Aaa7E25C391D52C74B5648f"
};
var VAULT = {
  [42161 /* ARBITRUM_ONE */]: "0xBA12222222228d8Ba445958a75a0704d566BF2C8",
  [43114 /* AVALANCHE */]: "0xBA12222222228d8Ba445958a75a0704d566BF2C8",
  [100 /* GNOSIS_CHAIN */]: "0xBA12222222228d8Ba445958a75a0704d566BF2C8",
  [1 /* MAINNET */]: "0xBA12222222228d8Ba445958a75a0704d566BF2C8",
  [10 /* OPTIMISM */]: "0xBA12222222228d8Ba445958a75a0704d566BF2C8",
  [137 /* POLYGON */]: "0xBA12222222228d8Ba445958a75a0704d566BF2C8",
  [1101 /* ZKEVM */]: "0xBA12222222228d8Ba445958a75a0704d566BF2C8",
  [250 /* FANTOM */]: "0x20dd72Ed959b6147912C2e529F0a0C651c33c9ce"
};
var BALANCER_QUERIES = {
  [42161 /* ARBITRUM_ONE */]: "0xE39B5e3B6D74016b2F6A9673D7d7493B6DF549d5",
  [43114 /* AVALANCHE */]: "0xE39B5e3B6D74016b2F6A9673D7d7493B6DF549d5",
  [100 /* GNOSIS_CHAIN */]: "0x0f3e0c4218b7b0108a3643cfe9d3ec0d4f57c54e",
  [1 /* MAINNET */]: "0xE39B5e3B6D74016b2F6A9673D7d7493B6DF549d5",
  [10 /* OPTIMISM */]: "0xE39B5e3B6D74016b2F6A9673D7d7493B6DF549d5",
  [137 /* POLYGON */]: "0xE39B5e3B6D74016b2F6A9673D7d7493B6DF549d5",
  [1101 /* ZKEVM */]: "0x809b79b53f18e9bc08a961ed4678b901ac93213a",
  [250 /* FANTOM */]: "0x1B0A42663DF1edeA171cD8732d288a81EFfF6d23"
};
var WEIGHTED_POOL_FACTORY = {
  [42161 /* ARBITRUM_ONE */]: "0xc7e5ed1054a24ef31d827e6f86caa58b3bc168d7",
  [43114 /* AVALANCHE */]: "0x230a59f4d9adc147480f03b0d3fffecd56c3289a",
  [100 /* GNOSIS_CHAIN */]: "0x6cad2ea22bfa7f4c14aae92e47f510cd5c509bc7",
  [1 /* MAINNET */]: "0x897888115ada5773e02aa29f775430bfb5f34c51",
  [10 /* OPTIMISM */]: "0x230a59f4d9adc147480f03b0d3fffecd56c3289a",
  [137 /* POLYGON */]: "0xfc8a407bba312ac761d8bfe04ce1201904842b76",
  [1101 /* ZKEVM */]: "0x03f3fb107e74f2eac9358862e91ad3c692712054"
};
var COMPOSABLE_STABLE_POOL_FACTORY = {
  [42161 /* ARBITRUM_ONE */]: "0xa8920455934da4d853faac1f94fe7bef72943ef1",
  [43114 /* AVALANCHE */]: "0xe42ffa682a26ef8f25891db4882932711d42e467",
  [100 /* GNOSIS_CHAIN */]: "0x4bdcc2fb18aeb9e2d281b0278d946445070eada7",
  [1 /* MAINNET */]: "0xdb8d758bcb971e482b2c45f7f8a7740283a1bd3a",
  [10 /* OPTIMISM */]: "0x043a2dad730d585c44fb79d2614f295d2d625412",
  [137 /* POLYGON */]: "0xe2fa4e1d17725e72dcdafe943ecf45df4b9e285b",
  [1101 /* ZKEVM */]: "0x577e5993b9cc480f07f98b5ebd055604bd9071c4"
};
var NATIVE_ASSETS = {
  [1 /* MAINNET */]: new Token(
    1 /* MAINNET */,
    NATIVE_ADDRESS,
    18,
    "ETH",
    "Ether",
    "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"
  ),
  [5 /* GOERLI */]: new Token(
    5 /* GOERLI */,
    NATIVE_ADDRESS,
    18,
    "ETH",
    "Ether",
    "0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6"
  ),
  [100 /* GNOSIS_CHAIN */]: new Token(
    100 /* GNOSIS_CHAIN */,
    NATIVE_ADDRESS,
    18,
    "xDAI",
    "xDAI",
    "0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d"
  ),
  [137 /* POLYGON */]: new Token(
    137 /* POLYGON */,
    NATIVE_ADDRESS,
    18,
    "MATIC",
    "Matic",
    "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270"
  ),
  [42161 /* ARBITRUM_ONE */]: new Token(
    42161 /* ARBITRUM_ONE */,
    NATIVE_ADDRESS,
    18,
    "ETH",
    "Ether",
    "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1"
  ),
  [10 /* OPTIMISM */]: new Token(
    10 /* OPTIMISM */,
    NATIVE_ADDRESS,
    18,
    "ETH",
    "Ether",
    "0x4200000000000000000000000000000000000006"
  ),
  [250 /* FANTOM */]: new Token(
    250 /* FANTOM */,
    NATIVE_ADDRESS,
    18,
    "FANTOM",
    "Fantom",
    "0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83"
  )
};
var ETH = NATIVE_ASSETS[1 /* MAINNET */];
var DEFAULT_FUND_MANAGMENT = {
  sender: ZERO_ADDRESS,
  recipient: ZERO_ADDRESS,
  fromInternalBalance: false,
  toInternalBalance: false
};
var DEFAULT_USERDATA = "0x";
var brickedPools = [
  "0x00c2a4be503869fa751c2dbcb7156cc970b5a8da000000000000000000000477",
  "0x02d928e68d8f10c0358566152677db51e1e2dc8c00000000000000000000051e",
  "0x04248aabca09e9a1a3d5129a7ba05b7f17de768400000000000000000000050e",
  "0x05513ca725b6ce035ca2641075474eb469f05f4c00020000000000000000041f",
  "0x0a0fb4ff697de5ac5b6770cd8ee1b72af80b57cf000000000000000000000496",
  "0x0afbd58beca09545e4fb67772faf3858e610bcd00000000000000000000004b9",
  "0x0d05aac44ac7dd3c7ba5d50be93eb884a057d23400000000000000000000051c",
  "0x11839d635e2f0270da37e8ef4324d4d5d54329570002000000000000000004d8",
  "0x126e7643235ec0ab9c103c507642dc3f4ca23c66000000000000000000000468",
  "0x133d241f225750d2c92948e464a5a80111920331000000000000000000000476",
  "0x159cb00338fb63f263fd6f621df619cef71da9540000000000000000000004d5",
  "0x173063a30e095313eee39411f07e95a8a806014e0002000000000000000003ab",
  "0x1bd2f176a812e312077bca87e37c08432bb09f3e0000000000000000000005a1",
  "0x20b156776114e8a801e9767d90c6ccccc8adf398000000000000000000000499",
  "0x246ffb4d928e394a02e45761fecdba6c2e79b8eb000000000000000000000541",
  "0x25accb7943fd73dda5e23ba6329085a3c24bfb6a000200000000000000000387",
  "0x26c2b83fc8535deead276f5cc3ad9c1a2192e02700020000000000000000056b",
  "0x2b218683178d029bab6c9789b1073aa6c96e517600000000000000000000058c",
  "0x2ba7aa2213fa2c909cd9e46fed5a0059542b36b00000000000000000000003a3",
  "0x2bbf681cc4eb09218bee85ea2a5d3d13fa40fc0c0000000000000000000000fd",
  "0x2e52c64fd319e380cdbcfc4577ea1fda558a32e40002000000000000000005ba",
  "0x2f4eb100552ef93840d5adc30560e5513dfffacb000000000000000000000334",
  "0x2ff1a9dbdacd55297452cfd8a4d94724bc22a5f7000000000000000000000484",
  "0x3035917be42af437cbdd774be26b9ec90a2bd677000200000000000000000543",
  "0x331d50e0b00fc1c32742f151e56b9b616227e23e00000000000000000000047c",
  "0x334c96d792e4b26b841d28f53235281cec1be1f200020000000000000000038a",
  "0x335d1709d4da9aca59d16328db5cd4ea66bfe06b0000000000000000000004d6",
  "0x395d8a1d9ad82b5abe558f8abbfe183b27138af40000000000000000000004e5",
  "0x3bb22fc9033b802f2ac47c18885f63476f158afc000000000000000000000483",
  "0x3c640f0d3036ad85afa2d5a9e32be651657b874f00000000000000000000046b",
  "0x3cdae4f12a67ba563499e102f309c73213cb241c000000000000000000000335",
  "0x3dbb8d974b82e82ce79c20c0f5995f4f1f533ede000000000000000000000470",
  "0x3f7a7fd7f214be45ec26820fd01ac3be4fc75aa70002000000000000000004c5",
  "0x3fcb7085b8f2f473f80bf6d879cae99ea4de934400000000000000000000056d",
  "0x41503c9d499ddbd1dcdf818a1b05e9774203bf46000000000000000000000594",
  "0x4228290ee9cab692938ff0b4ba303fbcdb68e9f200020000000000000000057d",
  "0x454ed96955d04d2f5cdd05e0fd1c77975bfe5307000000000000000000000410",
  "0x481c5fc05d63a58aa2f0f2aa417c021b5d419cb200000000000000000000056a",
  "0x483006684f422a9448023b2382615c57c5ecf18f000000000000000000000488",
  "0x4a82b580365cff9b146281ab72500957a849abdc000000000000000000000494",
  "0x4c81255cc9ed7062180ea99962fe05ac0d57350b0000000000000000000005a3",
  "0x4c8d2e60863e8d7e1033eda2b3d84e92a641802000000000000000000000040f",
  "0x4cbde5c4b4b53ebe4af4adb85404725985406163000000000000000000000595",
  "0x4ce0bd7debf13434d3ae127430e9bd4291bfb61f00020000000000000000038b",
  "0x4ce277df0feb5b4d07a0ca2adcf5326e4005239d000000000000000000000518",
  "0x4fd4687ec38220f805b6363c3c1e52d0df3b5023000200000000000000000473",
  "0x4fd63966879300cafafbb35d157dc5229278ed230000000000000000000000e9",
  "0x50cf90b954958480b8df7958a9e965752f62712400000000000000000000046f",
  "0x53bc3cba3832ebecbfa002c12023f8ab1aa3a3a0000000000000000000000411",
  "0x5a6a8cffb4347ff7fc484bf5f0f8a2e234d34255000200000000000000000275",
  "0x5b3240b6be3e7487d61cd1afdfc7fe4fa1d81e6400000000000000000000037b",
  "0x60683b05e9a39e3509d8fdb9c959f23170f8a0fa000000000000000000000489",
  "0x60d604890feaa0b5460b28a424407c24fe89374a0000000000000000000004fc",
  "0x639883476960a23b38579acfd7d71561a0f408cf000200000000000000000505",
  "0x652d486b80c461c397b0d95612a404da936f3db30000000000000000000000e7",
  "0x6667c6fa9f2b3fc1cc8d85320b62703d938e43850000000000000000000004fb",
  "0x6a1eb2e9b45e772f55bd9a34659a04b6f75da68700000000000000000000040d",
  "0x6c56e72c551b5ac4bf54a620a76077ca768c8fe40002000000000000000004da",
  "0x70b7d3b3209a59fb0400e17f67f3ee8c37363f4900020000000000000000018f",
  "0x7337224d59cb16c2dc6938cd45a7b2c60c865d6a0000000000000000000004d4",
  "0x74cbfaf94a3577c539a9dcee9870a6349a33b34f000000000000000000000534",
  "0x779d01f939d78a918a3de18cc236ee89221dfd4e0000000000000000000004c7",
  "0x7b50775383d3d6f0215a8f290f2c9e2eebbeceb20000000000000000000000fe",
  "0x804cdb9116a10bb78768d3252355a1b18067bf8f0000000000000000000000fb",
  "0x813e3fe1761f714c502d1d2d3a7cceb33f37f59d00000000000000000000040c",
  "0x82698aecc9e28e9bb27608bd52cf57f704bd1b83000000000000000000000336",
  "0x8a6b25e33b12d1bb6929a8793961076bd1f9d3eb0002000000000000000003e8",
  "0x8e6ec57a822c2f527f2df7c7d7d361df3e7530a1000000000000000000000498",
  "0x8f4063446f5011bc1c9f79a819efe87776f23704000000000000000000000197",
  "0x9001cbbd96f54a658ff4e6e65ab564ded76a543100000000000000000000050a",
  "0x9210f1204b5a24742eba12f710636d76240df3d00000000000000000000000fc",
  "0x9516a2d25958edb8da246a320f2c7d94a0dbe25d000000000000000000000519",
  "0x959216bb492b2efa72b15b7aacea5b5c984c3cca000200000000000000000472",
  "0x968024662b9566b42d78af23a0f441bc8723fa83000200000000000000000418",
  "0x99c88ad7dc566616548adde8ed3effa730eb6c3400000000000000000000049a",
  "0x9b1c8407a360443a9e5eca004713e4088fab8ac0000000000000000000000497",
  "0x9b692f571b256140a39a34676bffa30634c586e100000000000000000000059d",
  "0x9d7f992c900fbea0ec314bdd71b7cc1becf76a33000200000000000000000573",
  "0x9fb771d530b0ceba5160f7bfe2dd1e8b8aa1340300000000000000000000040e",
  "0xa13a9247ea42d743238089903570127dda72fe4400000000000000000000035d",
  "0xa1697f9af0875b63ddc472d6eebada8c1fab85680000000000000000000004f9",
  "0xa3823e50f20982656557a4a6a9c06ba5467ae9080000000000000000000000e6",
  "0xa718042e5622099e5f0ace4e7122058ab39e1bbe000200000000000000000475",
  "0xa8b103a10a94f4f2d7ed2fdcd5545e807557330700000000000000000000048e",
  "0xac5b4ef7ede2f2843a704e96dcaa637f4ba3dc3f00000000000000000000051d",
  "0xac976bb42cb0c85635644e8c7c74d0e0286aa61c0000000000000000000003cb",
  "0xae37d54ae477268b9997d4161b96b8200755935c000000000000000000000337",
  "0xae8535c23afedda9304b03c68a3563b75fc8f92b0000000000000000000005a0",
  "0xb0f75e97a114a4eb4a425edc48990e6760726709000000000000000000000198",
  "0xb5e3de837f869b0248825e0175da73d4e8c3db6b000200000000000000000474",
  "0xb841b062ea8ccf5c4cb78032e91de4ae875560420002000000000000000005b7",
  "0xb9bd68a77ccf8314c0dfe51bc291c77590c4e9e6000200000000000000000385",
  "0xbb6881874825e60e1160416d6c426eae65f2459e000000000000000000000592",
  "0xbc0f2372008005471874e426e86ccfae7b4de79d000000000000000000000485",
  "0xbf2ef8bdc2fc0f3203b3a01778e3ec5009aeef3300000000000000000000058d",
  "0xbfa413a2ff0f20456d57b643746133f54bfe0cd20000000000000000000004c3",
  "0xc2b021133d1b0cf07dba696fd5dd89338428225b000000000000000000000598",
  "0xc443c15033fcb6cf72cc24f1bda0db070ddd9786000000000000000000000593",
  "0xc50d4347209f285247bda8a09fc1c12ce42031c3000000000000000000000590",
  "0xc5dc1316ab670a2eed5716d7f19ced321191f38200000000000000000000056e",
  "0xc8c79fcd0e859e7ec81118e91ce8e4379a481ee6000000000000000000000196",
  "0xcaa052584b462198a5a9356c28bce0634d65f65c0000000000000000000004db",
  "0xcbfa4532d8b2ade2c261d3dd5ef2a2284f7926920000000000000000000004fa",
  "0xcfae6e251369467f465f13836ac8135bd42f8a56000000000000000000000591",
  "0xd4e7c1f3da1144c9e2cfd1b015eda7652b4a439900000000000000000000046a",
  "0xd6e355036f41dc261b3f1ed3bbc6003e87aadb4f000000000000000000000495",
  "0xd7edb56f63b2a0191742aea32df1f98ca81ed9c600000000000000000000058e",
  "0xd997f35c9b1281b82c8928039d14cddab5e13c2000000000000000000000019c",
  "0xdba274b4d04097b90a72b62467d828cefd708037000000000000000000000486",
  "0xdc063deafce952160ec112fa382ac206305657e60000000000000000000004c4",
  "0xdec02e6642e2c999af429f5ce944653cad15e093000000000000000000000469",
  "0xe03af00fabe8401560c1ff7d242d622a5b601573000000000000000000000493",
  "0xe0fcbf4d98f0ad982db260f86cf28b49845403c5000000000000000000000504",
  "0xe2d16b0a39f3fbb4389a0e8f1efcbecfb3d1e6e10000000000000000000005a7",
  "0xe4dc3c1998ac693d68f4c77476d7c815694c3e94000200000000000000000416",
  "0xe6bcc79f328eec93d4ec8f7ed35534d9ab549faa0000000000000000000000e8",
  "0xe8c56405bc405840154d9b572927f4197d110de10000000000000000000005a4",
  "0xeb486af868aeb3b6e53066abc9623b1041b42bc000000000000000000000046c",
  "0xeb567dde03f3da7fe185bdacd5ab495ab220769d000000000000000000000548",
  "0xec3626fee40ef95e7c0cbb1d495c8b67b34d398300000000000000000000053d",
  "0xf22ff21e17157340575158ad7394e068048dd98b0000000000000000000004b8",
  "0xf57c794f42da72b38c8f610ff3b5e8502e48cbde00000000000000000000055c",
  "0xf71d0774b214c4cf51e33eb3d30ef98132e4dbaa00000000000000000000046e",
  "0xfa24a90a3f2bbe5feea92b95cd0d14ce709649f900000000000000000000058f",
  "0xfd11ccdbdb7ab91cb9427a6d6bf570c95876d1950000000000000000000004c2",
  "0xfebb0bbf162e64fb9d0dfe186e517d84c395f016000000000000000000000502",
  "0xfef969638c52899f91781f1be594af6f40b99bad00000000000000000000047b",
  "0x02e139d53ebf4033bf78ab66c6a1e7f1f204487f0002000000000000000009f9",
  "0x03090a9811181a2afe830a3a0b467698ccf3a8b1000000000000000000000bf5",
  "0x0320c1c5b6df19a194d48882aaec1c72940081d9000000000000000000000a7d",
  "0x04b54ea92d73de2d62d651db7d9778f0c49157d8000200000000000000000ba2",
  "0x0503dd6b2d3dd463c9bef67fb5156870af63393e00000000000000000000042e",
  "0x0889b240a5876aae745ac19f1771853671dc5d36000000000000000000000b3f",
  "0x0bc54e914f53f98d16035f4f0d948f3e09c2fac0000200000000000000000bac",
  "0x0c06e87c7b88d998f645b91c1f53b51294b12bca000100000000000000000bb9",
  "0x10b040038f87219d9b42e025e3bd9b8095c87dd9000000000000000000000b11",
  "0x117a3d474976274b37b7b94af5dcade5c90c6e85000000000000000000000aca",
  "0x11884da90fb4221b3aa288a7741c51ec4fc43b2f000000000000000000000a5f",
  "0x1379b816b9be611431d693290289c204720ca56d000100000000000000000b6f",
  "0x150e7b885bdfce974f2abe88a72fdbd692175c6f0002000000000000000009fd",
  "0x178e029173417b1f9c8bc16dcec6f697bc323746000000000000000000000758",
  "0x1aafc31091d93c3ff003cff5d2d8f7ba2e7284250000000000000000000003b3",
  "0x216690738aac4aa0c4770253ca26a28f0115c595000000000000000000000b2c",
  "0x216d6db0c28204014618482c369d7fbf0a8f3232000100000000000000000b60",
  "0x230ecdb2a7cee56d6889965a023aa0473d6da507000000000000000000000bf3",
  "0x252ff6a3a6fd7b5e8e999de8e3f5c3b306ed1401000200000000000000000bec",
  "0x25e57f4612912614e6c99616bd2abb9b5ae71e99000000000000000000000bf0",
  "0x2645b13fd2c5295296e94a76280b968bdcbbdfed000000000000000000000c11",
  "0x284eb68520c8fa83361c1a3a5910aec7f873c18b000000000000000000000ac9",
  "0x2c8dbe8eb86135d9f2f26d196748c088d47f73e7000200000000000000000a29",
  "0x31bccf9e28b94e5dacebaa67fe8bc1603cecd904000000000000000000000a01",
  "0x341068a547c3cde3c09e338714010dd01b32f93f000200000000000000000a34",
  "0x3db543faf7a92052de7860c5c9debabee59ed5bd000000000000000000000a62",
  "0x3dd0843a028c86e0b760b1a76929d1c5ef93a2dd00000000000000000000070d",
  "0x3efb91c4f9b103ee45885695c67794591916f34e000200000000000000000b43",
  "0x402cfdb7781fa85d52f425352661128250b79e12000000000000000000000be3",
  "0x43894de14462b421372bcfe445fa51b1b4a0ff3d000000000000000000000b36",
  "0x4739e50b59b552d490d3fdc60d200977a38510c0000000000000000000000b10",
  "0x48e6b98ef6329f8f0a30ebb8c7c960330d64808500000000000000000000075b",
  "0x4a0b73f0d13ff6d43e304a174697e3d5cfd310a400020000000000000000091c",
  "0x4a77ef015ddcd972fd9ba2c7d5d658689d090f1a000000000000000000000b38",
  "0x4ae3661afa119892f0cc8c43edaf6a94989ac171000000000000000000000c06",
  "0x4ccb966d8246240afb7a1a24628efb930870b1c40002000000000000000009fc",
  "0x52cc8389c6b93d740325729cc7c958066cee4262000000000000000000000b0f",
  "0x5b77107fcdf2b41903bab2bc555d4fc14cf7667d000000000000000000000b32",
  "0x5bae72b75caab1f260d21bc028c630140607d6e8000000000000000000000ac6",
  "0x600bd01b6526611079e12e1ff93aba7a3e34226f0000000000000000000009e4",
  "0x63ce19ccd39930725b8a3d2733627804718ab83d000000000000000000000bf2",
  "0x64efad69f099813021b41f4cac6e749fd55e188f000000000000000000000b39",
  "0x6933ec1ca55c06a894107860c92acdfd2dd8512f000000000000000000000428",
  "0x6abe4e7a497b8293c258389c1b00d177e4f257ed00010000000000000000080d",
  "0x6c8c7fc50247a47038015eb1fd5dc105d05dafba000200000000000000000ba0",
  "0x7079a25dec33be61bbd81b2fb69b468e80d3e72c0000000000000000000009ff",
  "0x71bd10c2a590b5858f5576550c163976a48af906000000000000000000000b27",
  "0x7c82a23b4c48d796dee36a9ca215b641c6a8709d000000000000000000000acd",
  "0x7f4f4942f2a14b6ab7b08b10ada1aacede4ee8d4000200000000000000000b44",
  "0x86aef31951e0a3a54333bd9e72f9a95587d058c5000200000000000000000912",
  "0x882c7a84231484b3e9f3fd45ac04b1eb5d35b076000200000000000000000a91",
  "0x894c82800526e0391e709c0983a5aea3718b7f6d000000000000000000000ac5",
  "0x89b28a9494589b09dbccb69911c189f74fdadc5a000000000000000000000b33",
  "0x89bb15076c9f2d86aa98ec6cffc1a71e31c38953000000000000000000000bf1",
  "0x89f1146fee52b5d9166e9c83cc388b6d8f69f1380001000000000000000009e7",
  "0x8a819a4cabd6efcb4e5504fe8679a1abd831dd8f00000000000000000000042d",
  "0x8b58a1e7fff52001c22386c2918d45938a6a9be30001000000000000000008d9",
  "0x8b8225bfedebaf1708c55743acb4ad43fd4d0f21000200000000000000000918",
  "0x8fbd0f8e490735cfc3abf4f29cbddd5c3289b9a7000000000000000000000b5b",
  "0x8fd39252d683fdb60bddd4df4b53c9380b496d59000200000000000000000b45",
  "0x9321e2250767d79bab5aa06daa8606a2b3b7b4c5000000000000000000000bf4",
  "0x949a12b95ec5b80c375b98963a5d6b33b0d0efff0002000000000000000009fe",
  "0x9a020bdc2faff5bd24c6acc2020d01ff9f2c627a000000000000000000000ae2",
  "0x9cf9358300e34bf9373d30129a1e718d8d058b54000200000000000000000913",
  "0x9e34631547adcf2f8cefa0f5f223955c7b137571000000000000000000000ad5",
  "0xa5a935833f6a5312715f182733eab088452335d7000100000000000000000bee",
  "0xa5fe91dde37d8bf2dacacc0168b115d28ed03f84000000000000000000000b35",
  "0xa8bf1c584519be0184311c48adbdc4c15cb2e8c1000000000000000000000bf6",
  "0xab269164a10fab22bc87c39946da06c870b172d6000000000000000000000bfc",
  "0xac2cae8d2f78a4a8f92f20dbe74042cd0a8d5af3000000000000000000000be2",
  "0xae646817e458c0be890b81e8d880206710e3c44e000000000000000000000acb",
  "0xaef2c171dbe64b0c18977e16e70bfd29d4ee0256000000000000000000000ac8",
  "0xb0c830dceb4ef55a60192472c20c8bf19df03488000000000000000000000be1",
  "0xb266ac3b7c98d7bcb28731dac0ef42dba1b276be000000000000000000000be4",
  "0xb371aa09f5a110ab69b39a84b5469d29f9b22b76000000000000000000000b37",
  "0xb3d658d5b95bf04e2932370dd1ff976fe18dd66a000000000000000000000ace",
  "0xb54b2125b711cd183edd3dd09433439d5396165200000000000000000000075e",
  "0xb59be8f3c85a9dd6e2899103b6fbf6ea405b99a4000000000000000000000b34",
  "0xb878ecce26838fbba4f78cb5b791a0e09152c067000000000000000000000427",
  "0xb973ca96a3f0d61045f53255e319aedb6ed4924000000000000000000000042f",
  "0xbd4e35784c832d0f9049b54cb3609e5907c5b495000100000000000000000b14",
  "0xc55ec796a4debe625d95436a3531f4950b11bdcf000000000000000000000b3e",
  "0xc7e6389e364f4275eb442ef215ed21877028e2af000000000000000000000ac7",
  "0xc83b55bbd005f1f84906545fcdb145dee53523e0000200000000000000000b30",
  "0xcb21a9e647c95127ed784626485b3104cb28d0e7000000000000000000000425",
  "0xd00f9ca46ce0e4a63067c4657986f0167b0de1e5000000000000000000000b42",
  "0xd2f3b9e67c69762dd1c88f1d3dadd1649a190761000200000000000000000bf7",
  "0xd4accb350f9cf59fe3cf7a5ee6ed9ace6a568ea9000200000000000000000b75",
  "0xda1cd1711743e57dd57102e9e61b75f3587703da000000000000000000000acc",
  "0xdae301690004946424e41051ace1791083be42a1000000000000000000000b40",
  "0xde0a77ab6689b980c30306b10f9131a007e1af81000200000000000000000ba1",
  "0xe051605a83deae38d26a7346b100ef1ac2ef8a0b0000000000000000000003ce",
  "0xe1fb90d0d3b47e551d494d7ebe8f209753526b01000000000000000000000ac4",
  "0xe2272cddb2cc408e79e02a73d1db9acc24a843d5000200000000000000000ba7",
  "0xe2dc0e0f2c358d6e31836dee69a558ab8d1390e70000000000000000000009fa",
  "0xe4885ed2818cc9e840a25f94f9b2a28169d1aea7000000000000000000000b29",
  "0xe6909c2f18a29d97217a6146f045e1780606991f000100000000000000000bfe",
  "0xe78b25c06db117fdf8f98583cdaaa6c92b79e917000000000000000000000b2b",
  "0xea11645ac7d8f2def94c9d8d86bd766296c9b6b6000000000000000000000b3a",
  "0xeb480dbbdd921cd6c359e4cc4c65ddea6395e2a1000200000000000000000946",
  "0xed35f28f837e96f81240ebb82e0e3f518c7e8a2f000100000000000000000bb5",
  "0xf0211cceebe6fcc45052b4e57ee95d233f5669d2000100000000000000000c01",
  "0xf22a66046b5307842f21b311ecb4c462c24c0635000000000000000000000b15",
  "0xf28f17be00f8ca3c9b7f66a4aad5513757fb3341000200000000000000000b5a",
  "0xf42ed61450458ee4620f5ef4f29adb25a6ef0fb6000000000000000000000bf8",
  "0xf48f01dcb2cbb3ee1f6aab0e742c2d3941039d56000000000000000000000445",
  "0xf93579002dbe8046c43fefe86ec78b1112247bb8000000000000000000000759",
  "0xf984eb2b8a7ef780245a797a2fccd82f346409ca000000000000000000000a59",
  "0xfa2c0bd8327c99db5bde4c9e9e5cbf30946351bb000000000000000000000948",
  "0xff4ce5aaab5a627bf82f4a571ab1ce94aa365ea600000000000000000000075a",
  "0x1ac55c31dac78ca943cb8ebfca5945ce09e036e2000000000000000000000024",
  "0x225e0047671939a8d78e08ebd692788abe63f15c000000000000000000000009",
  "0x41211bba6d37f5a74b22e667533f080c7c7f3f1300000000000000000000000b",
  "0x4de21b365d6543661d0e105e579a34b963862497000200000000000000000045",
  "0x581ec1f5e7ced12b186deae32256adb53bdd5b08000000000000000000000001",
  "0x66f33ae36dd80327744207a48122f874634b3ada000100000000000000000013",
  "0xa3ed6f78edc29f69df8a0d16b1d1ccf9871f918c000000000000000000000032",
  "0xa611a551b95b205ccd9490657acf7899daee5db700000000000000000000002e",
  "0xb95829adbacd8af89e291dee78bc09e24de51d6b000000000000000000000043",
  "0xb973ca96a3f0d61045f53255e319aedb6ed49240000200000000000000000011",
  "0xba1a5b19d09a79dada039b1f974015c5a989d5fd000100000000000000000046",
  "0xbb9cd48d33033f5effbedec9dd700c7d7e1dcf5000000000000000000000000e",
  "0xd16f72b02da5f51231fde542a8b9e2777a478c8800000000000000000000000f",
  "0xd4015683b8153666190e0b2bec352580ebc4caca00000000000000000000000d",
  "0xe15cac1df3621e001f76210ab12a7f1a1691481f000000000000000000000044",
  "0xe7f88d7d4ef2eb18fcf9dd7216ba7da1c46f3dd600000000000000000000000a",
  "0xf48f01dcb2cbb3ee1f6aab0e742c2d3941039d56000200000000000000000012",
  "0xfedb19ec000d38d92af4b21436870f115db22725000000000000000000000010",
  "0xffff76a3280e95dc855696111c2562da09db2ac000000000000000000000000c",
  "0x00fcd3d55085e998e291a0005cedecf58ac14c4000020000000000000000047f",
  "0x077794c30afeccdf5ad2abc0588e8cee7197b71a000000000000000000000352",
  "0x117a3d474976274b37b7b94af5dcade5c90c6e85000000000000000000000381",
  "0x11884da90fb4221b3aa288a7741c51ec4fc43b2f000000000000000000000353",
  "0x19b1c92631405a0a9495ccba0becf4f2e8e908bd000000000000000000000410",
  "0x1e550b7764da9638fdd32c8a701364de31f45ee800000000000000000000047c",
  "0x1fa7f727934226aedab636d62a084931b97d366b000000000000000000000411",
  "0x23ca0306b21ea71552b148cf3c4db4fc85ae19290000000000000000000000c9",
  "0x284eb68520c8fa83361c1a3a5910aec7f873c18b000000000000000000000380",
  "0x2a96254ca32020b20ed3506f8f75318da24709f9000200000000000000000456",
  "0x36942963e3b6f37ecc45a4e72349558514233f0000000000000000000000048a",
  "0x3f53a862919ccfa023cb6ace91378a79fb0f6bf500000000000000000000040f",
  "0x40af308e3d07ec769d85eb80afb116525ff4ac99000000000000000000000485",
  "0x418de00ae109e6f874d872658767866d680eaa1900000000000000000000047d",
  "0x45c4d1376943ab28802b995acffc04903eb5223f000000000000000000000470",
  "0x4689122d360c4725d244c5cfea22861333d862e6000100000000000000000468",
  "0x4739e50b59b552d490d3fdc60d200977a38510c0000000000000000000000409",
  "0x49a0e3334496442a9706e481617724e7e37eaa080000000000000000000003ff",
  "0x519cce718fcd11ac09194cff4517f12d263be067000000000000000000000382",
  "0x52cc8389c6b93d740325729cc7c958066cee4262000000000000000000000408",
  "0x567ecfcb22205d279bb8eed3e066989902bf03d5000000000000000000000452",
  "0x585d95df0231fa08aeee35ff0c16b92fd0ecdc3300020000000000000000045f",
  "0x5a7f39435fd9c381e4932fa2047c9a5136a5e3e7000000000000000000000400",
  "0x5bae72b75caab1f260d21bc028c630140607d6e8000000000000000000000350",
  "0x6cb787a419c3e6ee2e9ff365856c29cd10659113000000000000000000000474",
  "0x7c82a23b4c48d796dee36a9ca215b641c6a8709d000000000000000000000406",
  "0x81fc12c60ee5b753cf5fd0adc342dfb5f3817e3200000000000000000000035d",
  "0x894c82800526e0391e709c0983a5aea3718b7f6d00000000000000000000034f",
  "0x970712708a08e8fb152be4d81b2dc586923f5369000200000000000000000479",
  "0x9bf7c3b63c77b4b4f2717776f15a4bec1b532a280000000000000000000000c8",
  "0x9cebf13bb702f253abf1579294694a1edad00eaa000000000000000000000486",
  "0x9e34631547adcf2f8cefa0f5f223955c7b137571000000000000000000000407",
  "0x9fb7d6dcac7b6aa20108bad226c35b85a9e31b63000200000000000000000412",
  "0xa1ea76c42b2938cfa9abea12357881006c52851300000000000000000000048f",
  "0xa50f89e9f439fde2a6fe05883721a00475da3c4500000000000000000000048b",
  "0xa612b6aed2e7ca1a3a4f23fbca9128461bbb7718000000000000000000000274",
  "0xa8af146d79ac0bb981e4e0d8b788ec5711b1d5d000000000000000000000047b",
  "0xad28940024117b442a9efb6d0f25c8b59e1c950b00000000000000000000046f",
  "0xae646817e458c0be890b81e8d880206710e3c44e00000000000000000000039d",
  "0xaef2c171dbe64b0c18977e16e70bfd29d4ee0256000000000000000000000351",
  "0xbbf9d705b75f408cfcaee91da32966124d2c6f7d00000000000000000000047e",
  "0xbd724eb087d4cc0f61a5fed1fffaf937937e14de000000000000000000000473",
  "0xbe0f30217be1e981add883848d0773a86d2d2cd4000000000000000000000471",
  "0xc46be4b8bb6b5a3d3120660efae9c5416318ed40000000000000000000000472",
  "0xc69771058481551261709d8db44977e9afde645000010000000000000000042a",
  "0xc6eee8cb7643ec2f05f46d569e9ec8ef8b41b389000000000000000000000475",
  "0xcba9ff45cfb9ce238afde32b0148eb82cbe635620000000000000000000003fd",
  "0xcf8b555b7754556cf2ac2165e77ee23ed8517d7900020000000000000000045e",
  "0xd0dc20e6342db2de82692b8dc842301ff9121805000200000000000000000454",
  "0xd3d5d45f4edf82ba0dfaf061d230766032a10e07000200000000000000000413",
  "0xd6d20527c7b0669989ee082b9d3a1c63af742290000000000000000000000483",
  "0xda1cd1711743e57dd57102e9e61b75f3587703da0000000000000000000003fc",
  "0xe1fb90d0d3b47e551d494d7ebe8f209753526b0100000000000000000000034e",
  "0xee02583596aee94cccb7e8ccd3921d955f17982a00000000000000000000040a",
  "0xf984eb2b8a7ef780245a797a2fccd82f346409ca00000000000000000000034d",
  "0xff8f84e8c87532af96aef5582ee451572233678b000200000000000000000478",
  "0x054e7b0c73e1ee5aed6864fa511658fc2b54bcaa000000000000000000000015",
  "0x3f1a2c4a3a751f6626bd90ef16e104f0772d4d6b00020000000000000000001b",
  "0x7275c131b1f67e8b53b4691f92b0e35a4c1c6e22000000000000000000000010",
  "0xa154009870e9b6431305f19b09f9cfd7284d4e7a000000000000000000000013",
  "0xa1d14d922a575232066520eda11e27760946c991000000000000000000000012",
  "0xa826a114b0c7db4d1ff4a4be845a78998c64564c000000000000000000000008",
  "0xea67626e1f0b59e0d172a04f5702ef90bcdf440c00000000000000000000000f",
  "0xeb496161099d45b3ea4892408ef745c6182eb56e00000000000000000000000e",
  "0xece571847897fd61e764d455dc15cf1cd9de8d6f000000000000000000000014",
  "0xed3e2f496cbcd8e212192fb8d1499842f04a0d19000000000000000000000009",
  "0x02c9dcb975262719a61f9b40bdf0987ead9add3a000000000000000000000006",
  "0x16c9a4d841e88e52b51936106010f27085a529ec00000000000000000000000c",
  "0x32be2d0ddeaf3333501b24a28668ce373ba8e763000200000000000000000014",
  "0x32f03464fdf909fdf3798f87ff3712b10c59bd86000000000000000000000005",
  "0x4b718e0e2fea1da68b763cd50c446fba03ceb2ea00000000000000000000000b",
  "0x68a69c596b3839023c0e08d09682314f582314e5000200000000000000000011",
  "0x6f34a44fce1506352a171232163e7716dd073ade000200000000000000000015",
  "0x9e2d87f904862671eb49cb358e74284762cc9f42000200000000000000000013",
  "0xac4b72c01072a52b73ca71105504f1372efcce0d000000000000000000000003",
  "0xbfd65c6160cfd638a85c645e6e6d8acac5dac935000000000000000000000004",
  "0xe274c9deb6ed34cfe4130f8d0a8a948dea5bb28600000000000000000000000d",
  "0x1f131ec1175f023ee1534b16fa8ab237c00e238100000000000000000000004a",
  "0x479a7d1fcdd71ce0c2ed3184bfbe9d23b92e8337000000000000000000000049",
  "0x23ca0306b21ea71552b148cf3c4db4fc85ae19290000000000000000000000ac",
  "0x43da214fab3315aa6c02e0b8f2bfb7ef2e3c60a50000000000000000000000ae",
  "0x62cf35db540152e94936de63efc90d880d4e241b0000000000000000000000ef",
  "0x098f32d98d0d64dba199fc1923d3bf4192e787190001000000000000000000d2",
  "0xb1c9ac57594e9b1ec0f3787d9f6744ef4cb0a02400000000000000000000006e",
  "0x05e7732bf9ae5592e6aa05afe8cd80f7ab0a7bea00020000000000000000005a",
  "0xde45f101250f2ca1c0f8adfc172576d10c12072d00000000000000000000003f",
  "0x981fb05b738e981ac532a99e77170ecb4bc27aef00010000000000000000004b",
  "0x6222ae1d2a9f6894da50aa25cb7b303497f9bebd000000000000000000000046",
  "0x3c74c4ed512050eb843d89fb9dcd5ebb4668eb6d0002000000000000000000cc",
  "0x7fe29a818438ed2759e30f65c2302295711d66fc0000000000000000000000e5",
  "0xb0de49429fbb80c635432bbad0b3965b2856017700010000000000000000004e",
  "0x428e1cc3099cf461b87d124957a0d48273f334b100000000000000000000007f",
  "0x359ea8618c405023fc4b98dab1b01f373792a12600010000000000000000004f",
  "0x62de5ca16a618e22f6dfe5315ebd31acb10c44b6000000000000000000000037",
  "0x7d6bff131b359da66d92f215fd4e186003bfaa42000000000000000000000058",
  "0x9964b1bd3cc530e5c58ba564e45d45290f677be2000000000000000000000036",
  "0x2c4a83f98d1cdbeeec825fabacd09c46e2dd3c570002000000000000000000de",
  "0x8b6d3aa69c1cf47677281691b1abf3831ba1329d0001000000000000000000d0",
  "0x64cee2338369aa9b36fc756ea231eb9bc242926f0000000000000000000000df",
  "0xe0b50b0635b90f7021d2618f76ab9a31b92d009400010000000000000000003a",
  "0x8a2872fd28f42bd9f6559907235e83fbf4167f480001000000000000000000f2",
  "0x362715c164d606682c4ea7e479633e419d9345eb0001000000000000000000e7",
  "0xcd7b2232b7435595bbc7fd7962f1f352fc2cc61a0000000000000000000000f0",
  "0xf572649606db4743d217a2fa6e8b8eb79742c24a000000000000000000000039",
  "0xbec621c9ab4ceddcc2a157ca9b5c475fab65f6a40000000000000000000000f3",
  "0x5470f064a19c65263b3033da3a6124fdf0a9bab80000000000000000000000e6",
  "0xcb89e89d798a4563d1599ea5508282e13b225b520000000000000000000000e4",
  "0xe94c45de980f914904fdcfa9fbbe7c4a0ffe6ac70000000000000000000000e0",
  "0x435272180a4125f3b47c92826f482fc6cc165958000200000000000000000059",
  "0x96a78983932b8739d1117b16d30c15607926b0c500000000000000000000006d",
  "0x593acbfb1eaf3b6ec86fa60325d816996fdcbc0d000000000000000000000038",
  "0xd1af4974fcc995cf36ba40b189caa92964a9126d0000000000000000000000f1"
];

// src/entities/tokenAmount.ts
var _decimaljslight = require('decimal.js-light'); var _decimaljslight2 = _interopRequireDefault(_decimaljslight);


// src/utils/math.ts
var WAD = 1000000000000000000n;
var RAY = 1000000000000000000000000000000000000n;
var TWO_WAD = 2000000000000000000n;
var FOUR_WAD = 4000000000000000000n;
var HUNDRED_WAD = 100000000000000000000n;
var abs = (n) => n < 0n ? -n : n;
var min = (values) => values.reduce((a, b) => a < b ? a : b);
var max = (values) => values.reduce((a, b) => a > b ? a : b);
var _require = (b, message) => {
  if (!b)
    throw new Error(message);
};
var _MathSol = class {
  static max(a, b) {
    return a >= b ? a : b;
  }
  static min(a, b) {
    return a < b ? a : b;
  }
  static mulDownFixed(a, b) {
    const product = a * b;
    return product / WAD;
  }
  static mulUpFixed(a, b) {
    const product = a * b;
    if (product === 0n) {
      return 0n;
    }
    return (product - 1n) / WAD + 1n;
  }
  static divDownFixed(a, b) {
    if (a === 0n) {
      return 0n;
    }
    const aInflated = a * WAD;
    return aInflated / b;
  }
  static divUpFixed(a, b) {
    if (a === 0n) {
      return 0n;
    }
    const aInflated = a * WAD;
    return (aInflated - 1n) / b + 1n;
  }
  static divUp(a, b) {
    if (a === 0n) {
      return 0n;
    }
    return 1n + (a - 1n) / b;
  }
  // version = poolTypeVersion
  static powUpFixed(x, y, version) {
    if (y === WAD && version !== 1) {
      return x;
    }
    if (y === TWO_WAD && version !== 1) {
      return _MathSol.mulUpFixed(x, x);
    }
    if (y === FOUR_WAD && version !== 1) {
      const square = _MathSol.mulUpFixed(x, x);
      return _MathSol.mulUpFixed(square, square);
    }
    const raw = LogExpMath.pow(x, y);
    const maxError = _MathSol.mulUpFixed(raw, _MathSol.MAX_POW_RELATIVE_ERROR) + 1n;
    return raw + maxError;
  }
  // version = poolTypeVersion
  static powDownFixed(x, y, version) {
    if (y === WAD && version !== 1) {
      return x;
    }
    if (y === TWO_WAD && version !== 1) {
      return _MathSol.mulUpFixed(x, x);
    }
    if (y === FOUR_WAD && version !== 1) {
      const square = _MathSol.mulUpFixed(x, x);
      return _MathSol.mulUpFixed(square, square);
    }
    const raw = LogExpMath.pow(x, y);
    const maxError = _MathSol.mulUpFixed(raw, _MathSol.MAX_POW_RELATIVE_ERROR) + 1n;
    if (raw < maxError) {
      return 0n;
    }
    return raw - maxError;
  }
  static complementFixed(x) {
    return x < WAD ? WAD - x : 0n;
  }
};
var MathSol = _MathSol;
__publicField(MathSol, "MAX_POW_RELATIVE_ERROR", 10000n);
var _LogExpMath = class {
  // eˆ(x11)
  // All arguments and return values are 18 decimal fixed point numbers.
  static pow(x, y) {
    if (y === 0n) {
      return WAD;
    }
    if (x === 0n) {
      return 0n;
    }
    _require(
      x < 57896044618658097711785492504343953926634992332820282019728792003956564819968n,
      "Errors.X_OUT_OF_BOUNDS"
    );
    const x_int256 = x;
    _require(y < _LogExpMath.MILD_EXPONENT_BOUND, "Errors.Y_OUT_OF_BOUNDS");
    const y_int256 = y;
    let logx_times_y;
    if (_LogExpMath.LN_36_LOWER_BOUND < x_int256 && x_int256 < _LogExpMath.LN_36_UPPER_BOUND) {
      const ln_36_x = _LogExpMath._ln_36(x_int256);
      logx_times_y = ln_36_x / WAD * y_int256 + ln_36_x % WAD * y_int256 / WAD;
    } else {
      logx_times_y = _LogExpMath._ln(x_int256) * y_int256;
    }
    logx_times_y /= WAD;
    _require(
      _LogExpMath.MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= _LogExpMath.MAX_NATURAL_EXPONENT,
      "Errors.PRODUCT_OUT_OF_BOUNDS"
    );
    return _LogExpMath.exp(logx_times_y);
  }
  static exp(x_) {
    let x = x_;
    _require(
      x >= _LogExpMath.MIN_NATURAL_EXPONENT && x <= _LogExpMath.MAX_NATURAL_EXPONENT,
      "Errors.INVALID_EXPONENT"
    );
    if (x < 0) {
      return WAD * WAD / _LogExpMath.exp(-1n * x);
    }
    let firstAN;
    if (x >= _LogExpMath.x0) {
      x -= _LogExpMath.x0;
      firstAN = _LogExpMath.a0;
    } else if (x >= _LogExpMath.x1) {
      x -= _LogExpMath.x1;
      firstAN = _LogExpMath.a1;
    } else {
      firstAN = 1n;
    }
    x *= 100n;
    let product = HUNDRED_WAD;
    if (x >= _LogExpMath.x2) {
      x -= _LogExpMath.x2;
      product = product * _LogExpMath.a2 / HUNDRED_WAD;
    }
    if (x >= _LogExpMath.x3) {
      x -= _LogExpMath.x3;
      product = product * _LogExpMath.a3 / HUNDRED_WAD;
    }
    if (x >= _LogExpMath.x4) {
      x -= _LogExpMath.x4;
      product = product * _LogExpMath.a4 / HUNDRED_WAD;
    }
    if (x >= _LogExpMath.x5) {
      x -= _LogExpMath.x5;
      product = product * _LogExpMath.a5 / HUNDRED_WAD;
    }
    if (x >= _LogExpMath.x6) {
      x -= _LogExpMath.x6;
      product = product * _LogExpMath.a6 / HUNDRED_WAD;
    }
    if (x >= _LogExpMath.x7) {
      x -= _LogExpMath.x7;
      product = product * _LogExpMath.a7 / HUNDRED_WAD;
    }
    if (x >= _LogExpMath.x8) {
      x -= _LogExpMath.x8;
      product = product * _LogExpMath.a8 / HUNDRED_WAD;
    }
    if (x >= _LogExpMath.x9) {
      x -= _LogExpMath.x9;
      product = product * _LogExpMath.a9 / HUNDRED_WAD;
    }
    let seriesSum = HUNDRED_WAD;
    let term;
    term = x;
    seriesSum += term;
    term = term * x / HUNDRED_WAD / 2n;
    seriesSum += term;
    term = term * x / HUNDRED_WAD / 3n;
    seriesSum += term;
    term = term * x / HUNDRED_WAD / 4n;
    seriesSum += term;
    term = term * x / HUNDRED_WAD / 5n;
    seriesSum += term;
    term = term * x / HUNDRED_WAD / 6n;
    seriesSum += term;
    term = term * x / HUNDRED_WAD / 7n;
    seriesSum += term;
    term = term * x / HUNDRED_WAD / 8n;
    seriesSum += term;
    term = term * x / HUNDRED_WAD / 9n;
    seriesSum += term;
    term = term * x / HUNDRED_WAD / 10n;
    seriesSum += term;
    term = term * x / HUNDRED_WAD / 11n;
    seriesSum += term;
    term = term * x / HUNDRED_WAD / 12n;
    seriesSum += term;
    return product * seriesSum / HUNDRED_WAD * firstAN / 100n;
  }
  static _ln_36(x_) {
    let x = x_;
    x *= WAD;
    const z = (x - RAY) * RAY / (x + RAY);
    const z_squared = z * z / RAY;
    let num = z;
    let seriesSum = num;
    num = num * z_squared / RAY;
    seriesSum += num / 3n;
    num = num * z_squared / RAY;
    seriesSum += num / 5n;
    num = num * z_squared / RAY;
    seriesSum += num / 7n;
    num = num * z_squared / RAY;
    seriesSum += num / 9n;
    num = num * z_squared / RAY;
    seriesSum += num / 11n;
    num = num * z_squared / RAY;
    seriesSum += num / 13n;
    num = num * z_squared / RAY;
    seriesSum += num / 15n;
    return seriesSum * 2n;
  }
  /**
   * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.
   */
  static _ln(a_) {
    let a = a_;
    if (a < WAD) {
      return -1n * _LogExpMath._ln(WAD * WAD / a);
    }
    let sum = 0n;
    if (a >= _LogExpMath.a0 * WAD) {
      a /= _LogExpMath.a0;
      sum += _LogExpMath.x0;
    }
    if (a >= _LogExpMath.a1 * WAD) {
      a /= _LogExpMath.a1;
      sum += _LogExpMath.x1;
    }
    sum *= 100n;
    a *= 100n;
    if (a >= _LogExpMath.a2) {
      a = a * HUNDRED_WAD / _LogExpMath.a2;
      sum += _LogExpMath.x2;
    }
    if (a >= _LogExpMath.a3) {
      a = a * HUNDRED_WAD / _LogExpMath.a3;
      sum += _LogExpMath.x3;
    }
    if (a >= _LogExpMath.a4) {
      a = a * HUNDRED_WAD / _LogExpMath.a4;
      sum += _LogExpMath.x4;
    }
    if (a >= _LogExpMath.a5) {
      a = a * HUNDRED_WAD / _LogExpMath.a5;
      sum += _LogExpMath.x5;
    }
    if (a >= _LogExpMath.a6) {
      a = a * HUNDRED_WAD / _LogExpMath.a6;
      sum += _LogExpMath.x6;
    }
    if (a >= _LogExpMath.a7) {
      a = a * HUNDRED_WAD / _LogExpMath.a7;
      sum += _LogExpMath.x7;
    }
    if (a >= _LogExpMath.a8) {
      a = a * HUNDRED_WAD / _LogExpMath.a8;
      sum += _LogExpMath.x8;
    }
    if (a >= _LogExpMath.a9) {
      a = a * HUNDRED_WAD / _LogExpMath.a9;
      sum += _LogExpMath.x9;
    }
    if (a >= _LogExpMath.a10) {
      a = a * HUNDRED_WAD / _LogExpMath.a10;
      sum += _LogExpMath.x10;
    }
    if (a >= _LogExpMath.a11) {
      a = a * HUNDRED_WAD / _LogExpMath.a11;
      sum += _LogExpMath.x11;
    }
    const z = (a - HUNDRED_WAD) * HUNDRED_WAD / (a + HUNDRED_WAD);
    const z_squared = z * z / HUNDRED_WAD;
    let num = z;
    let seriesSum = num;
    num = num * z_squared / HUNDRED_WAD;
    seriesSum += num / 3n;
    num = num * z_squared / HUNDRED_WAD;
    seriesSum += num / 5n;
    num = num * z_squared / HUNDRED_WAD;
    seriesSum += num / 7n;
    num = num * z_squared / HUNDRED_WAD;
    seriesSum += num / 9n;
    num = num * z_squared / HUNDRED_WAD;
    seriesSum += num / 11n;
    seriesSum *= 2n;
    return (sum + seriesSum) / 100n;
  }
};
var LogExpMath = _LogExpMath;
// All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying
// two numbers, and multiply by ONE when dividing them.
// The domain of natural exponentiation is bound by the word size and number of decimals used.
//
// Because internally the result will be stored using 20 decimals, the largest possible result is
// (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.
// The smallest possible result is 10^(-18), which makes largest negative argument
// ln(10^(-18)) = -41.446531673892822312.
// We use 130.0 and -41.0 to have some safety margin.
__publicField(LogExpMath, "MAX_NATURAL_EXPONENT", 130000000000000000000n);
__publicField(LogExpMath, "MIN_NATURAL_EXPONENT", -41000000000000000000n);
// Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point
// 256 bit integer.
__publicField(LogExpMath, "LN_36_LOWER_BOUND", WAD - 100000000000000000n);
__publicField(LogExpMath, "LN_36_UPPER_BOUND", WAD + 100000000000000000n);
// static MILD_EXPONENT_BOUND: bigint = 2 ** 254 / HUNDRED_WAD;
// Precomputed value of the above expression
__publicField(LogExpMath, "MILD_EXPONENT_BOUND", 289480223093290488558927462521719769633174961664101410098n);
// 18 decimal constants
__publicField(LogExpMath, "x0", 128000000000000000000n);
// 2ˆ7
__publicField(LogExpMath, "a0", 38877084059945950922200000000000000000000000000000000000n);
// eˆ(x0) (no decimals)
__publicField(LogExpMath, "x1", 64000000000000000000n);
// 2ˆ6
__publicField(LogExpMath, "a1", 6235149080811616882910000000n);
// eˆ(x1) (no decimals)
// 20 decimal constants
__publicField(LogExpMath, "x2", 3200000000000000000000n);
// 2ˆ5
__publicField(LogExpMath, "a2", 7896296018268069516100000000000000n);
// eˆ(x2)
__publicField(LogExpMath, "x3", 1600000000000000000000n);
// 2ˆ4
__publicField(LogExpMath, "a3", 888611052050787263676000000n);
// eˆ(x3)
__publicField(LogExpMath, "x4", 800000000000000000000n);
// 2ˆ3
__publicField(LogExpMath, "a4", 298095798704172827474000n);
// eˆ(x4)
__publicField(LogExpMath, "x5", 400000000000000000000n);
// 2ˆ2
__publicField(LogExpMath, "a5", 5459815003314423907810n);
// eˆ(x5)
__publicField(LogExpMath, "x6", 200000000000000000000n);
// 2ˆ1
__publicField(LogExpMath, "a6", 738905609893065022723n);
// eˆ(x6)
__publicField(LogExpMath, "x7", 100000000000000000000n);
// 2ˆ0
__publicField(LogExpMath, "a7", 271828182845904523536n);
// eˆ(x7)
__publicField(LogExpMath, "x8", 50000000000000000000n);
// 2ˆ-1
__publicField(LogExpMath, "a8", 164872127070012814685n);
// eˆ(x8)
__publicField(LogExpMath, "x9", 25000000000000000000n);
// 2ˆ-2
__publicField(LogExpMath, "a9", 128402541668774148407n);
// eˆ(x9)
__publicField(LogExpMath, "x10", 12500000000000000000n);
// 2ˆ-3
__publicField(LogExpMath, "a10", 113314845306682631683n);
// eˆ(x10)
__publicField(LogExpMath, "x11", 6250000000000000000n);
// 2ˆ-4
__publicField(LogExpMath, "a11", 106449445891785942956n);

// src/entities/tokenAmount.ts
var TokenAmount = class {
  constructor(token, amount) {
    __publicField(this, "token");
    __publicField(this, "scalar");
    __publicField(this, "decimalScale");
    __publicField(this, "amount");
    __publicField(this, "scale18");
    this.decimalScale = DECIMAL_SCALES[token.decimals];
    this.token = token;
    this.amount = BigInt(amount);
    this.scalar = DECIMAL_SCALES[18 - token.decimals];
    this.scale18 = this.amount * this.scalar;
  }
  static fromRawAmount(token, rawAmount) {
    return new TokenAmount(token, rawAmount);
  }
  static fromHumanAmount(token, humanAmount) {
    const rawAmount = _viem.parseUnits.call(void 0, humanAmount, token.decimals);
    return new TokenAmount(token, rawAmount);
  }
  static fromScale18Amount(token, scale18Amount, divUp) {
    const scalar = DECIMAL_SCALES[18 - token.decimals];
    const rawAmount = divUp ? 1n + (BigInt(scale18Amount) - 1n) / scalar : BigInt(scale18Amount) / scalar;
    return new TokenAmount(token, rawAmount);
  }
  add(other) {
    return new TokenAmount(this.token, this.amount + other.amount);
  }
  sub(other) {
    return new TokenAmount(this.token, this.amount - other.amount);
  }
  mulUpFixed(other) {
    const product = this.amount * other;
    const multiplied = (product - 1n) / WAD + 1n;
    return new TokenAmount(this.token, multiplied);
  }
  mulDownFixed(other) {
    const multiplied = this.amount * other / WAD;
    return new TokenAmount(this.token, multiplied);
  }
  divUpFixed(other) {
    const divided = (this.amount * WAD + other - 1n) / other;
    return new TokenAmount(this.token, divided);
  }
  divDownFixed(other) {
    const divided = this.amount * WAD / other;
    return new TokenAmount(this.token, divided);
  }
  toSignificant(significantDigits = 6) {
    return new (0, _decimaljslight2.default)(this.amount.toString()).div(new (0, _decimaljslight2.default)(this.decimalScale.toString())).toDecimalPlaces(significantDigits).toString();
  }
  toInputAmount() {
    return {
      address: this.token.address,
      decimals: this.token.decimals,
      rawAmount: this.amount
    };
  }
};

// src/types.ts
var PoolType = /* @__PURE__ */ ((PoolType2) => {
  PoolType2["Weighted"] = "Weighted";
  PoolType2["ComposableStable"] = "ComposableStable";
  PoolType2["MetaStable"] = "MetaStable";
  PoolType2["AaveLinear"] = "AaveLinear";
  PoolType2["Fx"] = "FX";
  PoolType2["Gyro2"] = "Gyro2";
  PoolType2["Gyro3"] = "Gyro3";
  PoolType2["GyroE"] = "GyroE";
  return PoolType2;
})(PoolType || {});
var SwapKind = /* @__PURE__ */ ((SwapKind2) => {
  SwapKind2[SwapKind2["GivenIn"] = 0] = "GivenIn";
  SwapKind2[SwapKind2["GivenOut"] = 1] = "GivenOut";
  return SwapKind2;
})(SwapKind || {});

// src/utils/helpers.ts
function checkInputs(tokenIn, tokenOut, swapKind, swapAmount) {
  let amount;
  if (swapAmount instanceof TokenAmount) {
    amount = swapAmount;
  } else {
    amount = TokenAmount.fromRawAmount(
      swapKind === 0 /* GivenIn */ ? tokenIn : tokenOut,
      swapAmount
    );
  }
  if (tokenIn.chainId !== tokenOut.chainId || tokenIn.chainId !== amount.token.chainId) {
    throw new Error("ChainId mismatch for inputs");
  }
  if (swapKind === 0 /* GivenIn */ && !tokenIn.isEqual(amount.token) || swapKind === 1 /* GivenOut */ && !tokenOut.isEqual(amount.token)) {
    throw new Error("Swap amount token does not match input token");
  }
  return amount;
}

// src/utils/pool.ts
var getPoolAddress = (poolId) => {
  if (poolId.length !== 66)
    throw new Error("Invalid poolId length");
  return poolId.slice(0, 42).toLowerCase();
};
function poolIsLinearPool(poolType) {
  return poolType.includes("Linear");
}
function poolHasVirtualSupply(poolType) {
  return poolType === "PhantomStable" || poolIsLinearPool(poolType);
}
function poolHasActualSupply(poolType) {
  return poolType === "ComposableStable";
}
function poolHasPercentFee(poolType) {
  return poolType === "Element";
}

// src/abi/balancerQueries.ts
var balancerQueriesAbi = [
  {
    inputs: [
      {
        internalType: "contract IVault",
        name: "_vault",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "enum IVault.SwapKind",
        name: "kind",
        type: "uint8"
      },
      {
        components: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "assetInIndex",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "assetOutIndex",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          { internalType: "bytes", name: "userData", type: "bytes" }
        ],
        internalType: "struct IVault.BatchSwapStep[]",
        name: "swaps",
        type: "tuple[]"
      },
      {
        internalType: "contract IAsset[]",
        name: "assets",
        type: "address[]"
      },
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "bool",
            name: "fromInternalBalance",
            type: "bool"
          },
          {
            internalType: "address payable",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "bool",
            name: "toInternalBalance",
            type: "bool"
          }
        ],
        internalType: "struct IVault.FundManagement",
        name: "funds",
        type: "tuple"
      }
    ],
    name: "queryBatchSwap",
    outputs: [
      { internalType: "int256[]", name: "assetDeltas", type: "int256[]" }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      { internalType: "address", name: "recipient", type: "address" },
      {
        components: [
          {
            internalType: "contract IAsset[]",
            name: "assets",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "minAmountsOut",
            type: "uint256[]"
          },
          { internalType: "bytes", name: "userData", type: "bytes" },
          {
            internalType: "bool",
            name: "toInternalBalance",
            type: "bool"
          }
        ],
        internalType: "struct IVault.ExitPoolRequest",
        name: "request",
        type: "tuple"
      }
    ],
    name: "queryExit",
    outputs: [
      { internalType: "uint256", name: "bptIn", type: "uint256" },
      {
        internalType: "uint256[]",
        name: "amountsOut",
        type: "uint256[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      { internalType: "address", name: "recipient", type: "address" },
      {
        components: [
          {
            internalType: "contract IAsset[]",
            name: "assets",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "maxAmountsIn",
            type: "uint256[]"
          },
          { internalType: "bytes", name: "userData", type: "bytes" },
          {
            internalType: "bool",
            name: "fromInternalBalance",
            type: "bool"
          }
        ],
        internalType: "struct IVault.JoinPoolRequest",
        name: "request",
        type: "tuple"
      }
    ],
    name: "queryJoin",
    outputs: [
      { internalType: "uint256", name: "bptOut", type: "uint256" },
      { internalType: "uint256[]", name: "amountsIn", type: "uint256[]" }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "enum IVault.SwapKind",
            name: "kind",
            type: "uint8"
          },
          {
            internalType: "contract IAsset",
            name: "assetIn",
            type: "address"
          },
          {
            internalType: "contract IAsset",
            name: "assetOut",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          { internalType: "bytes", name: "userData", type: "bytes" }
        ],
        internalType: "struct IVault.SingleSwap",
        name: "singleSwap",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "bool",
            name: "fromInternalBalance",
            type: "bool"
          },
          {
            internalType: "address payable",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "bool",
            name: "toInternalBalance",
            type: "bool"
          }
        ],
        internalType: "struct IVault.FundManagement",
        name: "funds",
        type: "tuple"
      }
    ],
    name: "querySwap",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "vault",
    outputs: [
      { internalType: "contract IVault", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// src/abi/balancerRelayer.ts
var balancerRelayerAbi = [
  {
    inputs: [
      {
        internalType: "contract IVault",
        name: "vault",
        type: "address"
      },
      {
        internalType: "address",
        name: "libraryAddress",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "getLibrary",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getVault",
    outputs: [
      {
        internalType: "contract IVault",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "vaultActionsQueryMulticall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    stateMutability: "payable",
    type: "receive"
  }
];

// src/abi/batchRelayerLibrary.ts
var batchRelayerLibraryAbi = [
  {
    inputs: [
      {
        internalType: "contract IVault",
        name: "vault",
        type: "address"
      },
      {
        internalType: "contract IERC20",
        name: "wstETH",
        type: "address"
      },
      {
        internalType: "contract IBalancerMinter",
        name: "minter",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "contract IERC20",
        name: "token",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "approveVault",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum IVault.SwapKind",
        name: "kind",
        type: "uint8"
      },
      {
        components: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "assetInIndex",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "assetOutIndex",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        internalType: "struct IVault.BatchSwapStep[]",
        name: "swaps",
        type: "tuple[]"
      },
      {
        internalType: "contract IAsset[]",
        name: "assets",
        type: "address[]"
      },
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "bool",
            name: "fromInternalBalance",
            type: "bool"
          },
          {
            internalType: "address payable",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "bool",
            name: "toInternalBalance",
            type: "bool"
          }
        ],
        internalType: "struct IVault.FundManagement",
        name: "funds",
        type: "tuple"
      },
      {
        internalType: "int256[]",
        name: "limits",
        type: "int256[]"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "key",
            type: "uint256"
          }
        ],
        internalType: "struct VaultActions.OutputReference[]",
        name: "outputReferences",
        type: "tuple[]"
      }
    ],
    name: "batchSwap",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "poolId",
        type: "bytes32"
      },
      {
        internalType: "enum VaultActions.PoolKind",
        name: "kind",
        type: "uint8"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address payable",
        name: "recipient",
        type: "address"
      },
      {
        components: [
          {
            internalType: "contract IAsset[]",
            name: "assets",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "minAmountsOut",
            type: "uint256[]"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          },
          {
            internalType: "bool",
            name: "toInternalBalance",
            type: "bool"
          }
        ],
        internalType: "struct IVault.ExitPoolRequest",
        name: "request",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "key",
            type: "uint256"
          }
        ],
        internalType: "struct VaultActions.OutputReference[]",
        name: "outputReferences",
        type: "tuple[]"
      }
    ],
    name: "exitPool",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IStakingLiquidityGauge[]",
        name: "gauges",
        type: "address[]"
      }
    ],
    name: "gaugeClaimRewards",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IStakingLiquidityGauge",
        name: "gauge",
        type: "address"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "gaugeDeposit",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "gauges",
        type: "address[]"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "gaugeMint",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bool",
        name: "approval",
        type: "bool"
      },
      {
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "gaugeSetMinterApproval",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IStakingLiquidityGauge",
        name: "gauge",
        type: "address"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "gaugeWithdraw",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "getEntrypoint",
    outputs: [
      {
        internalType: "contract IBalancerRelayer",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getVault",
    outputs: [
      {
        internalType: "contract IVault",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "poolId",
        type: "bytes32"
      },
      {
        internalType: "enum VaultActions.PoolKind",
        name: "kind",
        type: "uint8"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        components: [
          {
            internalType: "contract IAsset[]",
            name: "assets",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "maxAmountsIn",
            type: "uint256[]"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          },
          {
            internalType: "bool",
            name: "fromInternalBalance",
            type: "bool"
          }
        ],
        internalType: "struct IVault.JoinPoolRequest",
        name: "request",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "joinPool",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "enum IVault.UserBalanceOpKind",
            name: "kind",
            type: "uint8"
          },
          {
            internalType: "contract IAsset",
            name: "asset",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address payable",
            name: "recipient",
            type: "address"
          }
        ],
        internalType: "struct IVault.UserBalanceOp[]",
        name: "ops",
        type: "tuple[]"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "manageUserBalance",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "ref",
        type: "uint256"
      }
    ],
    name: "peekChainedReferenceValue",
    outputs: [
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "relayer",
        type: "address"
      },
      {
        internalType: "bool",
        name: "approved",
        type: "bool"
      },
      {
        internalType: "bytes",
        name: "authorisation",
        type: "bytes"
      }
    ],
    name: "setRelayerApproval",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "stakeETH",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "stakeETHAndWrap",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "enum IVault.SwapKind",
            name: "kind",
            type: "uint8"
          },
          {
            internalType: "contract IAsset",
            name: "assetIn",
            type: "address"
          },
          {
            internalType: "contract IAsset",
            name: "assetOut",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        internalType: "struct IVault.SingleSwap",
        name: "singleSwap",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "bool",
            name: "fromInternalBalance",
            type: "bool"
          },
          {
            internalType: "address payable",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "bool",
            name: "toInternalBalance",
            type: "bool"
          }
        ],
        internalType: "struct IVault.FundManagement",
        name: "funds",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "limit",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "swap",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IStaticATokenLM",
        name: "staticToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "bool",
        name: "toUnderlying",
        type: "bool"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "unwrapAaveStaticToken",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract ICToken",
        name: "wrappedToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "unwrapCompoundV2",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IERC4626",
        name: "wrappedToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "unwrapERC4626",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IEulerToken",
        name: "wrappedToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "unwrapEuler",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IGearboxDieselToken",
        name: "wrappedToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "dieselAmount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "unwrapGearbox",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IReaperTokenVault",
        name: "vaultToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "unwrapReaperVaultToken",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IShareToken",
        name: "wrappedToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "unwrapShareToken",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract ITetuSmartVault",
        name: "wrappedToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "unwrapTetu",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IUnbuttonToken",
        name: "wrapperToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "unwrapUnbuttonToken",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "unwrapWstETH",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IYearnTokenVault",
        name: "wrappedToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "unwrapYearn",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IERC20Permit",
        name: "token",
        type: "address"
      },
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "vaultPermit",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IERC20PermitDAI",
        name: "token",
        type: "address"
      },
      {
        internalType: "address",
        name: "holder",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "expiry",
        type: "uint256"
      },
      {
        internalType: "bool",
        name: "allowed",
        type: "bool"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "vaultPermitDAI",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IStaticATokenLM",
        name: "staticToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "bool",
        name: "fromUnderlying",
        type: "bool"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "wrapAaveDynamicToken",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract ICToken",
        name: "wrappedToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "wrapCompoundV2",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IERC4626",
        name: "wrappedToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "wrapERC4626",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IEulerToken",
        name: "wrappedToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "eulerProtocol",
        type: "address"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "wrapEuler",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IGearboxDieselToken",
        name: "wrappedToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "mainAmount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "wrapGearbox",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IReaperTokenVault",
        name: "vaultToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "wrapReaperVaultToken",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IShareToken",
        name: "wrappedToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "wrapShareToken",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "wrapStETH",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract ITetuSmartVault",
        name: "wrappedToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "wrapTetu",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IUnbuttonToken",
        name: "wrapperToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "uAmount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "wrapUnbuttonToken",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IYearnTokenVault",
        name: "wrappedToken",
        type: "address"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "outputReference",
        type: "uint256"
      }
    ],
    name: "wrapYearn",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  }
];

// src/abi/vault.ts
var vaultAbi = [
  {
    inputs: [
      {
        internalType: "contract IAuthorizer",
        name: "authorizer",
        type: "address"
      },
      { internalType: "contract IWETH", name: "weth", type: "address" },
      {
        internalType: "uint256",
        name: "pauseWindowDuration",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "bufferPeriodDuration",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "contract IAuthorizer",
        name: "newAuthorizer",
        type: "address"
      }
    ],
    name: "AuthorizerChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "contract IERC20",
        name: "token",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "ExternalBalanceTransfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "contract IFlashLoanRecipient",
        name: "recipient",
        type: "address"
      },
      {
        indexed: true,
        internalType: "contract IERC20",
        name: "token",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "feeAmount",
        type: "uint256"
      }
    ],
    name: "FlashLoan",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: true,
        internalType: "contract IERC20",
        name: "token",
        type: "address"
      },
      {
        indexed: false,
        internalType: "int256",
        name: "delta",
        type: "int256"
      }
    ],
    name: "InternalBalanceChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "paused",
        type: "bool"
      }
    ],
    name: "PausedStateChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "poolId",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "liquidityProvider",
        type: "address"
      },
      {
        indexed: false,
        internalType: "contract IERC20[]",
        name: "tokens",
        type: "address[]"
      },
      {
        indexed: false,
        internalType: "int256[]",
        name: "deltas",
        type: "int256[]"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "protocolFeeAmounts",
        type: "uint256[]"
      }
    ],
    name: "PoolBalanceChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "poolId",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "assetManager",
        type: "address"
      },
      {
        indexed: true,
        internalType: "contract IERC20",
        name: "token",
        type: "address"
      },
      {
        indexed: false,
        internalType: "int256",
        name: "cashDelta",
        type: "int256"
      },
      {
        indexed: false,
        internalType: "int256",
        name: "managedDelta",
        type: "int256"
      }
    ],
    name: "PoolBalanceManaged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "poolId",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "poolAddress",
        type: "address"
      },
      {
        indexed: false,
        internalType: "enum IVault.PoolSpecialization",
        name: "specialization",
        type: "uint8"
      }
    ],
    name: "PoolRegistered",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "relayer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "RelayerApprovalChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "poolId",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "contract IERC20",
        name: "tokenIn",
        type: "address"
      },
      {
        indexed: true,
        internalType: "contract IERC20",
        name: "tokenOut",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amountIn",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amountOut",
        type: "uint256"
      }
    ],
    name: "Swap",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "poolId",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "contract IERC20[]",
        name: "tokens",
        type: "address[]"
      }
    ],
    name: "TokensDeregistered",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "poolId",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "contract IERC20[]",
        name: "tokens",
        type: "address[]"
      },
      {
        indexed: false,
        internalType: "address[]",
        name: "assetManagers",
        type: "address[]"
      }
    ],
    name: "TokensRegistered",
    type: "event"
  },
  {
    inputs: [],
    name: "WETH",
    outputs: [
      { internalType: "contract IWETH", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum IVault.SwapKind",
        name: "kind",
        type: "uint8"
      },
      {
        components: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "assetInIndex",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "assetOutIndex",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          { internalType: "bytes", name: "userData", type: "bytes" }
        ],
        internalType: "struct IVault.BatchSwapStep[]",
        name: "swaps",
        type: "tuple[]"
      },
      {
        internalType: "contract IAsset[]",
        name: "assets",
        type: "address[]"
      },
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "bool",
            name: "fromInternalBalance",
            type: "bool"
          },
          {
            internalType: "address payable",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "bool",
            name: "toInternalBalance",
            type: "bool"
          }
        ],
        internalType: "struct IVault.FundManagement",
        name: "funds",
        type: "tuple"
      },
      { internalType: "int256[]", name: "limits", type: "int256[]" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "batchSwap",
    outputs: [
      { internalType: "int256[]", name: "assetDeltas", type: "int256[]" }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      {
        internalType: "contract IERC20[]",
        name: "tokens",
        type: "address[]"
      }
    ],
    name: "deregisterTokens",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address payable",
        name: "recipient",
        type: "address"
      },
      {
        components: [
          {
            internalType: "contract IAsset[]",
            name: "assets",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "minAmountsOut",
            type: "uint256[]"
          },
          { internalType: "bytes", name: "userData", type: "bytes" },
          {
            internalType: "bool",
            name: "toInternalBalance",
            type: "bool"
          }
        ],
        internalType: "struct IVault.ExitPoolRequest",
        name: "request",
        type: "tuple"
      }
    ],
    name: "exitPool",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IFlashLoanRecipient",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "contract IERC20[]",
        name: "tokens",
        type: "address[]"
      },
      { internalType: "uint256[]", name: "amounts", type: "uint256[]" },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "flashLoan",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "selector", type: "bytes4" }],
    name: "getActionId",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAuthorizer",
    outputs: [
      { internalType: "contract IAuthorizer", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getDomainSeparator",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "user", type: "address" },
      {
        internalType: "contract IERC20[]",
        name: "tokens",
        type: "address[]"
      }
    ],
    name: "getInternalBalance",
    outputs: [
      { internalType: "uint256[]", name: "balances", type: "uint256[]" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "user", type: "address" }],
    name: "getNextNonce",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPausedState",
    outputs: [
      { internalType: "bool", name: "paused", type: "bool" },
      {
        internalType: "uint256",
        name: "pauseWindowEndTime",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "bufferPeriodEndTime",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes32", name: "poolId", type: "bytes32" }],
    name: "getPool",
    outputs: [
      { internalType: "address", name: "", type: "address" },
      {
        internalType: "enum IVault.PoolSpecialization",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "contract IERC20", name: "token", type: "address" }
    ],
    name: "getPoolTokenInfo",
    outputs: [
      { internalType: "uint256", name: "cash", type: "uint256" },
      { internalType: "uint256", name: "managed", type: "uint256" },
      {
        internalType: "uint256",
        name: "lastChangeBlock",
        type: "uint256"
      },
      { internalType: "address", name: "assetManager", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes32", name: "poolId", type: "bytes32" }],
    name: "getPoolTokens",
    outputs: [
      {
        internalType: "contract IERC20[]",
        name: "tokens",
        type: "address[]"
      },
      { internalType: "uint256[]", name: "balances", type: "uint256[]" },
      {
        internalType: "uint256",
        name: "lastChangeBlock",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getProtocolFeesCollector",
    outputs: [
      {
        internalType: "contract ProtocolFeesCollector",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "user", type: "address" },
      { internalType: "address", name: "relayer", type: "address" }
    ],
    name: "hasApprovedRelayer",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      { internalType: "address", name: "recipient", type: "address" },
      {
        components: [
          {
            internalType: "contract IAsset[]",
            name: "assets",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "maxAmountsIn",
            type: "uint256[]"
          },
          { internalType: "bytes", name: "userData", type: "bytes" },
          {
            internalType: "bool",
            name: "fromInternalBalance",
            type: "bool"
          }
        ],
        internalType: "struct IVault.JoinPoolRequest",
        name: "request",
        type: "tuple"
      }
    ],
    name: "joinPool",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "enum IVault.PoolBalanceOpKind",
            name: "kind",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "contract IERC20",
            name: "token",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        internalType: "struct IVault.PoolBalanceOp[]",
        name: "ops",
        type: "tuple[]"
      }
    ],
    name: "managePoolBalance",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "enum IVault.UserBalanceOpKind",
            name: "kind",
            type: "uint8"
          },
          {
            internalType: "contract IAsset",
            name: "asset",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address payable",
            name: "recipient",
            type: "address"
          }
        ],
        internalType: "struct IVault.UserBalanceOp[]",
        name: "ops",
        type: "tuple[]"
      }
    ],
    name: "manageUserBalance",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum IVault.SwapKind",
        name: "kind",
        type: "uint8"
      },
      {
        components: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "assetInIndex",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "assetOutIndex",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          { internalType: "bytes", name: "userData", type: "bytes" }
        ],
        internalType: "struct IVault.BatchSwapStep[]",
        name: "swaps",
        type: "tuple[]"
      },
      {
        internalType: "contract IAsset[]",
        name: "assets",
        type: "address[]"
      },
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "bool",
            name: "fromInternalBalance",
            type: "bool"
          },
          {
            internalType: "address payable",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "bool",
            name: "toInternalBalance",
            type: "bool"
          }
        ],
        internalType: "struct IVault.FundManagement",
        name: "funds",
        type: "tuple"
      }
    ],
    name: "queryBatchSwap",
    outputs: [{ internalType: "int256[]", name: "", type: "int256[]" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum IVault.PoolSpecialization",
        name: "specialization",
        type: "uint8"
      }
    ],
    name: "registerPool",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      {
        internalType: "contract IERC20[]",
        name: "tokens",
        type: "address[]"
      },
      {
        internalType: "address[]",
        name: "assetManagers",
        type: "address[]"
      }
    ],
    name: "registerTokens",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IAuthorizer",
        name: "newAuthorizer",
        type: "address"
      }
    ],
    name: "setAuthorizer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bool", name: "paused", type: "bool" }],
    name: "setPaused",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "sender", type: "address" },
      { internalType: "address", name: "relayer", type: "address" },
      { internalType: "bool", name: "approved", type: "bool" }
    ],
    name: "setRelayerApproval",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "enum IVault.SwapKind",
            name: "kind",
            type: "uint8"
          },
          {
            internalType: "contract IAsset",
            name: "assetIn",
            type: "address"
          },
          {
            internalType: "contract IAsset",
            name: "assetOut",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          { internalType: "bytes", name: "userData", type: "bytes" }
        ],
        internalType: "struct IVault.SingleSwap",
        name: "singleSwap",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "bool",
            name: "fromInternalBalance",
            type: "bool"
          },
          {
            internalType: "address payable",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "bool",
            name: "toInternalBalance",
            type: "bool"
          }
        ],
        internalType: "struct IVault.FundManagement",
        name: "funds",
        type: "tuple"
      },
      { internalType: "uint256", name: "limit", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swap",
    outputs: [
      {
        internalType: "uint256",
        name: "amountCalculated",
        type: "uint256"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
];

// src/abi/composableStablePoolV5.ts
var composabableStablePoolV5Abi = [
  {
    inputs: [
      {
        components: [
          {
            internalType: "contract IVault",
            name: "vault",
            type: "address"
          },
          {
            internalType: "string",
            name: "name",
            type: "string"
          },
          {
            internalType: "string",
            name: "symbol",
            type: "string"
          },
          {
            internalType: "contract IERC20",
            name: "mainToken",
            type: "address"
          },
          {
            internalType: "contract IERC20",
            name: "wrappedToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetManager",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "upperTarget",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "swapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pauseWindowDuration",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "bufferPeriodDuration",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "string",
            name: "version",
            type: "string"
          }
        ],
        internalType: "struct AaveLinearPool.ConstructorArgs",
        name: "args",
        type: "tuple"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "paused",
        type: "bool"
      }
    ],
    name: "PausedStateChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "enabled",
        type: "bool"
      }
    ],
    name: "RecoveryModeStateChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "swapFeePercentage",
        type: "uint256"
      }
    ],
    name: "SwapFeePercentageChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "contract IERC20",
        name: "token",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "lowerTarget",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "upperTarget",
        type: "uint256"
      }
    ],
    name: "TargetsSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" }
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "decreaseAllowance",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "disableRecoveryMode",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "enableRecoveryMode",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "selector", type: "bytes4" }],
    name: "getActionId",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAuthorizer",
    outputs: [
      {
        internalType: "contract IAuthorizer",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getBptIndex",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "getDomainSeparator",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getMainIndex",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getMainToken",
    outputs: [
      { internalType: "contract IERC20", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "getNextNonce",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getOwner",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPausedState",
    outputs: [
      { internalType: "bool", name: "paused", type: "bool" },
      {
        internalType: "uint256",
        name: "pauseWindowEndTime",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "bufferPeriodEndTime",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPoolId",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getProtocolFeesCollector",
    outputs: [
      {
        internalType: "contract IProtocolFeesCollector",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getRate",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getScalingFactors",
    outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getSwapFeePercentage",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getTargets",
    outputs: [
      {
        internalType: "uint256",
        name: "lowerTarget",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "upperTarget",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getVault",
    outputs: [
      { internalType: "contract IVault", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getVirtualSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getWrappedIndex",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getWrappedToken",
    outputs: [
      { internalType: "contract IERC20", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getWrappedTokenRate",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "inRecoveryMode",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      {
        internalType: "uint256",
        name: "addedValue",
        type: "uint256"
      }
    ],
    name: "increaseAllowance",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "owner", type: "address" }],
    name: "nonces",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      { internalType: "address", name: "", type: "address" },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "onExitPool",
    outputs: [
      {
        internalType: "uint256[]",
        name: "amountsOut",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "dueProtocolFees",
        type: "uint256[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      { internalType: "address", name: "recipient", type: "address" },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "onJoinPool",
    outputs: [
      {
        internalType: "uint256[]",
        name: "amountsIn",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "dueProtocolFees",
        type: "uint256[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "enum IVault.SwapKind",
            name: "kind",
            type: "uint8"
          },
          {
            internalType: "contract IERC20",
            name: "tokenIn",
            type: "address"
          },
          {
            internalType: "contract IERC20",
            name: "tokenOut",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        internalType: "struct IPoolSwapStructs.SwapRequest",
        name: "request",
        type: "tuple"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      { internalType: "uint256", name: "indexIn", type: "uint256" },
      { internalType: "uint256", name: "indexOut", type: "uint256" }
    ],
    name: "onSwap",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "enum IVault.SwapKind",
            name: "kind",
            type: "uint8"
          },
          {
            internalType: "contract IERC20",
            name: "tokenIn",
            type: "address"
          },
          {
            internalType: "contract IERC20",
            name: "tokenOut",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        internalType: "struct IPoolSwapStructs.SwapRequest",
        name: "request",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "balanceTokenIn",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "balanceTokenOut",
        type: "uint256"
      }
    ],
    name: "onSwap",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "pause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" },
      { internalType: "uint8", name: "v", type: "uint8" },
      { internalType: "bytes32", name: "r", type: "bytes32" },
      { internalType: "bytes32", name: "s", type: "bytes32" }
    ],
    name: "permit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      { internalType: "address", name: "", type: "address" },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "queryExit",
    outputs: [
      { internalType: "uint256", name: "bptIn", type: "uint256" },
      {
        internalType: "uint256[]",
        name: "amountsOut",
        type: "uint256[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      { internalType: "address", name: "", type: "address" },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "queryJoin",
    outputs: [
      { internalType: "uint256", name: "bptOut", type: "uint256" },
      {
        internalType: "uint256[]",
        name: "amountsIn",
        type: "uint256[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "swapFeePercentage",
        type: "uint256"
      }
    ],
    name: "setSwapFeePercentage",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "newLowerTarget",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "newUpperTarget",
        type: "uint256"
      }
    ],
    name: "setTargets",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "recipient", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "sender", type: "address" },
      { internalType: "address", name: "recipient", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unpause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "version",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  }
];

// src/abi/fxPool.ts
var fxPoolAbi = [
  {
    inputs: [
      {
        internalType: "address[]",
        name: "_assetsToRegister",
        type: "address[]"
      },
      {
        internalType: "contract IVault",
        name: "vault",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_protocolPercentFee",
        type: "uint256"
      },
      { internalType: "string", name: "_name", type: "string" },
      { internalType: "string", name: "_symbol", type: "string" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "numeraire",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "reserve",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "weight",
        type: "uint256"
      }
    ],
    name: "AssetIncluded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "derivative",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "numeraire",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "reserve",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "assimilator",
        type: "address"
      }
    ],
    name: "AssimilatorIncluded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "newCollector",
        type: "address"
      }
    ],
    name: "ChangeCollectorAddress",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "isEmergency",
        type: "bool"
      }
    ],
    name: "EmergencyAlarm",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bytes32",
        name: "poolId",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "lptAmountBurned",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "amountsWithdrawn",
        type: "uint256[]"
      }
    ],
    name: "EmergencyWithdraw",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "feesCollected",
        type: "uint256"
      }
    ],
    name: "FeesAccrued",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "feesCollected",
        type: "uint256"
      }
    ],
    name: "FeesCollected",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bytes32",
        name: "poolId",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "lptAmountBurned",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "amountsWithdrawn",
        type: "uint256[]"
      }
    ],
    name: "OnExitPool",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bytes32",
        name: "poolId",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "lptAmountMinted",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "amountsDeposited",
        type: "uint256[]"
      }
    ],
    name: "OnJoinPool",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "alpha",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "beta",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "delta",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "epsilon",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "lambda",
        type: "uint256"
      }
    ],
    name: "ParametersSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Paused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "updater",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newProtocolPercentage",
        type: "uint256"
      }
    ],
    name: "ProtocolFeeShareUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "trader",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "origin",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "originAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "targetAmount",
        type: "uint256"
      }
    ],
    name: "Trade",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Unpaused",
    type: "event"
  },
  {
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" }
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_derivative",
        type: "address"
      }
    ],
    name: "assimilator",
    outputs: [
      {
        internalType: "address",
        name: "assimilator_",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "collectorAddress",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "curve",
    outputs: [
      { internalType: "int128", name: "alpha", type: "int128" },
      { internalType: "int128", name: "beta", type: "int128" },
      { internalType: "int128", name: "delta", type: "int128" },
      { internalType: "int128", name: "epsilon", type: "int128" },
      { internalType: "int128", name: "lambda", type: "int128" },
      { internalType: "uint256", name: "cap", type: "uint256" },
      {
        internalType: "contract IVault",
        name: "vault",
        type: "address"
      },
      {
        internalType: "address",
        name: "fxPoolAddress",
        type: "address"
      },
      { internalType: "bytes32", name: "poolId", type: "bytes32" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "decreaseAllowance",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    name: "derivatives",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "emergency",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPoolId",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getVault",
    outputs: [
      { internalType: "contract IVault", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      {
        internalType: "uint256",
        name: "addedValue",
        type: "uint256"
      }
    ],
    name: "increaseAllowance",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "_assets",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "_assetWeights",
        type: "uint256[]"
      }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "liquidity",
    outputs: [
      { internalType: "uint256", name: "total_", type: "uint256" },
      {
        internalType: "uint256[]",
        name: "individual_",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "owner", type: "address" }],
    name: "nonces",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    name: "numeraires",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      { internalType: "address", name: "", type: "address" },
      { internalType: "uint256[]", name: "", type: "uint256[]" },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "onExitPool",
    outputs: [
      {
        internalType: "uint256[]",
        name: "amountsOut",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "dueProtocolFeeAmounts",
        type: "uint256[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      { internalType: "uint256[]", name: "", type: "uint256[]" },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "onJoinPool",
    outputs: [
      {
        internalType: "uint256[]",
        name: "amountsIn",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "dueProtocolFeeAmounts",
        type: "uint256[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "enum IVault.SwapKind",
            name: "kind",
            type: "uint8"
          },
          {
            internalType: "contract IERC20",
            name: "tokenIn",
            type: "address"
          },
          {
            internalType: "contract IERC20",
            name: "tokenOut",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        internalType: "struct IPoolSwapStructs.SwapRequest",
        name: "swapRequest",
        type: "tuple"
      },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" }
    ],
    name: "onSwap",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "paused",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      { internalType: "uint8", name: "v", type: "uint8" },
      { internalType: "bytes32", name: "r", type: "bytes32" },
      { internalType: "bytes32", name: "s", type: "bytes32" }
    ],
    name: "permit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "protocolPercentFee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    name: "reserves",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "_cap", type: "uint256" }],
    name: "setCap",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_collectorAddress",
        type: "address"
      }
    ],
    name: "setCollectorAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bool", name: "_emergency", type: "bool" }],
    name: "setEmergency",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_alpha", type: "uint256" },
      { internalType: "uint256", name: "_beta", type: "uint256" },
      {
        internalType: "uint256",
        name: "_feeAtHalt",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_epsilon",
        type: "uint256"
      },
      { internalType: "uint256", name: "_lambda", type: "uint256" }
    ],
    name: "setParams",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "setPaused",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_protocolPercentFee",
        type: "uint256"
      }
    ],
    name: "setProtocolPercentFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalUnclaimedFeesInNumeraire",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "newOwner", type: "address" }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "totalDepositNumeraire",
        type: "uint256"
      }
    ],
    name: "viewDeposit",
    outputs: [
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256[]", name: "", type: "uint256[]" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "viewParameters",
    outputs: [
      { internalType: "uint256", name: "alpha_", type: "uint256" },
      { internalType: "uint256", name: "beta_", type: "uint256" },
      { internalType: "uint256", name: "delta_", type: "uint256" },
      {
        internalType: "uint256",
        name: "epsilon_",
        type: "uint256"
      },
      { internalType: "uint256", name: "lambda_", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_curvesToBurn",
        type: "uint256"
      }
    ],
    name: "viewWithdraw",
    outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
    stateMutability: "view",
    type: "function"
  }
];

// src/abi/GyroEV2.ts
var gyroEV2Abi = [
  {
    inputs: [
      {
        components: [
          {
            components: [
              {
                internalType: "contract IVault",
                name: "vault",
                type: "address"
              },
              {
                internalType: "string",
                name: "name",
                type: "string"
              },
              {
                internalType: "string",
                name: "symbol",
                type: "string"
              },
              {
                internalType: "contract IERC20",
                name: "token0",
                type: "address"
              },
              {
                internalType: "contract IERC20",
                name: "token1",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "swapFeePercentage",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "pauseWindowDuration",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "bufferPeriodDuration",
                type: "uint256"
              },
              {
                internalType: "bool",
                name: "oracleEnabled",
                type: "bool"
              },
              {
                internalType: "address",
                name: "owner",
                type: "address"
              }
            ],
            internalType: "struct ExtensibleWeightedPool2Tokens.NewPoolParams",
            name: "baseParams",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "int256",
                name: "alpha",
                type: "int256"
              },
              {
                internalType: "int256",
                name: "beta",
                type: "int256"
              },
              {
                internalType: "int256",
                name: "c",
                type: "int256"
              },
              {
                internalType: "int256",
                name: "s",
                type: "int256"
              },
              {
                internalType: "int256",
                name: "lambda",
                type: "int256"
              }
            ],
            internalType: "struct GyroECLPMath.Params",
            name: "eclpParams",
            type: "tuple"
          },
          {
            components: [
              {
                components: [
                  {
                    internalType: "int256",
                    name: "x",
                    type: "int256"
                  },
                  {
                    internalType: "int256",
                    name: "y",
                    type: "int256"
                  }
                ],
                internalType: "struct GyroECLPMath.Vector2",
                name: "tauAlpha",
                type: "tuple"
              },
              {
                components: [
                  {
                    internalType: "int256",
                    name: "x",
                    type: "int256"
                  },
                  {
                    internalType: "int256",
                    name: "y",
                    type: "int256"
                  }
                ],
                internalType: "struct GyroECLPMath.Vector2",
                name: "tauBeta",
                type: "tuple"
              },
              {
                internalType: "int256",
                name: "u",
                type: "int256"
              },
              {
                internalType: "int256",
                name: "v",
                type: "int256"
              },
              {
                internalType: "int256",
                name: "w",
                type: "int256"
              },
              {
                internalType: "int256",
                name: "z",
                type: "int256"
              },
              {
                internalType: "int256",
                name: "dSq",
                type: "int256"
              }
            ],
            internalType: "struct GyroECLPMath.DerivedParams",
            name: "derivedEclpParams",
            type: "tuple"
          },
          {
            internalType: "address",
            name: "rateProvider0",
            type: "address"
          },
          {
            internalType: "address",
            name: "rateProvider1",
            type: "address"
          },
          {
            internalType: "address",
            name: "capManager",
            type: "address"
          },
          {
            components: [
              {
                internalType: "bool",
                name: "capEnabled",
                type: "bool"
              },
              {
                internalType: "uint120",
                name: "perAddressCap",
                type: "uint120"
              },
              {
                internalType: "uint128",
                name: "globalCap",
                type: "uint128"
              }
            ],
            internalType: "struct ICappedLiquidity.CapParams",
            name: "capParams",
            type: "tuple"
          },
          {
            internalType: "address",
            name: "pauseManager",
            type: "address"
          }
        ],
        internalType: "struct GyroECLPPool.GyroParams",
        name: "params",
        type: "tuple"
      },
      {
        internalType: "address",
        name: "configAddress",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "capManager",
        type: "address"
      }
    ],
    name: "CapManagerUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        components: [
          {
            internalType: "bool",
            name: "capEnabled",
            type: "bool"
          },
          {
            internalType: "uint120",
            name: "perAddressCap",
            type: "uint120"
          },
          {
            internalType: "uint128",
            name: "globalCap",
            type: "uint128"
          }
        ],
        indexed: false,
        internalType: "struct ICappedLiquidity.CapParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "CapParamsUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "derivedParamsValidated",
        type: "bool"
      }
    ],
    name: "ECLPDerivedParamsValidated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "paramsValidated",
        type: "bool"
      }
    ],
    name: "ECLPParamsValidated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "invariantAfterJoin",
        type: "uint256"
      }
    ],
    name: "InvariantAterInitializeJoin",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldInvariant",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newInvariant",
        type: "uint256"
      }
    ],
    name: "InvariantOldAndNew",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "enabled",
        type: "bool"
      }
    ],
    name: "OracleEnabledChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oracleUpdatedIndex",
        type: "uint256"
      }
    ],
    name: "OracleIndexUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "oldPauseManager",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newPauseManager",
        type: "address"
      }
    ],
    name: "PauseManagerChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [],
    name: "PausedLocally",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "paused",
        type: "bool"
      }
    ],
    name: "PausedStateChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "swapFeePercentage",
        type: "uint256"
      }
    ],
    name: "SwapFeePercentageChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      {
        components: [
          {
            internalType: "int256",
            name: "x",
            type: "int256"
          },
          {
            internalType: "int256",
            name: "y",
            type: "int256"
          }
        ],
        indexed: false,
        internalType: "struct GyroECLPMath.Vector2",
        name: "invariant",
        type: "tuple"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "SwapParams",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [],
    name: "UnpausedLocally",
    type: "event"
  },
  {
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "_dSq",
    outputs: [
      {
        internalType: "int256",
        name: "",
        type: "int256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "_paramsAlpha",
    outputs: [
      {
        internalType: "int256",
        name: "",
        type: "int256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "_paramsBeta",
    outputs: [
      {
        internalType: "int256",
        name: "",
        type: "int256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "_paramsC",
    outputs: [
      {
        internalType: "int256",
        name: "",
        type: "int256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "_paramsLambda",
    outputs: [
      {
        internalType: "int256",
        name: "",
        type: "int256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "_paramsS",
    outputs: [
      {
        internalType: "int256",
        name: "",
        type: "int256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "_tauAlphaX",
    outputs: [
      {
        internalType: "int256",
        name: "",
        type: "int256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "_tauAlphaY",
    outputs: [
      {
        internalType: "int256",
        name: "",
        type: "int256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "_tauBetaX",
    outputs: [
      {
        internalType: "int256",
        name: "",
        type: "int256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "_tauBetaY",
    outputs: [
      {
        internalType: "int256",
        name: "",
        type: "int256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "_u",
    outputs: [
      {
        internalType: "int256",
        name: "",
        type: "int256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "_v",
    outputs: [
      {
        internalType: "int256",
        name: "",
        type: "int256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "_w",
    outputs: [
      {
        internalType: "int256",
        name: "",
        type: "int256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "_z",
    outputs: [
      {
        internalType: "int256",
        name: "",
        type: "int256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "capManager",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "capParams",
    outputs: [
      {
        components: [
          {
            internalType: "bool",
            name: "capEnabled",
            type: "bool"
          },
          {
            internalType: "uint120",
            name: "perAddressCap",
            type: "uint120"
          },
          {
            internalType: "uint128",
            name: "globalCap",
            type: "uint128"
          }
        ],
        internalType: "struct ICappedLiquidity.CapParams",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_pauseManager",
        type: "address"
      }
    ],
    name: "changePauseManager",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "decreaseAllowance",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "startIndex",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "endIndex",
        type: "uint256"
      }
    ],
    name: "dirtyUninitializedOracleSamples",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "enableOracle",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "selector",
        type: "bytes4"
      }
    ],
    name: "getActionId",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAuthorizer",
    outputs: [
      {
        internalType: "contract IAuthorizer",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getECLPParams",
    outputs: [
      {
        components: [
          {
            internalType: "int256",
            name: "alpha",
            type: "int256"
          },
          {
            internalType: "int256",
            name: "beta",
            type: "int256"
          },
          {
            internalType: "int256",
            name: "c",
            type: "int256"
          },
          {
            internalType: "int256",
            name: "s",
            type: "int256"
          },
          {
            internalType: "int256",
            name: "lambda",
            type: "int256"
          }
        ],
        internalType: "struct GyroECLPMath.Params",
        name: "params",
        type: "tuple"
      },
      {
        components: [
          {
            components: [
              {
                internalType: "int256",
                name: "x",
                type: "int256"
              },
              {
                internalType: "int256",
                name: "y",
                type: "int256"
              }
            ],
            internalType: "struct GyroECLPMath.Vector2",
            name: "tauAlpha",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "int256",
                name: "x",
                type: "int256"
              },
              {
                internalType: "int256",
                name: "y",
                type: "int256"
              }
            ],
            internalType: "struct GyroECLPMath.Vector2",
            name: "tauBeta",
            type: "tuple"
          },
          {
            internalType: "int256",
            name: "u",
            type: "int256"
          },
          {
            internalType: "int256",
            name: "v",
            type: "int256"
          },
          {
            internalType: "int256",
            name: "w",
            type: "int256"
          },
          {
            internalType: "int256",
            name: "z",
            type: "int256"
          },
          {
            internalType: "int256",
            name: "dSq",
            type: "int256"
          }
        ],
        internalType: "struct GyroECLPMath.DerivedParams",
        name: "d",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getInvariant",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getLargestSafeQueryWindow",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "getLastInvariant",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum IPriceOracle.Variable",
        name: "variable",
        type: "uint8"
      }
    ],
    name: "getLatest",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getMiscData",
    outputs: [
      {
        internalType: "int256",
        name: "logInvariant",
        type: "int256"
      },
      {
        internalType: "int256",
        name: "logTotalSupply",
        type: "int256"
      },
      {
        internalType: "uint256",
        name: "oracleSampleCreationTimestamp",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "oracleIndex",
        type: "uint256"
      },
      {
        internalType: "bool",
        name: "oracleEnabled",
        type: "bool"
      },
      {
        internalType: "uint256",
        name: "swapFeePercentage",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getNormalizedWeights",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getOwner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "enum IPriceOracle.Variable",
            name: "variable",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "ago",
            type: "uint256"
          }
        ],
        internalType: "struct IPriceOracle.OracleAccumulatorQuery[]",
        name: "queries",
        type: "tuple[]"
      }
    ],
    name: "getPastAccumulators",
    outputs: [
      {
        internalType: "int256[]",
        name: "results",
        type: "int256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPausedState",
    outputs: [
      {
        internalType: "bool",
        name: "paused",
        type: "bool"
      },
      {
        internalType: "uint256",
        name: "pauseWindowEndTime",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "bufferPeriodEndTime",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPoolId",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPrice",
    outputs: [
      {
        internalType: "uint256",
        name: "spotPrice",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getRate",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "index",
        type: "uint256"
      }
    ],
    name: "getSample",
    outputs: [
      {
        internalType: "int256",
        name: "logPairPrice",
        type: "int256"
      },
      {
        internalType: "int256",
        name: "accLogPairPrice",
        type: "int256"
      },
      {
        internalType: "int256",
        name: "logBptPrice",
        type: "int256"
      },
      {
        internalType: "int256",
        name: "accLogBptPrice",
        type: "int256"
      },
      {
        internalType: "int256",
        name: "logInvariant",
        type: "int256"
      },
      {
        internalType: "int256",
        name: "accLogInvariant",
        type: "int256"
      },
      {
        internalType: "uint256",
        name: "timestamp",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getSwapFeePercentage",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "enum IPriceOracle.Variable",
            name: "variable",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "secs",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "ago",
            type: "uint256"
          }
        ],
        internalType: "struct IPriceOracle.OracleAverageQuery[]",
        name: "queries",
        type: "tuple[]"
      }
    ],
    name: "getTimeWeightedAverage",
    outputs: [
      {
        internalType: "uint256[]",
        name: "results",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getTokenRates",
    outputs: [
      {
        internalType: "uint256",
        name: "rate0",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "rate1",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getTotalSamples",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "getVault",
    outputs: [
      {
        internalType: "contract IVault",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "gyroConfig",
    outputs: [
      {
        internalType: "contract IGyroConfig",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "addedValue",
        type: "uint256"
      }
    ],
    name: "increaseAllowance",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "nonces",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "poolId",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "lastChangeBlock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "protocolSwapFeePercentage",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "userData",
        type: "bytes"
      }
    ],
    name: "onExitPool",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "poolId",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "lastChangeBlock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "protocolSwapFeePercentage",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "userData",
        type: "bytes"
      }
    ],
    name: "onJoinPool",
    outputs: [
      {
        internalType: "uint256[]",
        name: "amountsIn",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "dueProtocolFeeAmounts",
        type: "uint256[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "enum IVault.SwapKind",
            name: "kind",
            type: "uint8"
          },
          {
            internalType: "contract IERC20",
            name: "tokenIn",
            type: "address"
          },
          {
            internalType: "contract IERC20",
            name: "tokenOut",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        internalType: "struct IPoolSwapStructs.SwapRequest",
        name: "request",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "balanceTokenIn",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "balanceTokenOut",
        type: "uint256"
      }
    ],
    name: "onSwap",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "pause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "pauseManager",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "permit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "poolId",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "lastChangeBlock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "protocolSwapFeePercentage",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "userData",
        type: "bytes"
      }
    ],
    name: "queryExit",
    outputs: [
      {
        internalType: "uint256",
        name: "bptIn",
        type: "uint256"
      },
      {
        internalType: "uint256[]",
        name: "amountsOut",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "poolId",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "lastChangeBlock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "protocolSwapFeePercentage",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "userData",
        type: "bytes"
      }
    ],
    name: "queryJoin",
    outputs: [
      {
        internalType: "uint256",
        name: "bptOut",
        type: "uint256"
      },
      {
        internalType: "uint256[]",
        name: "amountsIn",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "rateProvider0",
    outputs: [
      {
        internalType: "contract IRateProvider",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "rateProvider1",
    outputs: [
      {
        internalType: "contract IRateProvider",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_capManager",
        type: "address"
      }
    ],
    name: "setCapManager",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "bool",
            name: "capEnabled",
            type: "bool"
          },
          {
            internalType: "uint120",
            name: "perAddressCap",
            type: "uint120"
          },
          {
            internalType: "uint128",
            name: "globalCap",
            type: "uint128"
          }
        ],
        internalType: "struct ICappedLiquidity.CapParams",
        name: "params",
        type: "tuple"
      }
    ],
    name: "setCapParams",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bool",
        name: "paused",
        type: "bool"
      }
    ],
    name: "setPaused",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "swapFeePercentage",
        type: "uint256"
      }
    ],
    name: "setSwapFeePercentage",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unpause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// src/abi/liquidityBootstrappingPool.ts
var liquidityBootstrappingPoolAbi = [
  {
    inputs: [
      {
        internalType: "contract IVault",
        name: "vault",
        type: "address"
      },
      { internalType: "string", name: "name", type: "string" },
      { internalType: "string", name: "symbol", type: "string" },
      {
        internalType: "contract IERC20[]",
        name: "tokens",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "normalizedWeights",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "swapFeePercentage",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "pauseWindowDuration",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "bufferPeriodDuration",
        type: "uint256"
      },
      { internalType: "address", name: "owner", type: "address" },
      {
        internalType: "bool",
        name: "swapEnabledOnStart",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "startTime",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "endTime",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "startWeights",
        type: "uint256[]"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "endWeights",
        type: "uint256[]"
      }
    ],
    name: "GradualWeightUpdateScheduled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "paused",
        type: "bool"
      }
    ],
    name: "PausedStateChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "swapEnabled",
        type: "bool"
      }
    ],
    name: "SwapEnabledSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "swapFeePercentage",
        type: "uint256"
      }
    ],
    name: "SwapFeePercentageChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" }
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "decreaseAllowance",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "selector", type: "bytes4" }],
    name: "getActionId",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAuthorizer",
    outputs: [
      {
        internalType: "contract IAuthorizer",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getGradualWeightUpdateParams",
    outputs: [
      {
        internalType: "uint256",
        name: "startTime",
        type: "uint256"
      },
      { internalType: "uint256", name: "endTime", type: "uint256" },
      {
        internalType: "uint256[]",
        name: "endWeights",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getInvariant",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getLastInvariant",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getNormalizedWeights",
    outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getOwner",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPausedState",
    outputs: [
      { internalType: "bool", name: "paused", type: "bool" },
      {
        internalType: "uint256",
        name: "pauseWindowEndTime",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "bufferPeriodEndTime",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPoolId",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getRate",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getScalingFactors",
    outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getSwapEnabled",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getSwapFeePercentage",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getVault",
    outputs: [
      { internalType: "contract IVault", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      {
        internalType: "uint256",
        name: "addedValue",
        type: "uint256"
      }
    ],
    name: "increaseAllowance",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "owner", type: "address" }],
    name: "nonces",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "lastChangeBlock",
        type: "uint256"
      },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "onExitPool",
    outputs: [
      { internalType: "uint256[]", name: "", type: "uint256[]" },
      { internalType: "uint256[]", name: "", type: "uint256[]" }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "lastChangeBlock",
        type: "uint256"
      },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "onJoinPool",
    outputs: [
      { internalType: "uint256[]", name: "", type: "uint256[]" },
      { internalType: "uint256[]", name: "", type: "uint256[]" }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "enum IVault.SwapKind",
            name: "kind",
            type: "uint8"
          },
          {
            internalType: "contract IERC20",
            name: "tokenIn",
            type: "address"
          },
          {
            internalType: "contract IERC20",
            name: "tokenOut",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        internalType: "struct IPoolSwapStructs.SwapRequest",
        name: "request",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "balanceTokenIn",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "balanceTokenOut",
        type: "uint256"
      }
    ],
    name: "onSwap",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      { internalType: "uint8", name: "v", type: "uint8" },
      { internalType: "bytes32", name: "r", type: "bytes32" },
      { internalType: "bytes32", name: "s", type: "bytes32" }
    ],
    name: "permit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "lastChangeBlock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "protocolSwapFeePercentage",
        type: "uint256"
      },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "queryExit",
    outputs: [
      { internalType: "uint256", name: "bptIn", type: "uint256" },
      {
        internalType: "uint256[]",
        name: "amountsOut",
        type: "uint256[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "lastChangeBlock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "protocolSwapFeePercentage",
        type: "uint256"
      },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "queryJoin",
    outputs: [
      { internalType: "uint256", name: "bptOut", type: "uint256" },
      {
        internalType: "uint256[]",
        name: "amountsIn",
        type: "uint256[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IERC20",
        name: "token",
        type: "address"
      },
      { internalType: "bytes", name: "poolConfig", type: "bytes" }
    ],
    name: "setAssetManagerPoolConfig",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bool", name: "paused", type: "bool" }],
    name: "setPaused",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bool", name: "swapEnabled", type: "bool" }],
    name: "setSwapEnabled",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "swapFeePercentage",
        type: "uint256"
      }
    ],
    name: "setSwapFeePercentage",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "startTime",
        type: "uint256"
      },
      { internalType: "uint256", name: "endTime", type: "uint256" },
      {
        internalType: "uint256[]",
        name: "endWeights",
        type: "uint256[]"
      }
    ],
    name: "updateWeightsGradually",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// src/abi/managedPool.ts
var managedPoolAbi = [
  {
    inputs: [
      {
        internalType: "contract IVault",
        name: "vault",
        type: "address"
      },
      {
        internalType: "contract IProtocolFeePercentagesProvider",
        name: "protocolFeeProvider",
        type: "address"
      },
      {
        internalType: "contract IExternalWeightedMath",
        name: "externalWeightedMath",
        type: "address"
      },
      {
        internalType: "contract IRecoveryModeHelper",
        name: "recoveryModeHelper",
        type: "address"
      },
      {
        internalType: "string",
        name: "factoryVersion",
        type: "string"
      },
      {
        internalType: "string",
        name: "poolVersion",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "initialPauseWindowDuration",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "bufferPeriodDuration",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [],
    name: "FactoryDisabled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "pool",
        type: "address"
      }
    ],
    name: "PoolCreated",
    type: "event"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "string",
            name: "name",
            type: "string"
          },
          {
            internalType: "string",
            name: "symbol",
            type: "string"
          },
          {
            internalType: "address[]",
            name: "assetManagers",
            type: "address[]"
          }
        ],
        internalType: "struct ManagedPool.ManagedPoolParams",
        name: "params",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "normalizedWeights",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "swapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "swapEnabledOnStart",
            type: "bool"
          },
          {
            internalType: "bool",
            name: "mustAllowlistLPs",
            type: "bool"
          },
          {
            internalType: "uint256",
            name: "managementAumFeePercentage",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "aumFeeId",
            type: "uint256"
          }
        ],
        internalType: "struct ManagedPoolSettings.ManagedPoolSettingsParams",
        name: "settingsParams",
        type: "tuple"
      },
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bytes32", name: "salt", type: "bytes32" }
    ],
    name: "create",
    outputs: [{ internalType: "address", name: "pool", type: "address" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "disable",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "selector", type: "bytes4" }],
    name: "getActionId",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAuthorizer",
    outputs: [
      {
        internalType: "contract IAuthorizer",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCreationCode",
    outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCreationCodeContracts",
    outputs: [
      {
        internalType: "address",
        name: "contractA",
        type: "address"
      },
      {
        internalType: "address",
        name: "contractB",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPauseConfiguration",
    outputs: [
      {
        internalType: "uint256",
        name: "pauseWindowDuration",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "bufferPeriodDuration",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPoolVersion",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getProtocolFeePercentagesProvider",
    outputs: [
      {
        internalType: "contract IProtocolFeePercentagesProvider",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getRecoveryModeHelper",
    outputs: [
      {
        internalType: "contract IRecoveryModeHelper",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getVault",
    outputs: [
      { internalType: "contract IVault", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getWeightedMath",
    outputs: [
      {
        internalType: "contract IExternalWeightedMath",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "isDisabled",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "pool", type: "address" }],
    name: "isPoolFromFactory",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "version",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  }
];

// src/abi/metaStablePool.ts
var metaStablePoolAbi = [
  {
    inputs: [
      {
        components: [
          {
            internalType: "contract IVault",
            name: "vault",
            type: "address"
          },
          {
            internalType: "string",
            name: "name",
            type: "string"
          },
          {
            internalType: "string",
            name: "symbol",
            type: "string"
          },
          {
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          },
          {
            internalType: "contract IRateProvider[]",
            name: "rateProviders",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "priceRateCacheDuration",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "amplificationParameter",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "swapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pauseWindowDuration",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "bufferPeriodDuration",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "oracleEnabled",
            type: "bool"
          },
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        internalType: "struct MetaStablePool.NewPoolParams",
        name: "params",
        type: "tuple"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "startValue",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "endValue",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "startTime",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "endTime",
        type: "uint256"
      }
    ],
    name: "AmpUpdateStarted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "currentValue",
        type: "uint256"
      }
    ],
    name: "AmpUpdateStopped",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "enabled",
        type: "bool"
      }
    ],
    name: "OracleEnabledChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "paused",
        type: "bool"
      }
    ],
    name: "PausedStateChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "contract IERC20",
        name: "token",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "rate",
        type: "uint256"
      }
    ],
    name: "PriceRateCacheUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "contract IERC20",
        name: "token",
        type: "address"
      },
      {
        indexed: true,
        internalType: "contract IRateProvider",
        name: "provider",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "cacheDuration",
        type: "uint256"
      }
    ],
    name: "PriceRateProviderSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "swapFeePercentage",
        type: "uint256"
      }
    ],
    name: "SwapFeePercentageChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" }
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "decreaseAllowance",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "enableOracle",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "selector", type: "bytes4" }],
    name: "getActionId",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAmplificationParameter",
    outputs: [
      { internalType: "uint256", name: "value", type: "uint256" },
      { internalType: "bool", name: "isUpdating", type: "bool" },
      {
        internalType: "uint256",
        name: "precision",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAuthorizer",
    outputs: [
      {
        internalType: "contract IAuthorizer",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getLargestSafeQueryWindow",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "getLastInvariant",
    outputs: [
      {
        internalType: "uint256",
        name: "lastInvariant",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "lastInvariantAmp",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "enum IPriceOracle.Variable",
        name: "variable",
        type: "uint8"
      }
    ],
    name: "getLatest",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getOracleMiscData",
    outputs: [
      {
        internalType: "int256",
        name: "logInvariant",
        type: "int256"
      },
      {
        internalType: "int256",
        name: "logTotalSupply",
        type: "int256"
      },
      {
        internalType: "uint256",
        name: "oracleSampleCreationTimestamp",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "oracleIndex",
        type: "uint256"
      },
      { internalType: "bool", name: "oracleEnabled", type: "bool" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getOwner",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "enum IPriceOracle.Variable",
            name: "variable",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "ago",
            type: "uint256"
          }
        ],
        internalType: "struct IPriceOracle.OracleAccumulatorQuery[]",
        name: "queries",
        type: "tuple[]"
      }
    ],
    name: "getPastAccumulators",
    outputs: [
      {
        internalType: "int256[]",
        name: "results",
        type: "int256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPausedState",
    outputs: [
      { internalType: "bool", name: "paused", type: "bool" },
      {
        internalType: "uint256",
        name: "pauseWindowEndTime",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "bufferPeriodEndTime",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPoolId",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IERC20",
        name: "token",
        type: "address"
      }
    ],
    name: "getPriceRateCache",
    outputs: [
      { internalType: "uint256", name: "rate", type: "uint256" },
      {
        internalType: "uint256",
        name: "duration",
        type: "uint256"
      },
      { internalType: "uint256", name: "expires", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getRate",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getRateProviders",
    outputs: [
      {
        internalType: "contract IRateProvider[]",
        name: "providers",
        type: "address[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "index", type: "uint256" }],
    name: "getSample",
    outputs: [
      {
        internalType: "int256",
        name: "logPairPrice",
        type: "int256"
      },
      {
        internalType: "int256",
        name: "accLogPairPrice",
        type: "int256"
      },
      {
        internalType: "int256",
        name: "logBptPrice",
        type: "int256"
      },
      {
        internalType: "int256",
        name: "accLogBptPrice",
        type: "int256"
      },
      {
        internalType: "int256",
        name: "logInvariant",
        type: "int256"
      },
      {
        internalType: "int256",
        name: "accLogInvariant",
        type: "int256"
      },
      {
        internalType: "uint256",
        name: "timestamp",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getScalingFactors",
    outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getSwapFeePercentage",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "enum IPriceOracle.Variable",
            name: "variable",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "secs",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "ago",
            type: "uint256"
          }
        ],
        internalType: "struct IPriceOracle.OracleAverageQuery[]",
        name: "queries",
        type: "tuple[]"
      }
    ],
    name: "getTimeWeightedAverage",
    outputs: [
      {
        internalType: "uint256[]",
        name: "results",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getTotalSamples",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "getVault",
    outputs: [
      { internalType: "contract IVault", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      {
        internalType: "uint256",
        name: "addedValue",
        type: "uint256"
      }
    ],
    name: "increaseAllowance",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "owner", type: "address" }],
    name: "nonces",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "lastChangeBlock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "protocolSwapFeePercentage",
        type: "uint256"
      },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "onExitPool",
    outputs: [
      {
        internalType: "uint256[]",
        name: "amountsOut",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "dueProtocolFeeAmounts",
        type: "uint256[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "lastChangeBlock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "protocolSwapFeePercentage",
        type: "uint256"
      },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "onJoinPool",
    outputs: [
      {
        internalType: "uint256[]",
        name: "amountsIn",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "dueProtocolFeeAmounts",
        type: "uint256[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "enum IVault.SwapKind",
            name: "kind",
            type: "uint8"
          },
          {
            internalType: "contract IERC20",
            name: "tokenIn",
            type: "address"
          },
          {
            internalType: "contract IERC20",
            name: "tokenOut",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        internalType: "struct IPoolSwapStructs.SwapRequest",
        name: "request",
        type: "tuple"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      { internalType: "uint256", name: "indexIn", type: "uint256" },
      { internalType: "uint256", name: "indexOut", type: "uint256" }
    ],
    name: "onSwap",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "enum IVault.SwapKind",
            name: "kind",
            type: "uint8"
          },
          {
            internalType: "contract IERC20",
            name: "tokenIn",
            type: "address"
          },
          {
            internalType: "contract IERC20",
            name: "tokenOut",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        internalType: "struct IPoolSwapStructs.SwapRequest",
        name: "request",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "balanceTokenIn",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "balanceTokenOut",
        type: "uint256"
      }
    ],
    name: "onSwap",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      { internalType: "uint8", name: "v", type: "uint8" },
      { internalType: "bytes32", name: "r", type: "bytes32" },
      { internalType: "bytes32", name: "s", type: "bytes32" }
    ],
    name: "permit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "lastChangeBlock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "protocolSwapFeePercentage",
        type: "uint256"
      },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "queryExit",
    outputs: [
      { internalType: "uint256", name: "bptIn", type: "uint256" },
      {
        internalType: "uint256[]",
        name: "amountsOut",
        type: "uint256[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "lastChangeBlock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "protocolSwapFeePercentage",
        type: "uint256"
      },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "queryJoin",
    outputs: [
      { internalType: "uint256", name: "bptOut", type: "uint256" },
      {
        internalType: "uint256[]",
        name: "amountsIn",
        type: "uint256[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IERC20",
        name: "token",
        type: "address"
      },
      { internalType: "bytes", name: "poolConfig", type: "bytes" }
    ],
    name: "setAssetManagerPoolConfig",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bool", name: "paused", type: "bool" }],
    name: "setPaused",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IERC20",
        name: "token",
        type: "address"
      },
      { internalType: "uint256", name: "duration", type: "uint256" }
    ],
    name: "setPriceRateCacheDuration",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "swapFeePercentage",
        type: "uint256"
      }
    ],
    name: "setSwapFeePercentage",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "rawEndValue",
        type: "uint256"
      },
      { internalType: "uint256", name: "endTime", type: "uint256" }
    ],
    name: "startAmplificationParameterUpdate",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "stopAmplificationParameterUpdate",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IERC20",
        name: "token",
        type: "address"
      }
    ],
    name: "updatePriceRateCache",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// src/abi/phantomStablePool.ts
var phantomStablePoolAbi = [
  {
    inputs: [
      {
        components: [
          {
            internalType: "contract IVault",
            name: "vault",
            type: "address"
          },
          {
            internalType: "string",
            name: "name",
            type: "string"
          },
          {
            internalType: "string",
            name: "symbol",
            type: "string"
          },
          {
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          },
          {
            internalType: "contract IRateProvider[]",
            name: "rateProviders",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "tokenRateCacheDurations",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "amplificationParameter",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "swapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pauseWindowDuration",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "bufferPeriodDuration",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        internalType: "struct StablePhantomPool.NewPoolParams",
        name: "params",
        type: "tuple"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "startValue",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "endValue",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "startTime",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "endTime",
        type: "uint256"
      }
    ],
    name: "AmpUpdateStarted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "currentValue",
        type: "uint256"
      }
    ],
    name: "AmpUpdateStopped",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "protocolSwapFeePercentage",
        type: "uint256"
      }
    ],
    name: "CachedProtocolSwapFeePercentageUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "bptAmount",
        type: "uint256"
      }
    ],
    name: "DueProtocolFeeIncreased",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "paused",
        type: "bool"
      }
    ],
    name: "PausedStateChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "swapFeePercentage",
        type: "uint256"
      }
    ],
    name: "SwapFeePercentageChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "contract IERC20",
        name: "token",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "rate",
        type: "uint256"
      }
    ],
    name: "TokenRateCacheUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "contract IERC20",
        name: "token",
        type: "address"
      },
      {
        indexed: true,
        internalType: "contract IRateProvider",
        name: "provider",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "cacheDuration",
        type: "uint256"
      }
    ],
    name: "TokenRateProviderSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" }
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "decreaseAllowance",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "selector", type: "bytes4" }],
    name: "getActionId",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAmplificationParameter",
    outputs: [
      { internalType: "uint256", name: "value", type: "uint256" },
      { internalType: "bool", name: "isUpdating", type: "bool" },
      {
        internalType: "uint256",
        name: "precision",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAuthorizer",
    outputs: [
      {
        internalType: "contract IAuthorizer",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getBptIndex",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCachedProtocolSwapFeePercentage",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getDueProtocolFeeBptAmount",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getLastInvariant",
    outputs: [
      {
        internalType: "uint256",
        name: "lastInvariant",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "lastInvariantAmp",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getMinimumBpt",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "getOwner",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPausedState",
    outputs: [
      { internalType: "bool", name: "paused", type: "bool" },
      {
        internalType: "uint256",
        name: "pauseWindowEndTime",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "bufferPeriodEndTime",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPoolId",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getRate",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getRateProviders",
    outputs: [
      {
        internalType: "contract IRateProvider[]",
        name: "providers",
        type: "address[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IERC20",
        name: "token",
        type: "address"
      }
    ],
    name: "getScalingFactor",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getScalingFactors",
    outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getSwapFeePercentage",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IERC20",
        name: "token",
        type: "address"
      }
    ],
    name: "getTokenRate",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IERC20",
        name: "token",
        type: "address"
      }
    ],
    name: "getTokenRateCache",
    outputs: [
      { internalType: "uint256", name: "rate", type: "uint256" },
      {
        internalType: "uint256",
        name: "duration",
        type: "uint256"
      },
      { internalType: "uint256", name: "expires", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getVault",
    outputs: [
      { internalType: "contract IVault", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getVirtualSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      {
        internalType: "uint256",
        name: "addedValue",
        type: "uint256"
      }
    ],
    name: "increaseAllowance",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "owner", type: "address" }],
    name: "nonces",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "lastChangeBlock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "protocolSwapFeePercentage",
        type: "uint256"
      },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "onExitPool",
    outputs: [
      { internalType: "uint256[]", name: "", type: "uint256[]" },
      { internalType: "uint256[]", name: "", type: "uint256[]" }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "lastChangeBlock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "protocolSwapFeePercentage",
        type: "uint256"
      },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "onJoinPool",
    outputs: [
      { internalType: "uint256[]", name: "", type: "uint256[]" },
      { internalType: "uint256[]", name: "", type: "uint256[]" }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "enum IVault.SwapKind",
            name: "kind",
            type: "uint8"
          },
          {
            internalType: "contract IERC20",
            name: "tokenIn",
            type: "address"
          },
          {
            internalType: "contract IERC20",
            name: "tokenOut",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        internalType: "struct IPoolSwapStructs.SwapRequest",
        name: "swapRequest",
        type: "tuple"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      { internalType: "uint256", name: "indexIn", type: "uint256" },
      { internalType: "uint256", name: "indexOut", type: "uint256" }
    ],
    name: "onSwap",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "enum IVault.SwapKind",
            name: "kind",
            type: "uint8"
          },
          {
            internalType: "contract IERC20",
            name: "tokenIn",
            type: "address"
          },
          {
            internalType: "contract IERC20",
            name: "tokenOut",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        internalType: "struct IPoolSwapStructs.SwapRequest",
        name: "",
        type: "tuple"
      },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" }
    ],
    name: "onSwap",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      { internalType: "uint8", name: "v", type: "uint8" },
      { internalType: "bytes32", name: "r", type: "bytes32" },
      { internalType: "bytes32", name: "s", type: "bytes32" }
    ],
    name: "permit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "lastChangeBlock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "protocolSwapFeePercentage",
        type: "uint256"
      },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "queryExit",
    outputs: [
      { internalType: "uint256", name: "bptIn", type: "uint256" },
      {
        internalType: "uint256[]",
        name: "amountsOut",
        type: "uint256[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "lastChangeBlock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "protocolSwapFeePercentage",
        type: "uint256"
      },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "queryJoin",
    outputs: [
      { internalType: "uint256", name: "bptOut", type: "uint256" },
      {
        internalType: "uint256[]",
        name: "amountsIn",
        type: "uint256[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IERC20",
        name: "token",
        type: "address"
      },
      { internalType: "bytes", name: "poolConfig", type: "bytes" }
    ],
    name: "setAssetManagerPoolConfig",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bool", name: "paused", type: "bool" }],
    name: "setPaused",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "swapFeePercentage",
        type: "uint256"
      }
    ],
    name: "setSwapFeePercentage",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IERC20",
        name: "token",
        type: "address"
      },
      { internalType: "uint256", name: "duration", type: "uint256" }
    ],
    name: "setTokenRateCacheDuration",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "rawEndValue",
        type: "uint256"
      },
      { internalType: "uint256", name: "endTime", type: "uint256" }
    ],
    name: "startAmplificationParameterUpdate",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "stopAmplificationParameterUpdate",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "updateCachedProtocolSwapFeePercentage",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IERC20",
        name: "token",
        type: "address"
      }
    ],
    name: "updateTokenRateCache",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// src/abi/weightedFactoryV4.ts
var weightedFactoryV4Abi = [
  {
    inputs: [
      {
        internalType: "contract IVault",
        name: "vault",
        type: "address"
      },
      {
        internalType: "contract IProtocolFeePercentagesProvider",
        name: "protocolFeeProvider",
        type: "address"
      },
      {
        internalType: "string",
        name: "factoryVersion",
        type: "string"
      },
      {
        internalType: "string",
        name: "poolVersion",
        type: "string"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [],
    name: "FactoryDisabled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "pool",
        type: "address"
      }
    ],
    name: "PoolCreated",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        internalType: "string",
        name: "symbol",
        type: "string"
      },
      {
        internalType: "contract IERC20[]",
        name: "tokens",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "normalizedWeights",
        type: "uint256[]"
      },
      {
        internalType: "contract IRateProvider[]",
        name: "rateProviders",
        type: "address[]"
      },
      {
        internalType: "uint256",
        name: "swapFeePercentage",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "salt",
        type: "bytes32"
      }
    ],
    name: "create",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "disable",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "selector",
        type: "bytes4"
      }
    ],
    name: "getActionId",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAuthorizer",
    outputs: [
      {
        internalType: "contract IAuthorizer",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCreationCode",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCreationCodeContracts",
    outputs: [
      {
        internalType: "address",
        name: "contractA",
        type: "address"
      },
      {
        internalType: "address",
        name: "contractB",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPauseConfiguration",
    outputs: [
      {
        internalType: "uint256",
        name: "pauseWindowDuration",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "bufferPeriodDuration",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPoolVersion",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getProtocolFeePercentagesProvider",
    outputs: [
      {
        internalType: "contract IProtocolFeePercentagesProvider",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getVault",
    outputs: [
      {
        internalType: "contract IVault",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "isDisabled",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "pool",
        type: "address"
      }
    ],
    name: "isPoolFromFactory",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "version",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// src/abi/weightedPool.ts
var weightedPoolAbi = [
  {
    inputs: [
      {
        components: [
          {
            internalType: "string",
            name: "name",
            type: "string"
          },
          {
            internalType: "string",
            name: "symbol",
            type: "string"
          },
          {
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "normalizedWeights",
            type: "uint256[]"
          },
          {
            internalType: "contract IRateProvider[]",
            name: "rateProviders",
            type: "address[]"
          },
          {
            internalType: "address[]",
            name: "assetManagers",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "swapFeePercentage",
            type: "uint256"
          }
        ],
        internalType: "struct WeightedPool.NewPoolParams",
        name: "params",
        type: "tuple"
      },
      {
        internalType: "contract IVault",
        name: "vault",
        type: "address"
      },
      {
        internalType: "contract IProtocolFeePercentagesProvider",
        name: "protocolFeeProvider",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pauseWindowDuration",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "bufferPeriodDuration",
        type: "uint256"
      },
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "string", name: "version", type: "string" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "paused",
        type: "bool"
      }
    ],
    name: "PausedStateChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "feeType",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "protocolFeePercentage",
        type: "uint256"
      }
    ],
    name: "ProtocolFeePercentageCacheUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "enabled",
        type: "bool"
      }
    ],
    name: "RecoveryModeStateChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "swapFeePercentage",
        type: "uint256"
      }
    ],
    name: "SwapFeePercentageChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [],
    name: "DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" }
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "decreaseAllowance",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "disableRecoveryMode",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "enableRecoveryMode",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "getATHRateProduct",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "selector", type: "bytes4" }],
    name: "getActionId",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getActualSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAuthorizer",
    outputs: [
      {
        internalType: "contract IAuthorizer",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getDomainSeparator",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getInvariant",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getLastPostJoinExitInvariant",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "getNextNonce",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getNormalizedWeights",
    outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getOwner",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPausedState",
    outputs: [
      { internalType: "bool", name: "paused", type: "bool" },
      {
        internalType: "uint256",
        name: "pauseWindowEndTime",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "bufferPeriodEndTime",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPoolId",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "feeType", type: "uint256" }],
    name: "getProtocolFeePercentageCache",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getProtocolFeesCollector",
    outputs: [
      {
        internalType: "contract IProtocolFeesCollector",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getProtocolSwapFeeDelegation",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getRateProviders",
    outputs: [
      {
        internalType: "contract IRateProvider[]",
        name: "",
        type: "address[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getScalingFactors",
    outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getSwapFeePercentage",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getVault",
    outputs: [
      { internalType: "contract IVault", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "inRecoveryMode",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      {
        internalType: "uint256",
        name: "addedValue",
        type: "uint256"
      }
    ],
    name: "increaseAllowance",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "owner", type: "address" }],
    name: "nonces",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "lastChangeBlock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "protocolSwapFeePercentage",
        type: "uint256"
      },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "onExitPool",
    outputs: [
      { internalType: "uint256[]", name: "", type: "uint256[]" },
      { internalType: "uint256[]", name: "", type: "uint256[]" }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "lastChangeBlock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "protocolSwapFeePercentage",
        type: "uint256"
      },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "onJoinPool",
    outputs: [
      { internalType: "uint256[]", name: "", type: "uint256[]" },
      { internalType: "uint256[]", name: "", type: "uint256[]" }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "enum IVault.SwapKind",
            name: "kind",
            type: "uint8"
          },
          {
            internalType: "contract IERC20",
            name: "tokenIn",
            type: "address"
          },
          {
            internalType: "contract IERC20",
            name: "tokenOut",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        internalType: "struct IPoolSwapStructs.SwapRequest",
        name: "request",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "balanceTokenIn",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "balanceTokenOut",
        type: "uint256"
      }
    ],
    name: "onSwap",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "pause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      { internalType: "uint8", name: "v", type: "uint8" },
      { internalType: "bytes32", name: "r", type: "bytes32" },
      { internalType: "bytes32", name: "s", type: "bytes32" }
    ],
    name: "permit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "lastChangeBlock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "protocolSwapFeePercentage",
        type: "uint256"
      },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "queryExit",
    outputs: [
      { internalType: "uint256", name: "bptIn", type: "uint256" },
      {
        internalType: "uint256[]",
        name: "amountsOut",
        type: "uint256[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "lastChangeBlock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "protocolSwapFeePercentage",
        type: "uint256"
      },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "queryJoin",
    outputs: [
      { internalType: "uint256", name: "bptOut", type: "uint256" },
      {
        internalType: "uint256[]",
        name: "amountsIn",
        type: "uint256[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IERC20",
        name: "token",
        type: "address"
      },
      { internalType: "bytes", name: "poolConfig", type: "bytes" }
    ],
    name: "setAssetManagerPoolConfig",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "swapFeePercentage",
        type: "uint256"
      }
    ],
    name: "setSwapFeePercentage",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unpause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "updateProtocolFeePercentageCache",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "version",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  }
];

// src/abi/linearPool.ts
var linearPoolAbi = [
  {
    inputs: [
      {
        components: [
          {
            internalType: "contract IVault",
            name: "vault",
            type: "address"
          },
          {
            internalType: "string",
            name: "name",
            type: "string"
          },
          {
            internalType: "string",
            name: "symbol",
            type: "string"
          },
          {
            internalType: "contract IERC20",
            name: "mainToken",
            type: "address"
          },
          {
            internalType: "contract IERC20",
            name: "wrappedToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "assetManager",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "upperTarget",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "swapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pauseWindowDuration",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "bufferPeriodDuration",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "string",
            name: "version",
            type: "string"
          }
        ],
        internalType: "struct AaveLinearPool.ConstructorArgs",
        name: "args",
        type: "tuple"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "paused",
        type: "bool"
      }
    ],
    name: "PausedStateChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "enabled",
        type: "bool"
      }
    ],
    name: "RecoveryModeStateChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "swapFeePercentage",
        type: "uint256"
      }
    ],
    name: "SwapFeePercentageChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "contract IERC20",
        name: "token",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "lowerTarget",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "upperTarget",
        type: "uint256"
      }
    ],
    name: "TargetsSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" }
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "decreaseAllowance",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "disableRecoveryMode",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "enableRecoveryMode",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "selector", type: "bytes4" }],
    name: "getActionId",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAuthorizer",
    outputs: [
      {
        internalType: "contract IAuthorizer",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getBptIndex",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "getDomainSeparator",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getMainIndex",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getMainToken",
    outputs: [
      { internalType: "contract IERC20", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "getNextNonce",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getOwner",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPausedState",
    outputs: [
      { internalType: "bool", name: "paused", type: "bool" },
      {
        internalType: "uint256",
        name: "pauseWindowEndTime",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "bufferPeriodEndTime",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPoolId",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getProtocolFeesCollector",
    outputs: [
      {
        internalType: "contract IProtocolFeesCollector",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getRate",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getScalingFactors",
    outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getSwapFeePercentage",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getTargets",
    outputs: [
      {
        internalType: "uint256",
        name: "lowerTarget",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "upperTarget",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getVault",
    outputs: [
      { internalType: "contract IVault", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getVirtualSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getWrappedIndex",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getWrappedToken",
    outputs: [
      { internalType: "contract IERC20", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getWrappedTokenRate",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "inRecoveryMode",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      {
        internalType: "uint256",
        name: "addedValue",
        type: "uint256"
      }
    ],
    name: "increaseAllowance",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "owner", type: "address" }],
    name: "nonces",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      { internalType: "address", name: "", type: "address" },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "onExitPool",
    outputs: [
      {
        internalType: "uint256[]",
        name: "amountsOut",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "dueProtocolFees",
        type: "uint256[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      { internalType: "address", name: "recipient", type: "address" },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "onJoinPool",
    outputs: [
      {
        internalType: "uint256[]",
        name: "amountsIn",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "dueProtocolFees",
        type: "uint256[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "enum IVault.SwapKind",
            name: "kind",
            type: "uint8"
          },
          {
            internalType: "contract IERC20",
            name: "tokenIn",
            type: "address"
          },
          {
            internalType: "contract IERC20",
            name: "tokenOut",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        internalType: "struct IPoolSwapStructs.SwapRequest",
        name: "request",
        type: "tuple"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      { internalType: "uint256", name: "indexIn", type: "uint256" },
      { internalType: "uint256", name: "indexOut", type: "uint256" }
    ],
    name: "onSwap",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "enum IVault.SwapKind",
            name: "kind",
            type: "uint8"
          },
          {
            internalType: "contract IERC20",
            name: "tokenIn",
            type: "address"
          },
          {
            internalType: "contract IERC20",
            name: "tokenOut",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        internalType: "struct IPoolSwapStructs.SwapRequest",
        name: "request",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "balanceTokenIn",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "balanceTokenOut",
        type: "uint256"
      }
    ],
    name: "onSwap",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "pause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" },
      { internalType: "uint8", name: "v", type: "uint8" },
      { internalType: "bytes32", name: "r", type: "bytes32" },
      { internalType: "bytes32", name: "s", type: "bytes32" }
    ],
    name: "permit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      { internalType: "address", name: "", type: "address" },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "queryExit",
    outputs: [
      { internalType: "uint256", name: "bptIn", type: "uint256" },
      {
        internalType: "uint256[]",
        name: "amountsOut",
        type: "uint256[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      { internalType: "address", name: "", type: "address" },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "queryJoin",
    outputs: [
      { internalType: "uint256", name: "bptOut", type: "uint256" },
      {
        internalType: "uint256[]",
        name: "amountsIn",
        type: "uint256[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "swapFeePercentage",
        type: "uint256"
      }
    ],
    name: "setSwapFeePercentage",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "newLowerTarget",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "newUpperTarget",
        type: "uint256"
      }
    ],
    name: "setTargets",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "recipient", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "sender", type: "address" },
      { internalType: "address", name: "recipient", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unpause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "version",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  }
];

// src/abi/stablePool.ts
var stablePoolAbi = [
  {
    inputs: [
      {
        internalType: "contract IVault",
        name: "vault",
        type: "address"
      },
      { internalType: "string", name: "name", type: "string" },
      { internalType: "string", name: "symbol", type: "string" },
      {
        internalType: "contract IERC20[]",
        name: "tokens",
        type: "address[]"
      },
      {
        internalType: "uint256",
        name: "amplificationParameter",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "swapFeePercentage",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "pauseWindowDuration",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "bufferPeriodDuration",
        type: "uint256"
      },
      { internalType: "address", name: "owner", type: "address" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "startValue",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "endValue",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "startTime",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "endTime",
        type: "uint256"
      }
    ],
    name: "AmpUpdateStarted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "currentValue",
        type: "uint256"
      }
    ],
    name: "AmpUpdateStopped",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "paused",
        type: "bool"
      }
    ],
    name: "PausedStateChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "swapFeePercentage",
        type: "uint256"
      }
    ],
    name: "SwapFeePercentageChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" }
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "decreaseAllowance",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "selector", type: "bytes4" }],
    name: "getActionId",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAmplificationParameter",
    outputs: [
      { internalType: "uint256", name: "value", type: "uint256" },
      { internalType: "bool", name: "isUpdating", type: "bool" },
      {
        internalType: "uint256",
        name: "precision",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAuthorizer",
    outputs: [
      {
        internalType: "contract IAuthorizer",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getOwner",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPausedState",
    outputs: [
      { internalType: "bool", name: "paused", type: "bool" },
      {
        internalType: "uint256",
        name: "pauseWindowEndTime",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "bufferPeriodEndTime",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPoolId",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getRate",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getSwapFeePercentage",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getVault",
    outputs: [
      { internalType: "contract IVault", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      {
        internalType: "uint256",
        name: "addedValue",
        type: "uint256"
      }
    ],
    name: "increaseAllowance",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "owner", type: "address" }],
    name: "nonces",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "lastChangeBlock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "protocolSwapFeePercentage",
        type: "uint256"
      },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "onExitPool",
    outputs: [
      { internalType: "uint256[]", name: "", type: "uint256[]" },
      { internalType: "uint256[]", name: "", type: "uint256[]" }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "lastChangeBlock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "protocolSwapFeePercentage",
        type: "uint256"
      },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "onJoinPool",
    outputs: [
      { internalType: "uint256[]", name: "", type: "uint256[]" },
      { internalType: "uint256[]", name: "", type: "uint256[]" }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "enum IVault.SwapKind",
            name: "kind",
            type: "uint8"
          },
          {
            internalType: "contract IERC20",
            name: "tokenIn",
            type: "address"
          },
          {
            internalType: "contract IERC20",
            name: "tokenOut",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        internalType: "struct IPoolSwapStructs.SwapRequest",
        name: "swapRequest",
        type: "tuple"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      { internalType: "uint256", name: "indexIn", type: "uint256" },
      { internalType: "uint256", name: "indexOut", type: "uint256" }
    ],
    name: "onSwap",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "enum IVault.SwapKind",
            name: "kind",
            type: "uint8"
          },
          {
            internalType: "contract IERC20",
            name: "tokenIn",
            type: "address"
          },
          {
            internalType: "contract IERC20",
            name: "tokenOut",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        internalType: "struct IPoolSwapStructs.SwapRequest",
        name: "request",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "balanceTokenIn",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "balanceTokenOut",
        type: "uint256"
      }
    ],
    name: "onSwap",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      { internalType: "uint8", name: "v", type: "uint8" },
      { internalType: "bytes32", name: "r", type: "bytes32" },
      { internalType: "bytes32", name: "s", type: "bytes32" }
    ],
    name: "permit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "lastChangeBlock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "protocolSwapFeePercentage",
        type: "uint256"
      },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "queryExit",
    outputs: [
      { internalType: "uint256", name: "bptIn", type: "uint256" },
      {
        internalType: "uint256[]",
        name: "amountsOut",
        type: "uint256[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "poolId", type: "bytes32" },
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "balances",
        type: "uint256[]"
      },
      {
        internalType: "uint256",
        name: "lastChangeBlock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "protocolSwapFeePercentage",
        type: "uint256"
      },
      { internalType: "bytes", name: "userData", type: "bytes" }
    ],
    name: "queryJoin",
    outputs: [
      { internalType: "uint256", name: "bptOut", type: "uint256" },
      {
        internalType: "uint256[]",
        name: "amountsIn",
        type: "uint256[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IERC20",
        name: "token",
        type: "address"
      },
      { internalType: "bytes", name: "poolConfig", type: "bytes" }
    ],
    name: "setAssetManagerPoolConfig",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bool", name: "paused", type: "bool" }],
    name: "setPaused",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "swapFeePercentage",
        type: "uint256"
      }
    ],
    name: "setSwapFeePercentage",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "rawEndValue",
        type: "uint256"
      },
      { internalType: "uint256", name: "endTime", type: "uint256" }
    ],
    name: "startAmplificationParameterUpdate",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "stopAmplificationParameterUpdate",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// src/data/onChainPoolDataViaReadContract.ts
var requiredAbis = [
  ...composabableStablePoolV5Abi,
  ...fxPoolAbi,
  ...gyroEV2Abi,
  ...linearPoolAbi,
  ...liquidityBootstrappingPoolAbi,
  ...managedPoolAbi,
  ...metaStablePoolAbi,
  ...phantomStablePoolAbi,
  ...stablePoolAbi,
  ...weightedPoolAbi,
  ...vaultAbi
];
var uniqueAbiElements = new Map(
  requiredAbis.map((abi2) => [JSON.stringify(abi2), abi2])
);
var abi = Array.from(uniqueAbiElements.values()).filter(
  (a) => a.type === "function"
);
var getTotalSupplyFn = (poolType) => {
  if (poolType.includes("Linear") || ["StablePhantom"].includes(poolType)) {
    return "getVirtualSupply";
  }
  if (poolType === "ComposableStable") {
    return "getActualSupply";
  }
  return "totalSupply";
};
var getSwapFeeFn = (poolType) => {
  if (poolType === "Element") {
    return "percentFee";
  }
  if (poolType === "FX") {
    return "protocolPercentFee";
  }
  return "getSwapFeePercentage";
};
var defaultCalls = {
  count: 4,
  build: (id, poolType, vault) => [
    {
      address: vault,
      abi,
      functionName: "getPoolTokens",
      args: [id]
    },
    {
      address: getPoolAddress(id),
      abi,
      functionName: getTotalSupplyFn(poolType)
    },
    {
      address: getPoolAddress(id),
      abi,
      functionName: getSwapFeeFn(poolType)
    },
    {
      address: getPoolAddress(id),
      abi,
      functionName: "getPausedState"
    }
  ],
  parse: (results, shift) => {
    return {
      balances: results[shift].result[1],
      totalSupply: results[shift + 1].result,
      swapFee: results[shift + 2].result,
      isPaused: results[shift + 3].result
    };
  }
};
var defaultCallsAux = {
  count: 2 + defaultCalls.count,
  build: (id, poolType, vault) => [
    ...defaultCalls.build(id, poolType, vault),
    {
      address: getPoolAddress(id),
      abi,
      functionName: "inRecoveryMode"
    },
    {
      address: getPoolAddress(id),
      abi,
      functionName: "getScalingFactors"
    }
  ],
  parse: (results, shift) => ({
    ...defaultCalls.parse(results, shift),
    ...{
      inRecoveryMode: results[shift + defaultCalls.count].result,
      scalingFactors: results[shift + defaultCalls.count + 1].result
    }
  })
};
var weightedCalls = {
  count: 1,
  build: (id) => [
    {
      address: getPoolAddress(id),
      abi,
      functionName: "getNormalizedWeights"
    }
  ],
  parse: (results, shift) => ({
    weights: results[shift].result
  })
};
var linearCalls = {
  count: 3,
  build: (id) => [
    {
      address: getPoolAddress(id),
      abi,
      functionName: "getTargets"
    },
    {
      address: getPoolAddress(id),
      abi,
      functionName: "getWrappedTokenRate"
    },
    {
      address: getPoolAddress(id),
      abi,
      functionName: "getRate"
    }
  ],
  parse: (results, shift) => ({
    linearTargets: results[shift].result,
    wrappedTokenRate: results[shift + 1].result,
    poolRate: results[shift + 2].result
  })
};
var stableCalls = {
  count: 1,
  build: (id) => [
    {
      address: getPoolAddress(id),
      abi,
      functionName: "getAmplificationParameter"
    }
  ],
  parse: (results, shift) => {
    return {
      amp: results[shift].result[0]
    };
  }
};
var gyroECalls = {
  count: 1,
  build: (id) => [
    {
      address: getPoolAddress(id),
      abi,
      functionName: "getTokenRates"
    }
  ],
  parse: (results, shift) => ({
    tokenRates: results[shift].result
  })
};
var poolTypeCalls = (poolType, poolTypeVersion, vault) => {
  const do_nothing = {
    count: 0,
    build: () => [],
    parse: () => ({})
  };
  switch (poolType) {
    case "Weighted":
    case "LiquidityBootstrapping":
    case "Investment": {
      if (poolTypeVersion === 1) {
        return {
          count: defaultCalls.count + weightedCalls.count,
          build: (id) => [
            ...defaultCalls.build(id, poolType, vault),
            ...weightedCalls.build(id)
          ],
          parse: (results, shift) => ({
            ...defaultCalls.parse(results, shift),
            ...weightedCalls.parse(
              results,
              shift + defaultCalls.count
            )
          })
        };
      }
      return {
        count: defaultCallsAux.count + weightedCalls.count,
        build: (id) => [
          ...defaultCallsAux.build(id, poolType, vault),
          ...weightedCalls.build(id)
        ],
        parse: (results, shift) => ({
          ...defaultCallsAux.parse(results, shift),
          ...weightedCalls.parse(
            results,
            shift + defaultCallsAux.count
          )
        })
      };
    }
    case "Stable": {
      if (poolTypeVersion === 1) {
        return {
          count: defaultCalls.count + stableCalls.count,
          build: (id) => [
            ...defaultCalls.build(id, poolType, vault),
            ...stableCalls.build(id)
          ],
          parse: (results, shift) => ({
            ...defaultCalls.parse(results, shift),
            ...stableCalls.parse(
              results,
              shift + defaultCalls.count
            )
          })
        };
      }
      return {
        count: defaultCallsAux.count + stableCalls.count,
        build: (id) => [
          ...defaultCallsAux.build(id, poolType, vault),
          ...stableCalls.build(id)
        ],
        parse: (results, shift) => ({
          ...defaultCallsAux.parse(results, shift),
          ...stableCalls.parse(
            results,
            shift + defaultCallsAux.count
          )
        })
      };
    }
    case "StablePhantom":
    case "MetaStable":
      return {
        count: defaultCalls.count + stableCalls.count,
        build: (id) => [
          ...defaultCalls.build(id, poolType, vault),
          ...stableCalls.build(id)
        ],
        parse: (results, shift) => ({
          ...defaultCalls.parse(results, shift),
          ...stableCalls.parse(results, shift + defaultCalls.count)
        })
      };
    case "ComposableStable": {
      return {
        count: defaultCallsAux.count + stableCalls.count,
        build: (id) => [
          ...defaultCallsAux.build(id, poolType, vault),
          ...stableCalls.build(id)
        ],
        parse: (results, shift) => ({
          ...defaultCallsAux.parse(results, shift),
          ...stableCalls.parse(
            results,
            shift + defaultCallsAux.count
          )
        })
      };
    }
    case "GyroE":
      if (poolTypeVersion === 1) {
        return defaultCalls;
      }
      return {
        count: defaultCalls.count + gyroECalls.count,
        build: (id) => [
          ...defaultCalls.build(id, poolType, vault),
          ...gyroECalls.build(id)
        ],
        parse: (results, shift) => ({
          ...defaultCalls.parse(results, shift),
          ...gyroECalls.parse(results, shift + defaultCalls.count)
        })
      };
    case "AaveLinear":
      if (poolTypeVersion === 1) {
        return {
          count: defaultCalls.count + linearCalls.count,
          build: (id) => [
            ...defaultCalls.build(id, poolType, vault),
            ...linearCalls.build(id)
          ],
          parse: (results, shift) => ({
            ...defaultCalls.parse(results, shift),
            ...linearCalls.parse(
              results,
              shift + defaultCalls.count
            )
          })
        };
      }
      return defaultCallsAux;
    default:
      return do_nothing;
  }
};
var fetchAdditionalPoolData = async (vault, pools, client, options, batchSize) => {
  if (pools.length === 0) {
    return [];
  }
  const calls = pools.flatMap(
    ({ id, poolType, poolTypeVersion }) => poolTypeCalls(poolType, poolTypeVersion, vault).build(
      id,
      poolType,
      vault
    )
  );
  const results = await client.multicall({
    contracts: calls,
    batchSize,
    blockNumber: options.block
  });
  results.forEach((r, i) => {
    if (r.status === "failure")
      console.error(
        "Failed request in multicall",
        calls[i].address,
        calls[i].functionName,
        r.error
      );
  });
  let shift = 0;
  return pools.map(({ id, poolType, poolTypeVersion }) => {
    const result = {
      id,
      ...poolTypeCalls(poolType, poolTypeVersion, vault).parse(
        results,
        shift
      )
    };
    shift += poolTypeCalls(poolType, poolTypeVersion, vault).count;
    return result;
  });
};

// src/data/enrichers/onChainPoolDataEnricher.ts
var OnChainPoolDataEnricher = class {
  constructor(chainId, rpcUrl, batchSize, vault) {
    this.chainId = chainId;
    this.rpcUrl = rpcUrl;
    this.batchSize = batchSize;
    this.vault = vault;
    __publicField(this, "client");
    this.client = _viem.createPublicClient.call(void 0, {
      transport: _viem.http.call(void 0, this.rpcUrl, { timeout: 6e4 }),
      chain: CHAINS[this.chainId]
    });
  }
  async fetchAdditionalPoolData(data, options) {
    return fetchAdditionalPoolData(
      this.vault,
      data.pools,
      this.client,
      options,
      this.batchSize
    );
  }
  enrichPoolsWithData(pools, additionalPoolData) {
    return pools.map((pool) => {
      const data = additionalPoolData.find((item) => item.id === pool.id);
      return {
        ...pool,
        tokens: pool.tokens.sort((a, b) => a.index - b.index).map((token) => {
          return {
            ...token,
            balance: _optionalChain([data, 'optionalAccess', _2 => _2.balances]) && data.balances.length > 0 ? _viem.formatUnits.call(void 0, 
              data.balances[token.index],
              token.decimals
            ) : token.balance,
            priceRate: this.getPoolTokenRate({
              pool,
              token,
              data,
              index: token.index
            }),
            weight: _optionalChain([data, 'optionalAccess', _3 => _3.weights]) ? _viem.formatUnits.call(void 0, data.weights[token.index], 18) : token.weight
          };
        }),
        totalShares: _optionalChain([data, 'optionalAccess', _4 => _4.totalSupply]) ? _viem.formatUnits.call(void 0, data.totalSupply, 18) : pool.totalShares,
        amp: _optionalChain([data, 'optionalAccess', _5 => _5.amp]) ? _viem.formatUnits.call(void 0, data.amp, 3) : "amp" in pool ? pool.amp : void 0,
        swapFee: _optionalChain([data, 'optionalAccess', _6 => _6.swapFee]) ? _viem.formatUnits.call(void 0, data.swapFee, 18) : pool.swapFee,
        tokenRates: _optionalChain([data, 'optionalAccess', _7 => _7.tokenRates]) ? data.tokenRates.map(
          (tokenRate) => _viem.formatUnits.call(void 0, tokenRate, 18)
        ) : void 0,
        lowerTarget: _optionalChain([data, 'optionalAccess', _8 => _8.linearTargets]) ? _viem.formatUnits.call(void 0, data.linearTargets[0], 18) : "lowerTarget" in pool ? pool.lowerTarget : void 0,
        upperTarget: _optionalChain([data, 'optionalAccess', _9 => _9.linearTargets]) ? _viem.formatUnits.call(void 0, data.linearTargets[1], 18) : "upperTarget" in pool ? pool.upperTarget : void 0,
        inRecoveryMode: _optionalChain([data, 'optionalAccess', _10 => _10.inRecoveryMode]) || false,
        isPaused: _optionalChain([data, 'optionalAccess', _11 => _11.isPaused]) || false
      };
    });
  }
  getPoolTokenRate({
    pool,
    token,
    data,
    index
  }) {
    if (_optionalChain([data, 'optionalAccess', _12 => _12.wrappedTokenRate]) && "wrappedIndex" in pool && pool.wrappedIndex === index) {
      return _viem.formatUnits.call(void 0, data.wrappedTokenRate, 18);
    }
    if (_optionalChain([data, 'optionalAccess', _13 => _13.scalingFactors])) {
      const decimalsDiff = 18 - token.decimals;
      return _viem.formatUnits.call(void 0, data.scalingFactors[index], 18 + decimalsDiff);
    }
    return token.priceRate;
  }
};

// src/utils/fetch.ts
var _asyncretry = require('async-retry'); var _asyncretry2 = _interopRequireDefault(_asyncretry);
async function fetchWithRetry(fetch2, config = { retries: 1 }) {
  let response = null;
  await _asyncretry2.default.call(void 0, 
    async () => {
      response = await fetch2();
      return response;
    },
    {
      retries: config.retries
    }
  );
  return response;
}

// src/data/providers/subgraphPoolProvider.ts
BigInt.prototype["toJSON"] = function() {
  return this.toString();
};
var PAGE_SIZE = 1e3;
var SECS_IN_HOUR = 3600n;
var SubgraphPoolProvider = class {
  constructor(chainId, subgraphUrl, config) {
    __publicField(this, "url");
    __publicField(this, "config");
    const defaultSubgraphUrl = SUBGRAPH_URLS[chainId];
    this.url = _nullishCoalesce(subgraphUrl, () => ( defaultSubgraphUrl));
    const hasFilterConfig = config && (config.poolIdNotIn || config.poolIdIn || config.poolTypeIn || config.poolTypeNotIn);
    this.config = {
      retries: 2,
      timeout: 3e4,
      loadActiveAmpUpdates: true,
      // we assume a public subgraph is being used, so default to false
      addFilterToPoolQuery: false,
      // by default, we exclude pool types with weight updates.
      // if any filtering config is provided, this exclusion is removed.
      poolTypeNotIn: !hasFilterConfig ? ["Investment", "LiquidityBootstrapping"] : void 0,
      ...config,
      poolIdNotIn: [..._nullishCoalesce(_optionalChain([config, 'optionalAccess', _14 => _14.poolIdNotIn]), () => ( [])), ...brickedPools]
    };
  }
  async getPools(options) {
    const response = await fetchWithRetry(
      () => this.fetchDataFromSubgraph(options)
    );
    return {
      ...response,
      pools: _optionalChain([response, 'optionalAccess', _15 => _15.pools]) || [],
      syncedToBlockNumber: _optionalChain([response, 'optionalAccess', _16 => _16.syncedToBlockNumber]) || 0n
    };
  }
  async fetchDataFromSubgraph(options) {
    let ampUpdates = [];
    let syncedToBlockNumber = 0n;
    let lastId = "";
    let pools = [];
    let poolsPage = [];
    const nowMinusOneHour = options.timestamp - SECS_IN_HOUR;
    const nowPlusOneHour = options.timestamp + SECS_IN_HOUR;
    do {
      const query = this.getPoolsQuery(lastId === "");
      const variables = {
        pageSize: PAGE_SIZE,
        where: {
          id_gt: lastId || void 0,
          ...this.config.addFilterToPoolQuery ? {
            totalShares_gt: 1e-12,
            swapEnabled: true,
            poolType_in: this.config.poolTypeIn,
            poolType_not_in: this.config.poolTypeNotIn,
            id_in: this.config.poolIdIn,
            id_not_in: this.config.poolIdNotIn
          } : {}
        },
        ..._optionalChain([options, 'optionalAccess', _17 => _17.block]) ? {
          block: {
            number: Number(options.block)
          }
        } : {},
        ampUpdatesWhere: {
          endTimestamp_gte: nowMinusOneHour,
          startTimestamp_lte: nowPlusOneHour
        },
        weightedUpdatesWhere: {
          endTimestamp_gte: nowMinusOneHour,
          startTimestamp_lte: nowPlusOneHour
        }
      };
      const response = await fetch(this.url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          query,
          variables
        })
      });
      const poolsResult = await response.json();
      poolsPage = poolsResult.data.pools;
      pools = pools.concat(poolsPage);
      if (lastId === "") {
        ampUpdates = poolsResult.ampUpdates || [];
      }
      if (poolsResult._meta) {
        syncedToBlockNumber = BigInt(poolsResult._meta.block.number);
      }
      lastId = pools[pools.length - 1].id;
    } while (poolsPage.length === PAGE_SIZE);
    if (!this.config.addFilterToPoolQuery) {
      pools = pools.filter((pool) => this.poolMatchesFilter(pool));
    }
    pools = pools.map((pool) => ({
      ...pool,
      tokens: pool.tokens.map((token, index) => ({
        ...token,
        index: typeof token.index === "number" ? token.index : index
      }))
    }));
    return {
      pools,
      poolsWithActiveAmpUpdates: ampUpdates.map(
        (update) => update.poolId.id
      ),
      syncedToBlockNumber
    };
  }
  getPoolsQuery(isFirstQuery) {
    const {
      loadActiveAmpUpdates,
      loadActiveWeightUpdates,
      gqlAdditionalPoolQueryFields
    } = this.config;
    const blockNumberFragment = `
            _meta {
                block {
                    number
                }
            }
        `;
    const ampUpdatesFragment = `
            ampUpdates(where: $ampUpdatesWhere) {
                poolId {
                    id
                }
            }
        `;
    const weightUpdatesFragment = `
            gradualWeightUpdates(where: $weightedUpdatesWhere) {
                poolId {
                    id
                }
            }
        `;
    return `
            query poolsQuery(
                $pageSize: Int!
                $where: Pool_filter
                $block: Block_height
                $ampUpdatesWhere: AmpUpdate_filter
                $weightedUpdatesWhere: GradualWeightUpdate_filter
            ) {
                pools(first: $pageSize, where: $where, block: $block) {
                    id
                    address
                    poolType
                    poolTypeVersion
                    name
                    tokens {
                        address
                        balance
                        weight
                        priceRate
                        decimals
                        name
                        index
                        symbol
                        token {
                            latestFXPrice
                          }
                    }
                    tokensList
                    swapEnabled
                    swapFee
                    amp
                    totalLiquidity
                    totalShares
                    mainIndex
                    wrappedIndex
                    lowerTarget
                    upperTarget
                    alpha
                    beta
                    c
                    delta
                    dSq
                    epsilon
                    lambda
                    root3Alpha
                    s
                    sqrtAlpha
                    sqrtBeta
                    tauAlphaX
                    tauAlphaY
                    tauBetaX
                    tauBetaY
                    u
                    v
                    w
                    z
                    ${gqlAdditionalPoolQueryFields || ""}
                }
                ${isFirstQuery ? blockNumberFragment : ""}
                ${isFirstQuery && loadActiveAmpUpdates ? ampUpdatesFragment : ""}
                ${isFirstQuery && loadActiveWeightUpdates ? weightUpdatesFragment : ""}
            }
        `;
  }
  poolMatchesFilter(pool) {
    if (!pool.swapEnabled || pool.totalShares === "0.000000000001" || pool.totalShares === "0") {
      return false;
    }
    if (this.config.poolTypeIn && !this.config.poolTypeIn.includes(pool.poolType)) {
      return false;
    }
    if (_optionalChain([this, 'access', _18 => _18.config, 'access', _19 => _19.poolTypeNotIn, 'optionalAccess', _20 => _20.includes, 'call', _21 => _21(pool.poolType)])) {
      return false;
    }
    if (this.config.poolIdIn && !this.config.poolIdIn.includes(pool.id)) {
      return false;
    }
    if (_optionalChain([this, 'access', _22 => _22.config, 'access', _23 => _23.poolIdNotIn, 'optionalAccess', _24 => _24.includes, 'call', _25 => _25(pool.id)])) {
      return false;
    }
    return true;
  }
};

// src/utils/poolTypeMapper.ts
var poolTypeFromApi = {
  WEIGHTED: "Weighted" /* Weighted */,
  COMPOSABLE_STABLE: "ComposableStable" /* ComposableStable */,
  GYRO3: "Gyro3" /* Gyro3 */,
  GYRO2: "Gyro2" /* Gyro2 */,
  GYROE: "GyroE" /* GyroE */
};

// src/data/providers/balancer-api/modules/pool-state/index.ts
var Pools = class {
  constructor(balancerApiClient) {
    this.balancerApiClient = balancerApiClient;
    __publicField(this, "poolStateQuery", `query GetPool($id: String!){
    poolGetPool(id:$id) {
      id
      address
      name
      type
      version
      ... on GqlPoolWeighted {
        tokens {
          ... on GqlPoolTokenBase {
            address
             decimals
            index
          }
        }
      }
      ... on GqlPoolStable {
        tokens {
          ... on GqlPoolTokenBase {
            address
             decimals
            index
          }
        }
      }
      ... on GqlPoolComposableStable {
        tokens {
          ... on GqlPoolTokenBase {
            address
             decimals
            index
          }
        }
      }
      ... on GqlPoolGyro {
        tokens {
          ... on GqlPoolTokenBase {
            address
             decimals
            index
          }
        }
      }
      ... on GqlPoolLiquidityBootstrapping {
        tokens {
          ... on GqlPoolTokenBase {
            address
             decimals
            index
          }
        }
      }
      ... on GqlPoolElement {
        tokens {
          ... on GqlPoolTokenBase {
            address
             decimals
            index
          }
        }
      }
      ... on GqlPoolLiquidityBootstrapping {
        tokens {
          ... on GqlPoolTokenBase {
            address
             decimals
            index
          }
        }
      }
    }
}`);
  }
  async fetchPoolState(id) {
    const { data } = await this.balancerApiClient.fetch({
      query: this.poolStateQuery,
      variables: {
        id
      }
    });
    const poolGetPool = data.poolGetPool;
    return { ...poolGetPool, type: poolTypeFromApi[poolGetPool.type] };
  }
};

// src/data/providers/balancer-api/client/index.ts
var BalancerApiClient = class {
  constructor(apiUrl, chainId) {
    __publicField(this, "apiUrl");
    __publicField(this, "chainId");
    this.apiUrl = apiUrl;
    this.chainId = chainId;
  }
  async fetch(requestQuery) {
    const response = await fetch(this.apiUrl, {
      method: "post",
      body: JSON.stringify(requestQuery),
      headers: {
        "Content-Type": "application/json",
        ChainId: this.chainId.toString()
      }
    });
    return response.json();
  }
};

// src/data/providers/balancer-api/modules/nested-pool-state/index.ts
var NestedPools = class {
  constructor(balancerApiClient) {
    this.balancerApiClient = balancerApiClient;
    __publicField(this, "nestedPoolStateQuery", `
    query GetPool($id: String!){
      poolGetPool(id:$id) {
        id
        address
        name
        type
        version
        allTokens {
          id
          address
          name
          symbol
          decimals
          isNested
          isPhantomBpt
          isMainToken
        }
        ... on GqlPoolWeighted {
          nestingType
          tokens {
            ... on GqlPoolToken {
              ...GqlPoolToken
            }
            ... on GqlPoolTokenLinear {
              ...GqlPoolTokenLinear
            }
            ... on GqlPoolTokenPhantomStable {
              ...GqlPoolTokenPhantomStable
            }
          }
        }
        ... on GqlPoolPhantomStable {
          amp
          nestingType
          tokens {
            ... on GqlPoolToken {
              ...GqlPoolToken
            }
            ... on GqlPoolTokenLinear {
              ...GqlPoolTokenLinear
            }
            ... on GqlPoolTokenPhantomStable {
              ...GqlPoolTokenPhantomStable
            }
          }
        }
        ... on GqlPoolLiquidityBootstrapping {
          name
          nestingType
          tokens {
            ... on GqlPoolToken {
              ...GqlPoolToken
            }
            ... on GqlPoolTokenLinear {
              ...GqlPoolTokenLinear
            }
            ... on GqlPoolTokenPhantomStable {
              ...GqlPoolTokenPhantomStable
            }
          }
        }
      }
    }

    fragment GqlPoolToken on GqlPoolToken {
      index
      name
      symbol
      address
      decimals
    }
    
    fragment GqlPoolTokenLinear on GqlPoolTokenLinear {
      index
      name
      symbol
      address
      decimals
      pool {
        id
        name
        symbol
        address
        type
        tokens {
          ... on GqlPoolToken {
            ...GqlPoolToken
          }
        }
      }
    }
    
    fragment GqlPoolTokenPhantomStable on GqlPoolTokenPhantomStable {
      index
      name
      symbol
      address
      decimals
      pool {
        id
        name
        symbol
        address
        type
        tokens {
          ... on GqlPoolToken {
            ...GqlPoolToken
          }
          ... on GqlPoolTokenLinear {
            ...GqlPoolTokenLinear
          }
        }
      }
    }`);
    __publicField(this, "fetchNestedPoolState", async (id) => {
      const {
        data: { poolGetPool }
      } = await this.balancerApiClient.fetch({
        query: this.nestedPoolStateQuery,
        variables: {
          id
        }
      });
      const nestedPoolState = this.mapPoolToNestedPoolState(
        poolGetPool
      );
      return nestedPoolState;
    });
    __publicField(this, "mapPoolToNestedPoolState", (pool) => {
      const pools = [
        {
          id: pool.id,
          address: pool.address,
          type: this.mapPoolType(pool.type),
          level: 1,
          tokens: pool.tokens.map((t) => {
            const minimalToken = {
              address: t.address,
              decimals: t.decimals,
              index: t.index
            };
            return minimalToken;
          })
        }
      ];
      pool.tokens.forEach((token) => {
        if (token.pool === void 0)
          return;
        pools.push({
          id: token.pool.id,
          address: token.pool.address,
          level: 0,
          type: this.mapPoolType(token.pool.type),
          tokens: token.pool.tokens.map((t) => {
            const minimalToken = {
              address: t.address,
              decimals: t.decimals,
              index: t.index
            };
            return minimalToken;
          })
        });
      });
      const mainTokens = pool.allTokens.filter((t) => t.isMainToken).map((t) => {
        return {
          address: t.address,
          decimals: t.decimals
        };
      });
      return {
        pools,
        mainTokens
      };
    });
    __publicField(this, "mapPoolType", (type) => {
      switch (type) {
        case "WEIGHTED":
          return "Weighted" /* Weighted */;
        case "PHANTOM_STABLE":
          return "ComposableStable" /* ComposableStable */;
        default:
          throw new Error(`Unsupported pool type ${type}`);
      }
    });
  }
};

// src/data/providers/balancer-api/index.ts
var BalancerApi = class {
  constructor(balancerApiUrl, chainId) {
    __publicField(this, "balancerApiClient");
    __publicField(this, "pools");
    __publicField(this, "nestedPools");
    this.balancerApiClient = new BalancerApiClient(balancerApiUrl, chainId);
    this.pools = new Pools(this.balancerApiClient);
    this.nestedPools = new NestedPools(this.balancerApiClient);
  }
};

// src/entities/addLiquidityNested/index.ts


// src/entities/relayer/index.ts









// src/entities/relayer/authorization.ts






var _RelayerAuthorization = class {
  /**
   * Cannot be constructed.
   */
  constructor() {
  }
};
var RelayerAuthorization = _RelayerAuthorization;
__publicField(RelayerAuthorization, "encodeCalldataAuthorization", (calldata, deadline, signatureHex) => {
  const encodedDeadline = _viem.pad.call(void 0, _viem.toHex.call(void 0, deadline), { size: 32 });
  const { v, r, s } = _viem.hexToSignature.call(void 0, signatureHex);
  const encodedV = _viem.pad.call(void 0, _viem.toHex.call(void 0, v), { size: 32 });
  const encodedR = _viem.pad.call(void 0, r, { size: 32 });
  const encodedS = _viem.pad.call(void 0, s, { size: 32 });
  return _viem.concat.call(void 0, [
    calldata,
    encodedDeadline,
    encodedV,
    encodedR,
    encodedS
  ]);
});
__publicField(RelayerAuthorization, "signJoinAuthorization", (client, signerAddress, allowedSender, allowedCalldata, deadline, nonce) => _RelayerAuthorization.signAuthorizationFor(
  "JoinPool" /* JoinPool */,
  client,
  signerAddress,
  allowedSender,
  allowedCalldata,
  deadline,
  nonce
));
__publicField(RelayerAuthorization, "signExitAuthorization", (client, signerAddress, allowedSender, allowedCalldata, deadline, nonce) => _RelayerAuthorization.signAuthorizationFor(
  "ExitPool" /* ExitPool */,
  client,
  signerAddress,
  allowedSender,
  allowedCalldata,
  deadline,
  nonce
));
__publicField(RelayerAuthorization, "signSwapAuthorization", (client, signerAddress, allowedSender, allowedCalldata, deadline, nonce) => _RelayerAuthorization.signAuthorizationFor(
  "Swap" /* Swap */,
  client,
  signerAddress,
  allowedSender,
  allowedCalldata,
  deadline,
  nonce
));
__publicField(RelayerAuthorization, "signBatchSwapAuthorization", (client, signerAddress, allowedSender, allowedCalldata, deadline, nonce) => _RelayerAuthorization.signAuthorizationFor(
  "BatchSwap" /* BatchSwap */,
  client,
  signerAddress,
  allowedSender,
  allowedCalldata,
  deadline,
  nonce
));
__publicField(RelayerAuthorization, "signSetRelayerApprovalAuthorization", (client, signerAddress, allowedSender, allowedCalldata, deadline, nonce) => _RelayerAuthorization.signAuthorizationFor(
  "SetRelayerApproval" /* SetRelayerApproval */,
  client,
  signerAddress,
  allowedSender,
  allowedCalldata,
  deadline,
  nonce
));
__publicField(RelayerAuthorization, "signAuthorizationFor", async (type, client, signerAddress, allowedSender, allowedCalldata, deadline = MAX_UINT256, nonce) => {
  const chainId = await client.getChainId();
  const verifyingContract = BALANCER_VAULT;
  const domain = {
    name: "Balancer V2 Vault",
    version: "1",
    chainId,
    verifyingContract
  };
  const types = {
    [type]: [
      { name: "calldata", type: "bytes" },
      { name: "sender", type: "address" },
      { name: "nonce", type: "uint256" },
      { name: "deadline", type: "uint256" }
    ]
  };
  let _nonce = nonce;
  if (_nonce === void 0) {
    _nonce = await client.readContract({
      abi: vaultAbi,
      address: verifyingContract,
      functionName: "getNextNonce",
      args: [allowedSender]
    });
  }
  const signature = client.signTypedData({
    account: signerAddress,
    domain,
    types,
    primaryType: type,
    message: {
      calldata: allowedCalldata,
      sender: allowedSender,
      nonce: _nonce,
      deadline
    }
  });
  return signature;
});

// src/entities/relayer/index.ts
var _Relayer = class {
  // Read-only reference: it is not deleted after a read.
  static toChainedReference(key, isTemporary = true) {
    const prefix = isTemporary ? _Relayer.CHAINED_REFERENCE_TEMP_PREFIX : _Relayer.CHAINED_REFERENCE_READONLY_PREFIX;
    const paddedKey = _viem.pad.call(void 0, _viem.toHex.call(void 0, key), { dir: "left", size: 30 });
    const chainedReferenceWithPrefix = _viem.concat.call(void 0, [prefix, paddedKey]);
    return _viem.hexToBigInt.call(void 0, chainedReferenceWithPrefix);
  }
  static fromChainedReference(ref) {
    const chainedReferenceWithoutPrefix = _viem.slice.call(void 0, _viem.toHex.call(void 0, ref), 2);
    return _viem.hexToBigInt.call(void 0, chainedReferenceWithoutPrefix);
  }
  static encodePeekChainedReferenceValue(reference) {
    return _viem.encodeFunctionData.call(void 0, {
      abi: batchRelayerLibraryAbi,
      functionName: "peekChainedReferenceValue",
      args: [reference]
    });
  }
  static encodeSetRelayerApproval(relayerAddress, approved, signature) {
    return _viem.encodeFunctionData.call(void 0, {
      abi: batchRelayerLibraryAbi,
      functionName: "setRelayerApproval",
      args: [relayerAddress, approved, signature]
    });
  }
};
var Relayer = _Relayer;
__publicField(Relayer, "CHAINED_REFERENCE_TEMP_PREFIX", "0xba10");
// Temporary reference: it is deleted after a read.
__publicField(Relayer, "CHAINED_REFERENCE_READONLY_PREFIX", "0xba11");
__publicField(Relayer, "signRelayerApproval", async (relayerAddress, signerAddress, client) => {
  const approval = _viem.encodeFunctionData.call(void 0, {
    abi: vaultAbi,
    functionName: "setRelayerApproval",
    args: [signerAddress, relayerAddress, true]
  });
  const signature = await RelayerAuthorization.signSetRelayerApprovalAuthorization(
    client,
    signerAddress,
    relayerAddress,
    approval
  );
  const encodedSignature = RelayerAuthorization.encodeCalldataAuthorization(
    "0x",
    MAX_UINT256,
    signature
  );
  return encodedSignature;
});

// src/entities/encoders/weighted.ts


// src/entities/addLiquidity/types.ts
var AddLiquidityKind = /* @__PURE__ */ ((AddLiquidityKind2) => {
  AddLiquidityKind2["Init"] = "Init";
  AddLiquidityKind2["Unbalanced"] = "Unbalanced";
  AddLiquidityKind2["SingleToken"] = "SingleToken";
  AddLiquidityKind2["Proportional"] = "Proportional";
  return AddLiquidityKind2;
})(AddLiquidityKind || {});

// src/entities/removeLiquidity/types.ts
var RemoveLiquidityKind = /* @__PURE__ */ ((RemoveLiquidityKind2) => {
  RemoveLiquidityKind2["Unbalanced"] = "Unbalanced";
  RemoveLiquidityKind2["SingleToken"] = "SingleToken";
  RemoveLiquidityKind2["Proportional"] = "Proportional";
  return RemoveLiquidityKind2;
})(RemoveLiquidityKind || {});

// src/entities/encoders/weighted.ts
var WeightedPoolJoinKind = /* @__PURE__ */ ((WeightedPoolJoinKind2) => {
  WeightedPoolJoinKind2[WeightedPoolJoinKind2["INIT"] = 0] = "INIT";
  WeightedPoolJoinKind2[WeightedPoolJoinKind2["EXACT_TOKENS_IN_FOR_BPT_OUT"] = 1] = "EXACT_TOKENS_IN_FOR_BPT_OUT";
  WeightedPoolJoinKind2[WeightedPoolJoinKind2["TOKEN_IN_FOR_EXACT_BPT_OUT"] = 2] = "TOKEN_IN_FOR_EXACT_BPT_OUT";
  WeightedPoolJoinKind2[WeightedPoolJoinKind2["ALL_TOKENS_IN_FOR_EXACT_BPT_OUT"] = 3] = "ALL_TOKENS_IN_FOR_EXACT_BPT_OUT";
  return WeightedPoolJoinKind2;
})(WeightedPoolJoinKind || {});
var WeightedPoolExitKind = /* @__PURE__ */ ((WeightedPoolExitKind2) => {
  WeightedPoolExitKind2[WeightedPoolExitKind2["EXACT_BPT_IN_FOR_ONE_TOKEN_OUT"] = 0] = "EXACT_BPT_IN_FOR_ONE_TOKEN_OUT";
  WeightedPoolExitKind2[WeightedPoolExitKind2["EXACT_BPT_IN_FOR_TOKENS_OUT"] = 1] = "EXACT_BPT_IN_FOR_TOKENS_OUT";
  WeightedPoolExitKind2[WeightedPoolExitKind2["BPT_IN_FOR_EXACT_TOKENS_OUT"] = 2] = "BPT_IN_FOR_EXACT_TOKENS_OUT";
  WeightedPoolExitKind2[WeightedPoolExitKind2["MANAGEMENT_FEE_TOKENS_OUT"] = 3] = "MANAGEMENT_FEE_TOKENS_OUT";
  return WeightedPoolExitKind2;
})(WeightedPoolExitKind || {});
var _WeightedEncoder = class {
  /**
   * Cannot be constructed.
   */
  constructor() {
  }
  /**
   * Encodes the User Data for initializing a WeightedPool
   * @param amounts Amounts of tokens to be added to the pool
   * @returns
   */
  static encodeInitPoolUserData(amounts) {
    return _WeightedEncoder.initPool(amounts.maxAmountsIn);
  }
  /**
   * Encodes the User Data for adding liquidity to a WeightedPool
   * @param kind Kind of the Add Liquidity operation: Init, Unbalanced, SingleToken, Proportional
   * @param amounts Amounts of tokens to be added to the pool
   * @returns
   */
  static encodeAddLiquidityUserData(kind, amounts) {
    switch (kind) {
      case "Init" /* Init */:
        throw new Error(
          "For this kind use initPool instead of addLiquidity"
        );
      case "Unbalanced" /* Unbalanced */:
        return _WeightedEncoder.addLiquidityUnbalanced(
          amounts.maxAmountsIn,
          amounts.minimumBpt
        );
      case "SingleToken" /* SingleToken */: {
        if (amounts.tokenInIndex === void 0)
          throw Error("No Index");
        return _WeightedEncoder.addLiquiditySingleToken(
          amounts.minimumBpt,
          amounts.tokenInIndex
        );
      }
      case "Proportional" /* Proportional */: {
        return _WeightedEncoder.addLiquidityProportional(
          amounts.minimumBpt
        );
      }
      default:
        throw Error("Unsupported Add Liquidity Kind");
    }
  }
  /**
   * Encodes the User Data for removing liquidity from a WeightedPool
   * @param kind Kind of the Remove Liquidity operation: Unbalanced, SingleToken, Proportional
   * @param amounts Amounts of tokens to be removed from the pool
   * @returns
   */
  static encodeRemoveLiquidityUserData(kind, amounts) {
    switch (kind) {
      case "Unbalanced" /* Unbalanced */:
        return _WeightedEncoder.removeLiquidityUnbalanced(
          amounts.minAmountsOut,
          amounts.maxBptAmountIn
        );
      case "SingleToken" /* SingleToken */:
        if (amounts.tokenOutIndex === void 0)
          throw Error("No Index");
        return _WeightedEncoder.removeLiquiditySingleToken(
          amounts.maxBptAmountIn,
          amounts.tokenOutIndex
        );
      case "Proportional" /* Proportional */:
        return _WeightedEncoder.removeLiquidityProportional(
          amounts.maxBptAmountIn
        );
      default:
        throw Error("Unsupported Remove Liquidity Kind");
    }
  }
};
var WeightedEncoder = _WeightedEncoder;
/**
 * Encodes the userData parameter for providing the initial liquidity to a WeightedPool
 * @param initialBalances - the amounts of tokens to send to the pool to form the initial balances
 */
__publicField(WeightedEncoder, "initPool", (amountsIn) => _viem.encodeAbiParameters.call(void 0, 
  [{ type: "uint256" }, { type: "uint256[]" }],
  [BigInt(0 /* INIT */), amountsIn]
));
/**
 * Encodes the userData parameter for adding liquidity to a WeightedPool with exact token inputs
 * @param amountsIn - the amounts each of token to deposit in the pool as liquidity
 * @param minimumBPT - the minimum acceptable BPT to receive in return for deposited tokens
 */
__publicField(WeightedEncoder, "addLiquidityUnbalanced", (amountsIn, minimumBPT) => _viem.encodeAbiParameters.call(void 0, 
  [{ type: "uint256" }, { type: "uint256[]" }, { type: "uint256" }],
  [
    BigInt(1 /* EXACT_TOKENS_IN_FOR_BPT_OUT */),
    amountsIn,
    minimumBPT
  ]
));
/**
 * Encodes the userData parameter for adding liquidity to a WeightedPool with a single token to receive an exact amount of BPT
 * @param bptAmountOut - the amount of BPT to be minted
 * @param tokenIndex - the index of the token to be provided as liquidity
 */
__publicField(WeightedEncoder, "addLiquiditySingleToken", (bptAmountOut, tokenIndex) => {
  return _viem.encodeAbiParameters.call(void 0, 
    [{ type: "uint256" }, { type: "uint256" }, { type: "uint256" }],
    [
      BigInt(2 /* TOKEN_IN_FOR_EXACT_BPT_OUT */),
      bptAmountOut,
      BigInt(tokenIndex)
    ]
  );
});
/**
 * Encodes the userData parameter for adding liquidity to a WeightedPool proportionally to receive an exact amount of BPT
 * @param bptAmountOut - the amount of BPT to be minted
 */
__publicField(WeightedEncoder, "addLiquidityProportional", (bptAmountOut) => {
  return _viem.encodeAbiParameters.call(void 0, 
    [{ type: "uint256" }, { type: "uint256" }],
    [
      BigInt(3 /* ALL_TOKENS_IN_FOR_EXACT_BPT_OUT */),
      bptAmountOut
    ]
  );
});
/**
 * Encodes the userData parameter for removing liquidity from a WeightedPool by removing tokens in return for an exact amount of BPT
 * @param bptAmountIn - the amount of BPT to be burned
 * @param tokenIndex - the index of the token to removed from the pool
 */
__publicField(WeightedEncoder, "removeLiquiditySingleToken", (bptAmountIn, tokenIndex) => {
  return _viem.encodeAbiParameters.call(void 0, 
    [{ type: "uint256" }, { type: "uint256" }, { type: "uint256" }],
    [
      BigInt(0 /* EXACT_BPT_IN_FOR_ONE_TOKEN_OUT */),
      bptAmountIn,
      BigInt(tokenIndex)
    ]
  );
});
/**
 * Encodes the userData parameter for removing liquidity from a WeightedPool by removing tokens in return for an exact amount of BPT
 * @param bptAmountIn - the amount of BPT to be burned
 */
__publicField(WeightedEncoder, "removeLiquidityProportional", (bptAmountIn) => {
  return _viem.encodeAbiParameters.call(void 0, 
    [{ type: "uint256" }, { type: "uint256" }],
    [
      BigInt(1 /* EXACT_BPT_IN_FOR_TOKENS_OUT */),
      bptAmountIn
    ]
  );
});
/**
 * Encodes the userData parameter for removing liquidity from a WeightedPool by removing exact amounts of tokens
 * @param amountsOut - the amounts of each token to be withdrawn from the pool
 * @param maxBPTAmountIn - the minimum acceptable BPT to burn in return for withdrawn tokens
 */
__publicField(WeightedEncoder, "removeLiquidityUnbalanced", (amountsOut, maxBPTAmountIn) => _viem.encodeAbiParameters.call(void 0, 
  [{ type: "uint256" }, { type: "uint256[]" }, { type: "uint256" }],
  [
    BigInt(2 /* BPT_IN_FOR_EXACT_TOKENS_OUT */),
    amountsOut,
    maxBPTAmountIn
  ]
));

// src/entities/encoders/index.ts
var getEncoder = (poolType) => {
  switch (poolType) {
    case "Weighted":
      return WeightedEncoder;
    default:
      return void 0;
  }
};

// src/entities/encoders/composableStable.ts

var _ComposableStableEncoder = class {
  /**
   * Cannot be constructed.
   */
  constructor() {
  }
  /**
   * Encodes the User Data for initializing a WeightedPool
   * @param amounts Amounts of tokens to be added to the pool
   * @returns
   */
  static encodeInitPoolUserData(amounts) {
    return _ComposableStableEncoder.initPool(amounts.amountsIn);
  }
  /**
   * Encodes the User Data for adding liquidity to a ComposableStablePool
   * @param kind Kind of the Add Liquidity operation: Init, Unbalanced, SingleToken, Proportional
   * @param amounts Amounts of tokens to be added to the pool
   * @returns
   */
  static encodeAddLiquidityUserData(kind, amounts) {
    switch (kind) {
      case "Init" /* Init */:
        throw new Error(
          "For this kind use initPool instead of addLiquidity"
        );
      case "Unbalanced" /* Unbalanced */:
        return _ComposableStableEncoder.addLiquidityUnbalanced(
          amounts.maxAmountsInWithoutBpt,
          amounts.minimumBpt
        );
      case "SingleToken" /* SingleToken */: {
        if (amounts.tokenInIndex === void 0)
          throw Error("No Index");
        return _ComposableStableEncoder.addLiquiditySingleToken(
          amounts.minimumBpt,
          amounts.tokenInIndex
          // Has to be index without BPT
        );
      }
      case "Proportional" /* Proportional */: {
        return _ComposableStableEncoder.addLiquidityProportional(
          amounts.minimumBpt
        );
      }
      default:
        throw Error("Unsupported Add Liquidity Kind");
    }
  }
  /**
   * Encodes the User Data for removing liquidity to a ComposableStablePool
   * @param kind Kind of the Remove Liquidity operation: Unbalanced, SingleToken, Proportional
   * @param amounts Amounts of tokens to be removed from the pool
   * @returns
   */
  static encodeRemoveLiquidityUserData(kind, amounts) {
    switch (kind) {
      case "Unbalanced" /* Unbalanced */:
        return _ComposableStableEncoder.removeLiquidityUnbalanced(
          amounts.minAmountsOut,
          amounts.maxBptAmountIn
        );
      case "SingleToken" /* SingleToken */:
        if (amounts.tokenOutIndex === void 0)
          throw new Error(
            "tokenOutIndex must be defined for RemoveLiquiditySingleToken"
          );
        return _ComposableStableEncoder.removeLiquiditySingleToken(
          amounts.maxBptAmountIn,
          amounts.tokenOutIndex
        );
      case "Proportional" /* Proportional */:
        return _ComposableStableEncoder.removeLiquidityProportional(
          amounts.maxBptAmountIn
        );
      default:
        throw Error("Unsupported Remove Liquidity Kind");
    }
  }
};
var ComposableStableEncoder = _ComposableStableEncoder;
/**
 * Encodes the userData parameter for providing the initial liquidity to a ComposableStablePool
 * @param initialBalances - the amounts of tokens to send to the pool to form the initial balances
 */
__publicField(ComposableStableEncoder, "initPool", (amountsIn) => _viem.encodeAbiParameters.call(void 0, 
  [{ type: "uint256" }, { type: "uint256[]" }],
  [BigInt(0 /* INIT */), amountsIn]
));
/**
 * Encodes the userData parameter for adding liquidity to a ComposableStablePool with exact token inputs
 * @param amountsIn - the amounts each of token to deposit in the pool as liquidity
 * @param minimumBPT - the minimum acceptable BPT to receive in return for deposited tokens
 */
__publicField(ComposableStableEncoder, "addLiquidityUnbalanced", (amountsIn, minimumBPT) => _viem.encodeAbiParameters.call(void 0, 
  [{ type: "uint256" }, { type: "uint256[]" }, { type: "uint256" }],
  [
    BigInt(
      1 /* EXACT_TOKENS_IN_FOR_BPT_OUT */
    ),
    amountsIn,
    minimumBPT
  ]
));
/**
 * Encodes the userData parameter for adding liquidity to a ComposableStablePool with a single token to receive an exact amount of BPT
 * @param bptAmountOut - the amount of BPT to be minted
 * @param tokenIndex - the index of the token to be provided as liquidity
 */
__publicField(ComposableStableEncoder, "addLiquiditySingleToken", (bptAmountOut, tokenIndex) => {
  return _viem.encodeAbiParameters.call(void 0, 
    [{ type: "uint256" }, { type: "uint256" }, { type: "uint256" }],
    [
      BigInt(2 /* TOKEN_IN_FOR_EXACT_BPT_OUT */),
      bptAmountOut,
      BigInt(tokenIndex)
    ]
  );
});
/**
 * Encodes the userData parameter for adding liquidity to a ComposableStablePool proportionally to receive an exact amount of BPT
 * @param bptAmountOut - the amount of BPT to be minted
 */
__publicField(ComposableStableEncoder, "addLiquidityProportional", (bptAmountOut) => {
  return _viem.encodeAbiParameters.call(void 0, 
    [{ type: "uint256" }, { type: "uint256" }],
    [
      BigInt(
        3 /* ALL_TOKENS_IN_FOR_EXACT_BPT_OUT */
      ),
      bptAmountOut
    ]
  );
});
/**
 * Encodes the userData parameter for removing liquidity from a ComposableStablePool by removing tokens in return for an exact amount of BPT
 * @param bptAmountIn - the amount of BPT to be burned
 * @param tokenIndex - the index of the token to be removed from the pool
 */
__publicField(ComposableStableEncoder, "removeLiquiditySingleToken", (bptAmountIn, tokenIndex) => {
  return _viem.encodeAbiParameters.call(void 0, 
    [{ type: "uint256" }, { type: "uint256" }, { type: "uint256" }],
    [
      BigInt(
        0 /* EXACT_BPT_IN_FOR_ONE_TOKEN_OUT */
      ),
      bptAmountIn,
      BigInt(tokenIndex)
    ]
  );
});
/**
 * Encodes the userData parameter for removing liquidity from a ComposableStablePool by removing tokens in return for an exact amount of BPT
 * @param bptAmountIn - the amount of BPT to be burned
 */
__publicField(ComposableStableEncoder, "removeLiquidityProportional", (bptAmountIn) => {
  return _viem.encodeAbiParameters.call(void 0, 
    [{ type: "uint256" }, { type: "uint256" }],
    [
      BigInt(
        2 /* EXACT_BPT_IN_FOR_ALL_TOKENS_OUT */
      ),
      bptAmountIn
    ]
  );
});
/**
 * Encodes the userData parameter for removing liquidity from a ComposableStablePool by removing exact amounts of tokens
 * @param amountsOut - the amounts of each token to be withdrawn from the pool
 * @param maxBPTAmountIn - the minimum acceptable BPT to burn in return for withdrawn tokens
 */
__publicField(ComposableStableEncoder, "removeLiquidityUnbalanced", (amountsOut, maxBPTAmountIn) => _viem.encodeAbiParameters.call(void 0, 
  [{ type: "uint256" }, { type: "uint256[]" }, { type: "uint256" }],
  [
    BigInt(
      1 /* BPT_IN_FOR_EXACT_TOKENS_OUT */
    ),
    amountsOut,
    maxBPTAmountIn
  ]
));

// src/entities/utils/replaceWrapped.ts
function replaceWrapped(tokens, chainId) {
  return tokens.map((token) => {
    if (token.isUnderlyingEqual(NATIVE_ASSETS[chainId])) {
      return new Token(chainId, ZERO_ADDRESS, 18);
    }
    return token;
  });
}

// src/entities/addLiquidityNested/encodeCalls.ts

var encodeCalls = (callsAttributes) => {
  const encodedCalls = [];
  const values = [];
  for (const callAttributes of callsAttributes) {
    const {
      useNativeAssetAsWrappedAmountIn,
      chainId,
      sortedTokens,
      poolId,
      poolAddress,
      poolType,
      kind,
      sender,
      recipient,
      maxAmountsIn,
      minBptOut,
      fromInternalBalance,
      outputReference
    } = callAttributes;
    let tokensIn = [...sortedTokens];
    let value = 0n;
    if (useNativeAssetAsWrappedAmountIn) {
      tokensIn = replaceWrapped([...sortedTokens], chainId);
      const nativeAssetIndex = tokensIn.findIndex(
        (t) => t.isSameAddress(ZERO_ADDRESS)
      );
      if (nativeAssetIndex > -1) {
        value = maxAmountsIn[nativeAssetIndex].amount;
      }
    }
    const _maxAmountsIn = maxAmountsIn.map((a) => a.amount);
    const amountsInWithoutBpt = _maxAmountsIn.filter(
      (_, i) => !sortedTokens[i].isSameAddress(poolAddress)
    );
    const userData = getUserData(poolType, amountsInWithoutBpt, minBptOut);
    const joinPoolRequest = {
      assets: tokensIn.map((t) => t.address),
      // with BPT
      maxAmountsIn: _maxAmountsIn,
      // with BPT
      userData,
      // wihtout BPT
      fromInternalBalance
    };
    const encodedCall = _viem.encodeFunctionData.call(void 0, {
      abi: batchRelayerLibraryAbi,
      functionName: "joinPool",
      args: [
        poolId,
        kind,
        sender,
        recipient,
        joinPoolRequest,
        value,
        outputReference
      ]
    });
    encodedCalls.push(encodedCall);
    values.push(value);
  }
  return { encodedCalls, values };
};
var getUserData = (poolType, amountsInWithoutBpt, minBptOut) => {
  switch (poolType) {
    case "Weighted" /* Weighted */:
      return WeightedEncoder.addLiquidityUnbalanced(
        amountsInWithoutBpt,
        minBptOut
      );
    case "ComposableStable" /* ComposableStable */:
      return ComposableStableEncoder.addLiquidityUnbalanced(
        amountsInWithoutBpt,
        minBptOut
      );
    default:
      throw new Error(`Unsupported pool type: ${poolType}`);
  }
};

// src/entities/addLiquidityNested/doAddLiquidityNestedQuery.ts






var doAddLiquidityNestedQuery = async (chainId, rpcUrl, accountAddress, encodedMulticall) => {
  const client = _viem.createPublicClient.call(void 0, {
    transport: _viem.http.call(void 0, rpcUrl),
    chain: CHAINS[chainId]
  });
  const { data } = await client.call({
    account: accountAddress,
    to: BALANCER_RELAYER[chainId],
    data: encodedMulticall
  });
  const result = _viem.decodeFunctionResult.call(void 0, {
    abi: balancerRelayerAbi,
    functionName: "vaultActionsQueryMulticall",
    data
  });
  const peekedValue = _viem.decodeAbiParameters.call(void 0, 
    [{ type: "uint256" }],
    result[result.length - 1]
  )[0];
  return peekedValue;
};

// src/entities/types.ts
var PoolKind = /* @__PURE__ */ ((PoolKind2) => {
  PoolKind2[PoolKind2["WEIGHTED"] = 0] = "WEIGHTED";
  PoolKind2[PoolKind2["LEGACY_STABLE"] = 1] = "LEGACY_STABLE";
  PoolKind2[PoolKind2["COMPOSABLE_STABLE"] = 2] = "COMPOSABLE_STABLE";
  PoolKind2[PoolKind2["COMPOSABLE_STABLE_V2"] = 3] = "COMPOSABLE_STABLE_V2";
  return PoolKind2;
})(PoolKind || {});

// src/entities/addLiquidityNested/getQueryCallsAttributes.ts
var getQueryCallsAttributes = ({
  amountsIn,
  chainId,
  accountAddress,
  useNativeAssetAsWrappedAmountIn,
  fromInternalBalance
}, pools) => {
  const poolsSortedByLevel = pools.sort((a, b) => a.level - b.level);
  const calls = [];
  for (const pool of poolsSortedByLevel) {
    const sortedTokens = pool.tokens.sort((a, b) => a.index - b.index).map((t) => new Token(chainId, t.address, t.decimals));
    const maxAmountsIn = getMaxAmountsIn(sortedTokens, amountsIn, calls);
    calls.push({
      chainId,
      useNativeAssetAsWrappedAmountIn: _nullishCoalesce(useNativeAssetAsWrappedAmountIn, () => ( false)),
      sortedTokens,
      poolId: pool.id,
      poolAddress: pool.address,
      poolType: pool.type,
      kind: pool.type === "ComposableStable" /* ComposableStable */ ? 3 /* COMPOSABLE_STABLE_V2 */ : 0 /* WEIGHTED */,
      sender: getSender(maxAmountsIn, accountAddress, chainId),
      recipient: "0x",
      // set as placeholder - will be updated after all calls are created
      maxAmountsIn,
      minBptOut: 0n,
      // limits set to zero for query calls
      fromInternalBalance: _nullishCoalesce(fromInternalBalance, () => ( false)),
      outputReference: Relayer.toChainedReference(
        BigInt(poolsSortedByLevel.indexOf(pool))
      )
    });
  }
  updateRecipients(calls, accountAddress);
  return calls;
};
var getMaxAmountsIn = (sortedTokens, amountsIn, calls) => {
  return sortedTokens.map((token) => {
    const amountIn = amountsIn.find((a) => token.isSameAddress(a.address));
    if (amountIn !== void 0) {
      return {
        amount: amountIn.rawAmount,
        isRef: false
      };
    }
    const previousCall = calls.find(
      (call) => getPoolAddress(call.poolId) === token.address
    );
    if (previousCall !== void 0) {
      return {
        amount: previousCall.outputReference,
        isRef: true
      };
    }
    return {
      amount: 0n,
      isRef: false
    };
  });
};
var getSender = (maxAmountsIn, accountAddress, chainId) => {
  return maxAmountsIn.some((a) => !a.isRef && a.amount > 0n) ? accountAddress : BALANCER_RELAYER[chainId];
};
var updateRecipients = (calls, accountAddress) => {
  for (const call of calls) {
    const followingCall = calls.find(
      (_call) => _call.maxAmountsIn.some((a) => a.amount === call.outputReference)
    );
    if (followingCall !== void 0) {
      call.recipient = followingCall.sender;
    } else {
      call.recipient = accountAddress;
    }
  }
};

// src/entities/utils/doAddLiquidityQuery.ts

async function doAddLiquidityQuery(rpcUrl, chainId, args) {
  const client = _viem.createPublicClient.call(void 0, {
    transport: _viem.http.call(void 0, rpcUrl),
    chain: CHAINS[chainId]
  });
  const {
    result: [bptOut, amountsIn]
  } = await client.simulateContract({
    address: BALANCER_QUERIES[chainId],
    abi: balancerQueriesAbi,
    functionName: "queryJoin",
    args
  });
  return {
    bptOut,
    amountsIn
  };
}

// src/entities/utils/getAmounts.ts
function getAmounts(tokens, amounts, defaultAmount = 0n) {
  return tokens.map(
    (t) => _nullishCoalesce(_optionalChain([amounts, 'access', _26 => _26.find, 'call', _27 => _27((a) => t.isSameAddress(a.address)), 'optionalAccess', _28 => _28.rawAmount]), () => ( defaultAmount))
  );
}

// src/entities/utils/getSortedTokens.ts
function getSortedTokens(tokens, chainId) {
  return tokens.sort((a, b) => a.index - b.index).map((t) => new Token(chainId, t.address, t.decimals));
}

// src/entities/utils/parseAddLiquidityArgs.ts
function parseAddLiquidityArgs({
  useNativeAssetAsWrappedAmountIn,
  chainId,
  sortedTokens,
  poolId,
  sender,
  recipient,
  maxAmountsIn,
  userData,
  fromInternalBalance
}) {
  const tokensIn = chainId && useNativeAssetAsWrappedAmountIn ? replaceWrapped([...sortedTokens], chainId) : [...sortedTokens];
  const joinPoolRequest = {
    assets: tokensIn.map((t) => t.address),
    // with BPT
    maxAmountsIn,
    // with BPT
    userData,
    // wihtout BPT
    fromInternalBalance
  };
  return {
    args: [poolId, sender, recipient, joinPoolRequest],
    tokensIn
  };
}

// src/entities/utils/constraintValidation.ts
function constraintValidation(nestedPoolState) {
  const topLevel = Math.max(...nestedPoolState.pools.map((p) => p.level));
  nestedPoolState.mainTokens.forEach((t) => {
    const poolsWithToken = nestedPoolState.pools.filter(
      (p) => p.tokens.some((pt) => pt.address === t.address)
    );
    if (poolsWithToken.length < 1)
      throw "NestedPoolState, main token must exist as a token of a pool";
    if (poolsWithToken.length > 1)
      throw `NestedPoolState, main token can't be token of more than 1 pool`;
    if (poolsWithToken[0]) {
      if (topLevel - poolsWithToken[0].level > 1)
        throw "NestedPoolState, main token only supported to a max of 1 level of nesting";
    }
  });
  return true;
}

// src/entities/addLiquidityNested/validateInputs.ts
var validateInputs = (input, nestedPoolState) => {
  constraintValidation(nestedPoolState);
  const mainTokens = nestedPoolState.mainTokens.map(
    (t) => new Token(input.chainId, t.address, t.decimals)
  );
  const amountsIn = input.amountsIn.map((amountIn) => {
    const tokenIn = mainTokens.find(
      (t) => t.isSameAddress(amountIn.address)
    );
    if (tokenIn === void 0) {
      throw new Error(
        `Adding liquidity with ${tokenIn} requires it to exist within mainTokens`
      );
    }
    return TokenAmount.fromRawAmount(tokenIn, amountIn.rawAmount);
  });
  if (input.useNativeAssetAsWrappedAmountIn) {
    if (!mainTokens.some(
      (t) => t.isUnderlyingEqual(NATIVE_ASSETS[input.chainId])
    )) {
      throw new Error(
        "Adding liquidity with native asset requires wrapped native asset to exist within mainTokens"
      );
    }
    if (!amountsIn.some(
      (a) => a.token.isUnderlyingEqual(NATIVE_ASSETS[input.chainId])
    )) {
      throw new Error(
        "Adding liquidity with native asset requires wrapped native asset to exist within amountsIn"
      );
    }
  }
  return amountsIn;
};

// src/entities/addLiquidityNested/index.ts
var AddLiquidityNested = class {
  async query(input, nestedPoolState) {
    const amountsIn = validateInputs(input, nestedPoolState);
    const callsAttributes = getQueryCallsAttributes(
      input,
      nestedPoolState.pools
    );
    const { encodedCalls } = encodeCalls(callsAttributes);
    const peekCall = Relayer.encodePeekChainedReferenceValue(
      callsAttributes[callsAttributes.length - 1].outputReference
    );
    encodedCalls.push(peekCall);
    const encodedMulticall = _viem.encodeFunctionData.call(void 0, {
      abi: balancerRelayerAbi,
      functionName: "vaultActionsQueryMulticall",
      args: [encodedCalls]
    });
    const peekedValue = await doAddLiquidityNestedQuery(
      input.chainId,
      input.rpcUrl,
      input.accountAddress,
      encodedMulticall
    );
    const tokenOut = new Token(
      input.chainId,
      callsAttributes[callsAttributes.length - 1].poolAddress,
      18
    );
    const bptOut = TokenAmount.fromRawAmount(tokenOut, peekedValue);
    return { callsAttributes, amountsIn, bptOut };
  }
  buildCall(input) {
    const minBptOut = input.slippage.removeFrom(input.bptOut.amount);
    input.callsAttributes[input.callsAttributes.length - 1] = {
      ...input.callsAttributes[input.callsAttributes.length - 1],
      minBptOut
    };
    const { encodedCalls, values } = encodeCalls(input.callsAttributes);
    if (input.relayerApprovalSignature !== void 0) {
      encodedCalls.unshift(
        Relayer.encodeSetRelayerApproval(
          BALANCER_RELAYER[input.callsAttributes[0].chainId],
          true,
          input.relayerApprovalSignature
        )
      );
    }
    const call = _viem.encodeFunctionData.call(void 0, {
      abi: balancerRelayerAbi,
      functionName: "multicall",
      args: [encodedCalls]
    });
    const accumulatedValue = values.reduce((acc, value) => {
      return acc + value;
    }, 0n);
    return {
      call,
      to: BALANCER_RELAYER[input.callsAttributes[0].chainId],
      value: accumulatedValue,
      minBptOut
    };
  }
};

// src/entities/removeLiquidityNested/index.ts


// src/entities/removeLiquidityNested/doRemoveLiquidityNestedQuery.ts






var doRemoveLiquidityNestedQuery = async (chainId, rpcUrl, accountAddress, encodedMulticall, tokensOutLength) => {
  const client = _viem.createPublicClient.call(void 0, {
    transport: _viem.http.call(void 0, rpcUrl),
    chain: CHAINS[chainId]
  });
  const { data } = await client.call({
    account: accountAddress,
    to: BALANCER_RELAYER[chainId],
    data: encodedMulticall
  });
  const result = _viem.decodeFunctionResult.call(void 0, {
    abi: balancerRelayerAbi,
    functionName: "vaultActionsQueryMulticall",
    data
  });
  const resultsToPeek = result.slice(result.length - tokensOutLength);
  const peekedValues = resultsToPeek.map(
    (r) => _viem.decodeAbiParameters.call(void 0, [{ type: "uint256" }], r)[0]
  );
  return peekedValues;
};

// src/entities/removeLiquidityNested/getQueryCallsAttributes.ts
var getQueryCallsAttributes2 = (input, pools, isProportional) => {
  const {
    bptAmountIn,
    chainId,
    accountAddress,
    useNativeAssetAsWrappedAmountOut = false,
    toInternalBalance = false
  } = input;
  let callsAttributes;
  const poolsTopDown = pools.sort((a, b) => b.level - a.level);
  if (isProportional) {
    callsAttributes = getProportionalCallsAttributes(
      poolsTopDown,
      chainId,
      useNativeAssetAsWrappedAmountOut,
      accountAddress,
      bptAmountIn,
      toInternalBalance
    );
  } else {
    const { tokenOut } = input;
    callsAttributes = getSingleTokenCallsAttributes(
      poolsTopDown,
      chainId,
      useNativeAssetAsWrappedAmountOut,
      accountAddress,
      bptAmountIn,
      toInternalBalance,
      tokenOut
    );
  }
  const bptIn = new Token(chainId, poolsTopDown[0].address, 18);
  const _bptAmountIn = TokenAmount.fromRawAmount(bptIn, bptAmountIn);
  return { callsAttributes, bptAmountIn: _bptAmountIn };
};
var getProportionalCallsAttributes = (poolsSortedByLevel, chainId, useNativeAssetAsWrappedAmountOut, accountAddress, bptAmountIn, toInternalBalance) => {
  const calls = [];
  for (const pool of poolsSortedByLevel) {
    const sortedTokens = pool.tokens.sort((a, b) => a.index - b.index).map((t) => new Token(chainId, t.address, t.decimals));
    const sortedTokensWithoutBpt = sortedTokens.filter(
      (t) => !t.isSameAddress(pool.address)
    );
    calls.push({
      chainId,
      useNativeAssetAsWrappedAmountOut,
      sortedTokens,
      poolId: pool.id,
      poolAddress: pool.address,
      poolType: pool.type,
      kind: pool.type === "ComposableStable" /* ComposableStable */ ? 3 /* COMPOSABLE_STABLE_V2 */ : 0 /* WEIGHTED */,
      sender: getSenderProportional(calls, pool.address, accountAddress),
      recipient: getRecipientProportional(
        sortedTokensWithoutBpt,
        poolsSortedByLevel,
        accountAddress,
        chainId
      ),
      bptAmountIn: getBptAmountIn(pool, bptAmountIn, calls, true),
      minAmountsOut: Array(sortedTokens.length).fill(0n),
      // limits set to zero for query calls
      toInternalBalance,
      outputReferences: sortedTokensWithoutBpt.map((token) => {
        return {
          key: Relayer.toChainedReference(
            BigInt(poolsSortedByLevel.indexOf(pool)) * 10n + BigInt(sortedTokens.indexOf(token))
          ),
          index: BigInt(sortedTokens.indexOf(token))
        };
      })
    });
  }
  return calls;
};
var getSingleTokenCallsAttributes = (poolsTopDown, chainId, useNativeAssetAsWrappedAmountOut, accountAddress, bptAmountIn, toInternalBalance, tokenOut) => {
  const removeLiquidityPath = getRemoveLiquidityPath(
    tokenOut,
    poolsTopDown
  );
  const calls = [];
  for (let i = 0; i < removeLiquidityPath.length; i++) {
    const pool = removeLiquidityPath[i];
    const sortedTokens = pool.tokens.sort((a, b) => a.index - b.index).map((t) => new Token(chainId, t.address, t.decimals));
    const isLastCall = i === removeLiquidityPath.length - 1;
    const currenTokenOut = isLastCall ? tokenOut : removeLiquidityPath[i + 1].address;
    const tokenOutIndex = sortedTokens.findIndex(
      (t) => t.isSameAddress(currenTokenOut)
    );
    calls.push({
      chainId,
      useNativeAssetAsWrappedAmountOut,
      sortedTokens,
      poolId: pool.id,
      poolAddress: pool.address,
      poolType: pool.type,
      kind: pool.type === "ComposableStable" /* ComposableStable */ ? 3 /* COMPOSABLE_STABLE_V2 */ : 0 /* WEIGHTED */,
      sender: i === 0 ? accountAddress : BALANCER_RELAYER[chainId],
      recipient: isLastCall ? accountAddress : BALANCER_RELAYER[chainId],
      bptAmountIn: getBptAmountIn(pool, bptAmountIn, calls, false),
      minAmountsOut: Array(sortedTokens.length).fill(0n),
      // limits set to zero for query calls
      toInternalBalance,
      outputReferences: [
        {
          key: Relayer.toChainedReference(
            BigInt(removeLiquidityPath.indexOf(pool)) * 10n + BigInt(tokenOutIndex)
          ),
          index: BigInt(tokenOutIndex)
        }
      ],
      tokenOutIndex
    });
  }
  return calls;
};
var getRemoveLiquidityPath = (tokenOut, poolsTopDown) => {
  const topPool = poolsTopDown[0];
  const removeLiquidityPath = [];
  let tokenOutByLevel = tokenOut;
  while (tokenOutByLevel !== topPool.address) {
    const currentPool = poolsTopDown.find(
      (p) => (
        /**
         * Filter out pools that have tokenOutByLevel as it's own address
         * in order to prevent pools with BPT as token to be picked up
         * incorrectly - e.g. when removing liquidity from WETH/3-POOL to DAI, the
         * first iteration will pick 3-POOL as the "bottom" pool and update
         * tokenOutByLevel to 3-POOL-BPT. Since 3-POOL-BPT is contained
         * on both WETH/3-POOL and 3-POOL itself, simply checking if the
         * pool contains that token could result in the bottom pool being
         * picked up again.
         */
        p.address !== tokenOutByLevel && p.tokens.some((t) => t.address === tokenOutByLevel)
      )
    );
    removeLiquidityPath.unshift(currentPool);
    tokenOutByLevel = currentPool.address;
  }
  return removeLiquidityPath;
};
var getBptAmountIn = (pool, bptAmountIn, calls, isProportional) => {
  if (calls.length === 0) {
    return {
      amount: bptAmountIn,
      isRef: false
    };
  }
  let previousCall;
  let outputReferenceIndex;
  if (isProportional) {
    previousCall = calls.find(
      (call) => call.sortedTokens.map((token) => token.address).includes(pool.address)
    );
    outputReferenceIndex = previousCall.sortedTokens.map((token) => token.address).indexOf(pool.address);
  } else {
    previousCall = calls[calls.length - 1];
    outputReferenceIndex = 0;
  }
  return {
    amount: previousCall.outputReferences[outputReferenceIndex].key,
    isRef: true
  };
};
var getSenderProportional = (calls, poolAddress, accountAddress) => {
  const previousCall = calls.find(
    (_call) => _call.sortedTokens.map((token) => token.address).includes(poolAddress)
  );
  return previousCall !== void 0 ? previousCall.recipient : accountAddress;
};
var getRecipientProportional = (sortedTokensWithoutBpt, poolsSortedByLevel, accountAddress, chainId) => {
  const containsOutputToken = sortedTokensWithoutBpt.some(
    (token) => !poolsSortedByLevel.some(
      (_pool) => token.isSameAddress(_pool.address)
    )
  );
  return containsOutputToken ? accountAddress : BALANCER_RELAYER[chainId];
};

// src/entities/removeLiquidityNested/encodeCalls.ts

var encodeCalls2 = (callsAttributes, isProportional) => {
  const encodedCalls = [];
  for (const callAttributes of callsAttributes) {
    const {
      useNativeAssetAsWrappedAmountOut,
      chainId,
      sortedTokens,
      poolId,
      poolType,
      kind,
      sender,
      recipient,
      bptAmountIn,
      minAmountsOut,
      toInternalBalance,
      outputReferences,
      tokenOutIndex
    } = callAttributes;
    let tokensOut = [...sortedTokens];
    if (useNativeAssetAsWrappedAmountOut) {
      tokensOut = replaceWrapped([...sortedTokens], chainId);
    }
    let userData;
    if (isProportional) {
      userData = getUserDataProportional(poolType, bptAmountIn.amount);
    } else {
      userData = getUserDataSingleToken(
        tokenOutIndex,
        poolType,
        bptAmountIn.amount
      );
    }
    const exitPoolRequest = {
      assets: tokensOut.map((t) => t.address),
      // with BPT
      minAmountsOut,
      // with BPT
      userData,
      // wihtout BPT
      toInternalBalance
    };
    const encodedCall = _viem.encodeFunctionData.call(void 0, {
      abi: batchRelayerLibraryAbi,
      functionName: "exitPool",
      args: [
        poolId,
        kind,
        sender,
        recipient,
        exitPoolRequest,
        outputReferences
      ]
    });
    encodedCalls.push(encodedCall);
  }
  return encodedCalls;
};
var getUserDataProportional = (poolType, bptAmountIn) => {
  switch (poolType) {
    case "Weighted" /* Weighted */:
      return WeightedEncoder.removeLiquidityProportional(bptAmountIn);
    case "ComposableStable" /* ComposableStable */:
      return ComposableStableEncoder.removeLiquidityProportional(
        bptAmountIn
      );
    default:
      throw new Error(`Unsupported pool type ${poolType}`);
  }
};
var getUserDataSingleToken = (tokenOutIndex, poolType, bptAmountIn) => {
  if (tokenOutIndex === void 0) {
    throw new Error(
      "tokenOutIndex can't be undefined for removing liquidity to single token"
    );
  }
  switch (poolType) {
    case "Weighted" /* Weighted */:
      return WeightedEncoder.removeLiquiditySingleToken(
        bptAmountIn,
        tokenOutIndex
      );
    case "ComposableStable" /* ComposableStable */:
      return ComposableStableEncoder.removeLiquiditySingleToken(
        bptAmountIn,
        tokenOutIndex
      );
    default:
      throw new Error(`Unsupported pool type ${poolType}`);
  }
};

// src/entities/removeLiquidityNested/getPeekCalls.ts
var getPeekCalls = (calls, isProportional) => {
  const tokensOut = [];
  const peekCalls = [];
  if (isProportional) {
    calls.forEach((call) => {
      call.outputReferences.forEach((outputReference) => {
        const tokenOut = call.sortedTokens[Number(outputReference.index)];
        const isTokenBeingUsedAsInput = calls.some(
          (_call) => tokenOut.isSameAddress(_call.poolAddress)
        );
        if (!isTokenBeingUsedAsInput) {
          tokensOut.push(tokenOut);
          peekCalls.push(
            Relayer.encodePeekChainedReferenceValue(
              outputReference.key
            )
          );
        }
      });
    });
  } else {
    const lastCall = calls[calls.length - 1];
    const tokenOut = lastCall.sortedTokens[lastCall.tokenOutIndex];
    tokensOut.push(tokenOut);
    peekCalls.push(
      Relayer.encodePeekChainedReferenceValue(
        lastCall.outputReferences[0].key
      )
    );
  }
  return { peekCalls, tokensOut };
};

// src/entities/removeLiquidityNested/validateInputs.ts
var validateInputs2 = (input, nestedPoolState) => {
  constraintValidation(nestedPoolState);
  const tokenOut = "tokenOut" in input ? input.tokenOut : void 0;
  const isProportional = tokenOut === void 0;
  const mainTokens = nestedPoolState.mainTokens.map(
    (token) => new Token(input.chainId, token.address, token.decimals)
  );
  if (isProportional) {
    validateInputsProportional(
      input,
      mainTokens
    );
  } else {
    validateInputsSingleToken(
      input,
      mainTokens
    );
  }
  return isProportional;
};
var validateInputsProportional = (input, mainTokens) => {
  if (input.useNativeAssetAsWrappedAmountOut && !mainTokens.some(
    (t) => t.isUnderlyingEqual(NATIVE_ASSETS[input.chainId])
  )) {
    throw new Error(
      "Removing liquidity to native asset requires wrapped native asset to exist within main tokens"
    );
  }
};
var validateInputsSingleToken = (input, mainTokens) => {
  const tokenOut = mainTokens.find((t) => t.isSameAddress(input.tokenOut));
  if (tokenOut === void 0) {
    throw new Error(
      `Removing liquidity to ${input.tokenOut} requires it to exist within main tokens`
    );
  }
  if (input.useNativeAssetAsWrappedAmountOut && !tokenOut.isUnderlyingEqual(NATIVE_ASSETS[input.chainId])) {
    throw new Error(
      "Removing liquidity to native asset requires wrapped native asset to be the tokenOut"
    );
  }
};

// src/entities/removeLiquidityNested/index.ts
var RemoveLiquidityNested = class {
  async query(input, nestedPoolState) {
    const isProportional = validateInputs2(input, nestedPoolState);
    const { callsAttributes, bptAmountIn } = getQueryCallsAttributes2(
      input,
      nestedPoolState.pools,
      isProportional
    );
    const encodedCalls = encodeCalls2(callsAttributes, isProportional);
    const { peekCalls, tokensOut } = getPeekCalls(
      callsAttributes,
      isProportional
    );
    encodedCalls.push(...peekCalls);
    const encodedMulticall = _viem.encodeFunctionData.call(void 0, {
      abi: balancerRelayerAbi,
      functionName: "vaultActionsQueryMulticall",
      args: [encodedCalls]
    });
    const peekedValues = await doRemoveLiquidityNestedQuery(
      input.chainId,
      input.rpcUrl,
      input.accountAddress,
      encodedMulticall,
      tokensOut.length
    );
    console.log("peekedValues ", peekedValues);
    const amountsOut = tokensOut.map(
      (tokenOut, i) => TokenAmount.fromRawAmount(tokenOut, peekedValues[i])
    );
    return { callsAttributes, bptAmountIn, amountsOut, isProportional };
  }
  buildCall(input) {
    const minAmountsOut = input.amountsOut.map(
      (amountOut) => TokenAmount.fromRawAmount(
        amountOut.token,
        input.slippage.removeFrom(amountOut.amount)
      )
    );
    input.callsAttributes.forEach((call2) => {
      minAmountsOut.forEach((minAmountOut, j) => {
        const minAmountOutIndex = call2.sortedTokens.findIndex(
          (t) => t.isSameAddress(minAmountOut.token.address)
        );
        if (minAmountOutIndex !== -1) {
          call2.minAmountsOut[minAmountOutIndex] = minAmountsOut[j].amount;
        }
      });
    });
    const encodedCalls = encodeCalls2(
      input.callsAttributes,
      input.isProportional
    );
    if (input.relayerApprovalSignature !== void 0) {
      encodedCalls.unshift(
        Relayer.encodeSetRelayerApproval(
          BALANCER_RELAYER[input.callsAttributes[0].chainId],
          true,
          input.relayerApprovalSignature
        )
      );
    }
    const call = _viem.encodeFunctionData.call(void 0, {
      abi: balancerRelayerAbi,
      functionName: "multicall",
      args: [encodedCalls]
    });
    return {
      call,
      to: BALANCER_RELAYER[input.callsAttributes[0].chainId],
      minAmountsOut
    };
  }
};

// src/entities/addLiquidity/addLiquidityV2/composableStable/addLiquidityComposableStable.ts

var AddLiquidityComposableStable = class {
  async query(input, poolState) {
    const sortedTokens = getSortedTokens(poolState.tokens, input.chainId);
    const bptIndex = sortedTokens.findIndex(
      (t) => t.address === poolState.address
    );
    const amounts = this.getAmountsQuery(sortedTokens, input, bptIndex);
    const userData = ComposableStableEncoder.encodeAddLiquidityUserData(
      input.kind,
      amounts
    );
    const { args, tokensIn } = parseAddLiquidityArgs({
      useNativeAssetAsWrappedAmountIn: !!input.useNativeAssetAsWrappedAmountIn,
      chainId: input.chainId,
      sortedTokens,
      poolId: poolState.id,
      sender: ZERO_ADDRESS,
      recipient: ZERO_ADDRESS,
      maxAmountsIn: amounts.maxAmountsIn,
      userData,
      fromInternalBalance: _nullishCoalesce(input.fromInternalBalance, () => ( false))
    });
    const queryOutput = await doAddLiquidityQuery(
      input.rpcUrl,
      input.chainId,
      args
    );
    const bpt = new Token(input.chainId, poolState.address, 18);
    const bptOut = TokenAmount.fromRawAmount(bpt, queryOutput.bptOut);
    const amountsIn = queryOutput.amountsIn.map(
      (a, i) => TokenAmount.fromRawAmount(tokensIn[i], a)
    );
    return {
      poolType: poolState.type,
      addLiquidityKind: input.kind,
      poolId: poolState.id,
      bptOut,
      amountsIn,
      tokenInIndex: amounts.tokenInIndex,
      fromInternalBalance: !!input.fromInternalBalance,
      bptIndex,
      balancerVersion: 2
    };
  }
  buildCall(input) {
    const amounts = this.getAmountsCall(input);
    const userData = ComposableStableEncoder.encodeAddLiquidityUserData(
      input.addLiquidityKind,
      amounts
    );
    const { args } = parseAddLiquidityArgs({
      ...input,
      sortedTokens: input.amountsIn.map((a) => a.token),
      maxAmountsIn: amounts.maxAmountsIn,
      userData,
      fromInternalBalance: input.fromInternalBalance
    });
    const call = _viem.encodeFunctionData.call(void 0, {
      abi: vaultAbi,
      functionName: "joinPool",
      args
    });
    const value = _optionalChain([input, 'access', _29 => _29.amountsIn, 'access', _30 => _30.find, 'call', _31 => _31(
      (a) => a.token.address === ZERO_ADDRESS
    ), 'optionalAccess', _32 => _32.amount]);
    return {
      call,
      to: BALANCER_VAULT,
      value: value === void 0 ? 0n : value,
      minBptOut: TokenAmount.fromRawAmount(
        input.bptOut.token,
        amounts.minimumBpt
      ),
      maxAmountsIn: input.amountsIn.map(
        (a, i) => TokenAmount.fromRawAmount(a.token, amounts.maxAmountsIn[i])
      )
    };
  }
  getAmountsQuery(poolTokens, input, bptIndex) {
    let addLiquidityAmounts;
    switch (input.kind) {
      case "Unbalanced" /* Unbalanced */: {
        addLiquidityAmounts = {
          minimumBpt: 0n,
          maxAmountsIn: getAmounts(
            poolTokens,
            input.amountsIn,
            BigInt(0)
          ),
          tokenInIndex: void 0
        };
        break;
      }
      case "SingleToken" /* SingleToken */: {
        const tokenInIndex = poolTokens.filter((_, index) => index !== bptIndex).findIndex((t) => t.isSameAddress(input.tokenIn));
        if (tokenInIndex === -1)
          throw Error("Can't find index of SingleToken");
        const maxAmountsIn = Array(poolTokens.length).fill(0n);
        maxAmountsIn[tokenInIndex] = MAX_UINT256;
        addLiquidityAmounts = {
          minimumBpt: input.bptOut.rawAmount,
          maxAmountsIn,
          tokenInIndex
        };
        break;
      }
      case "Proportional" /* Proportional */: {
        addLiquidityAmounts = {
          minimumBpt: input.bptOut.rawAmount,
          maxAmountsIn: Array(poolTokens.length).fill(MAX_UINT256),
          tokenInIndex: void 0
        };
        break;
      }
    }
    return {
      ...addLiquidityAmounts,
      maxAmountsInWithoutBpt: [
        ...addLiquidityAmounts.maxAmountsIn.slice(0, bptIndex),
        ...addLiquidityAmounts.maxAmountsIn.slice(bptIndex + 1)
      ]
    };
  }
  getAmountsCall(input) {
    let addLiquidityAmounts;
    switch (input.addLiquidityKind) {
      case "Init" /* Init */:
        throw Error(
          "Unsupported Add Liquidity Kind, for Init use InitPool instead of AddLiquidity"
        );
      case "Unbalanced" /* Unbalanced */: {
        const minimumBpt = input.slippage.removeFrom(
          input.bptOut.amount
        );
        addLiquidityAmounts = {
          minimumBpt,
          maxAmountsIn: input.amountsIn.map((a) => a.amount),
          tokenInIndex: input.tokenInIndex
        };
        break;
      }
      case "SingleToken" /* SingleToken */:
      case "Proportional" /* Proportional */: {
        addLiquidityAmounts = {
          minimumBpt: input.bptOut.amount,
          maxAmountsIn: input.amountsIn.map(
            (a) => input.slippage.applyTo(a.amount)
          ),
          tokenInIndex: input.tokenInIndex
        };
        break;
      }
      default:
        throw Error("Unsupported Add Liquidity Kind");
    }
    return {
      ...addLiquidityAmounts,
      maxAmountsInWithoutBpt: [
        ...addLiquidityAmounts.maxAmountsIn.slice(0, input.bptIndex),
        ...addLiquidityAmounts.maxAmountsIn.slice(input.bptIndex + 1)
      ]
    };
  }
};

// src/entities/addLiquidity/addLiquidityV2/weighted/addLiquidityWeighted.ts

var AddLiquidityWeighted = class {
  async query(input, poolState) {
    const sortedTokens = getSortedTokens(poolState.tokens, input.chainId);
    const amounts = this.getAmountsQuery(sortedTokens, input);
    const userData = WeightedEncoder.encodeAddLiquidityUserData(
      input.kind,
      amounts
    );
    const { args, tokensIn } = parseAddLiquidityArgs({
      useNativeAssetAsWrappedAmountIn: !!input.useNativeAssetAsWrappedAmountIn,
      chainId: input.chainId,
      sortedTokens,
      poolId: poolState.id,
      sender: ZERO_ADDRESS,
      recipient: ZERO_ADDRESS,
      maxAmountsIn: amounts.maxAmountsIn,
      userData,
      fromInternalBalance: _nullishCoalesce(input.fromInternalBalance, () => ( false))
    });
    const queryOutput = await doAddLiquidityQuery(
      input.rpcUrl,
      input.chainId,
      args
    );
    const bpt = new Token(input.chainId, poolState.address, 18);
    const bptOut = TokenAmount.fromRawAmount(bpt, queryOutput.bptOut);
    const amountsIn = queryOutput.amountsIn.map(
      (a, i) => TokenAmount.fromRawAmount(tokensIn[i], a)
    );
    return {
      poolType: poolState.type,
      addLiquidityKind: input.kind,
      poolId: poolState.id,
      bptOut,
      amountsIn,
      tokenInIndex: amounts.tokenInIndex,
      fromInternalBalance: !!input.fromInternalBalance,
      balancerVersion: 2
    };
  }
  buildCall(input) {
    const amounts = this.getAmountsCall(input);
    const userData = WeightedEncoder.encodeAddLiquidityUserData(
      input.addLiquidityKind,
      amounts
    );
    const { args } = parseAddLiquidityArgs({
      ...input,
      sortedTokens: input.amountsIn.map((a) => a.token),
      maxAmountsIn: amounts.maxAmountsIn,
      userData,
      fromInternalBalance: input.fromInternalBalance
    });
    const call = _viem.encodeFunctionData.call(void 0, {
      abi: vaultAbi,
      functionName: "joinPool",
      args
    });
    const value = _optionalChain([input, 'access', _33 => _33.amountsIn, 'access', _34 => _34.find, 'call', _35 => _35(
      (a) => a.token.address === ZERO_ADDRESS
    ), 'optionalAccess', _36 => _36.amount]);
    return {
      call,
      to: BALANCER_VAULT,
      value: value === void 0 ? 0n : value,
      minBptOut: TokenAmount.fromRawAmount(
        input.bptOut.token,
        amounts.minimumBpt
      ),
      maxAmountsIn: input.amountsIn.map(
        (a, i) => TokenAmount.fromRawAmount(a.token, amounts.maxAmountsIn[i])
      )
    };
  }
  getAmountsQuery(poolTokens, input) {
    switch (input.kind) {
      case "Unbalanced" /* Unbalanced */: {
        return {
          minimumBpt: 0n,
          maxAmountsIn: getAmounts(poolTokens, input.amountsIn),
          tokenInIndex: void 0
        };
      }
      case "SingleToken" /* SingleToken */: {
        const tokenInIndex = poolTokens.findIndex(
          (t) => t.isSameAddress(input.tokenIn)
        );
        if (tokenInIndex === -1)
          throw Error("Can't find index of SingleToken");
        const maxAmountsIn = Array(poolTokens.length).fill(0n);
        maxAmountsIn[tokenInIndex] = MAX_UINT256;
        return {
          minimumBpt: input.bptOut.rawAmount,
          maxAmountsIn,
          tokenInIndex
        };
      }
      case "Proportional" /* Proportional */: {
        return {
          minimumBpt: input.bptOut.rawAmount,
          maxAmountsIn: Array(poolTokens.length).fill(MAX_UINT256),
          tokenInIndex: void 0
        };
      }
    }
  }
  getAmountsCall(input) {
    switch (input.addLiquidityKind) {
      case "Init" /* Init */:
        throw Error("Unsupported Add Liquidity Kind");
      case "Unbalanced" /* Unbalanced */: {
        const minimumBpt = input.slippage.removeFrom(
          input.bptOut.amount
        );
        return {
          minimumBpt,
          maxAmountsIn: input.amountsIn.map((a) => a.amount),
          tokenInIndex: input.tokenInIndex
        };
      }
      case "SingleToken" /* SingleToken */:
      case "Proportional" /* Proportional */: {
        return {
          minimumBpt: input.bptOut.amount,
          maxAmountsIn: input.amountsIn.map(
            (a) => input.slippage.applyTo(a.amount)
          ),
          tokenInIndex: input.tokenInIndex
        };
      }
      default:
        throw Error("Unsupported Add Liquidity Kind");
    }
  }
};

// src/entities/addLiquidity/addLiquidityV2/index.ts
var AddLiquidityV2 = class {
  constructor(config) {
    __publicField(this, "addLiquidityTypes", {});
    const { customAddLiquidityTypes } = config || {};
    this.addLiquidityTypes = {
      //GYRO2, GYRO3, GYROE pool types only support Add Liquidity Proportional (3 - ALL_TOKENS_IN_FOR_BPT_OUT)
      ["Gyro2" /* Gyro2 */]: new AddLiquidityWeighted(),
      ["Gyro3" /* Gyro3 */]: new AddLiquidityWeighted(),
      ["GyroE" /* GyroE */]: new AddLiquidityWeighted(),
      ["Weighted" /* Weighted */]: new AddLiquidityWeighted(),
      ["ComposableStable" /* ComposableStable */]: new AddLiquidityComposableStable(),
      // custom add liquidity types take precedence over base types
      ...customAddLiquidityTypes
    };
  }
  getAddLiquidity(poolType) {
    if (!this.addLiquidityTypes[poolType]) {
      throw new Error("Unsupported pool type");
    }
    return this.addLiquidityTypes[poolType];
  }
  async query(input, poolState) {
    return this.getAddLiquidity(poolState.type).query(input, poolState);
  }
  buildCall(input) {
    return this.getAddLiquidity(input.poolType).buildCall(input);
  }
};

// src/entities/addLiquidity/addLiquidityV3.ts
var AddLiquidityV3 = class {
  query(input, poolState) {
    console.log(input, poolState);
    throw new Error("Method not implemented.");
  }
  buildCall(input) {
    console.log(input);
    throw new Error("Method not implemented.");
  }
};

// src/entities/utils/areTokensInArray.ts
function areTokensInArray(tokens, tokenArray) {
  const sanitisedTokens = tokens.map((t) => t.toLowerCase());
  const sanitisedTokenArray = tokenArray.map((t) => t.toLowerCase());
  for (const token of sanitisedTokens) {
    if (!sanitisedTokenArray.includes(token)) {
      throw new Error(`Token ${token} not found in array`);
    }
  }
}

// src/entities/inputValidator/utils/validateTokens.ts
var validateTokensAddLiquidity = (addLiquidityInput, poolState) => {
  switch (addLiquidityInput.kind) {
    case "Unbalanced" /* Unbalanced */:
      areTokensInArray(
        addLiquidityInput.amountsIn.map((a) => a.address),
        poolState.tokens.map((t) => t.address)
      );
      break;
    case "SingleToken" /* SingleToken */:
      areTokensInArray(
        [addLiquidityInput.tokenIn],
        poolState.tokens.map((t) => t.address)
      );
      break;
    case "Proportional" /* Proportional */:
      areTokensInArray(
        [addLiquidityInput.bptOut.address],
        [poolState.address]
      );
      break;
    default:
      break;
  }
};
var validateTokensRemoveLiquidity = (removeLiquidityInput, poolState) => {
  switch (removeLiquidityInput.kind) {
    case "Unbalanced" /* Unbalanced */:
      areTokensInArray(
        removeLiquidityInput.amountsOut.map((a) => a.address),
        poolState.tokens.map((t) => t.address)
      );
      break;
    case "SingleToken" /* SingleToken */:
      areTokensInArray(
        [removeLiquidityInput.tokenOut],
        poolState.tokens.map((t) => t.address)
      );
      break;
    case "Proportional" /* Proportional */:
      areTokensInArray(
        [removeLiquidityInput.bptIn.address],
        [poolState.address]
      );
      break;
    default:
      break;
  }
};
var validatePoolHasBpt = (poolState) => {
  const { tokens, address } = poolState;
  const bptIndex = tokens.findIndex((t) => t.address === address);
  if (bptIndex < 0) {
    throw new Error(
      "INPUT_ERROR: Pool State should have BPT token included"
    );
  }
};
var validateCreatePoolTokens = (tokens) => {
  const tokenAddresses = tokens.map((t) => t.tokenAddress);
  if (tokenAddresses.length !== new Set(tokenAddresses).size) {
    throw new Error("Duplicate token addresses");
  }
  if (tokens.length < 2) {
    throw new Error("Minimum of 2 tokens required");
  }
};

// src/entities/inputValidator/composableStable/inputValidatorComposableStable.ts
var InputValidatorComposableStable = class {
  validateAddLiquidity(addLiquidityInput, poolState) {
    validatePoolHasBpt(poolState);
    validateTokensAddLiquidity(addLiquidityInput, poolState);
  }
  validateRemoveLiquidity(input, poolState) {
    validatePoolHasBpt(poolState);
    validateTokensRemoveLiquidity(input, poolState);
  }
  validateCreatePool(input) {
    validateCreatePoolTokens(input.tokens);
    if (input.tokens.length > 5) {
      throw new Error(
        "Composable stable pools can have a maximum of 5 tokens"
      );
    }
    if (input.amplificationParameter <= BigInt(0)) {
      throw new Error("Amplification parameter must be greater than 0");
    }
    if (input.amplificationParameter > BigInt(5e3)) {
      throw new Error(
        "Amplification parameter must be equal or lower than 5000"
      );
    }
    return;
  }
};

// src/entities/inputValidator/gyro/inputValidatorGyro.ts
var _InputValidatorGyro = class {
  validateAddLiquidity(addLiquidityInput, poolState) {
    if (addLiquidityInput.kind !== "Proportional" /* Proportional */) {
      throw new Error(
        _InputValidatorGyro.addLiquidityKindNotSupportedByGyro
      );
    }
    validateTokensAddLiquidity(addLiquidityInput, poolState);
  }
  validateRemoveLiquidity(removeLiquidityInput, poolState) {
    if (removeLiquidityInput.kind !== "Proportional" /* Proportional */) {
      throw new Error(
        _InputValidatorGyro.removeLiquidityKindNotSupportedByGyro
      );
    }
    validateTokensRemoveLiquidity(removeLiquidityInput, poolState);
  }
  validateCreatePool(input) {
    console.log(input);
    throw new Error("Method not implemented.");
  }
};
var InputValidatorGyro = _InputValidatorGyro;
__publicField(InputValidatorGyro, "addLiquidityKindNotSupportedByGyro", "INPUT_ERROR: Gyro pools do not implement this add liquidity kind, only Add Liquidity Proportional (3 - ALL_TOKENS_IN_FOR_BPT_OUT) is supported");
__publicField(InputValidatorGyro, "removeLiquidityKindNotSupportedByGyro", "INPUT_ERROR: Gyro pools do not implement this remove liquidity kind, only Remove Liquidity Proportional (1 - EXACT_BPT_IN_FOR_TOKENS_OUT) is supported");

// src/entities/inputValidator/weighted/inputValidatorWeighted.ts
var InputValidatorWeighted = class {
  validateCreatePool(input) {
    validateCreatePoolTokens(input.tokens);
    if (input.tokens.length > 8) {
      throw new Error("Weighted pools can have a maximum of 8 tokens");
    }
    const weightsSum = input.tokens.reduce(
      (acc, { weight }) => acc + weight,
      0n
    );
    if (weightsSum !== BigInt(1e18)) {
      throw new Error("Weights must sum to 1e18");
    }
    if (input.tokens.find(({ weight }) => weight === 0n)) {
      throw new Error("Weight cannot be 0");
    }
  }
  validateAddLiquidity(addLiquidityInput, poolState) {
    validateTokensAddLiquidity(addLiquidityInput, poolState);
  }
  validateRemoveLiquidity(input, poolState) {
    validateTokensRemoveLiquidity(input, poolState);
  }
};

// src/entities/inputValidator/inputValidator.ts
var InputValidator = class {
  constructor() {
    __publicField(this, "validators", {});
    this.validators = {
      ["Weighted" /* Weighted */]: new InputValidatorWeighted(),
      ["Gyro2" /* Gyro2 */]: new InputValidatorGyro(),
      ["Gyro3" /* Gyro3 */]: new InputValidatorGyro(),
      ["GyroE" /* GyroE */]: new InputValidatorGyro(),
      ["ComposableStable" /* ComposableStable */]: new InputValidatorComposableStable()
    };
  }
  getValidator(poolType) {
    if (!this.validators[poolType])
      throw new Error("This Pool type does not have a validator");
    return this.validators[poolType];
  }
  validateAddLiquidity(addLiquidityInput, poolState) {
    this.getValidator(poolState.type).validateAddLiquidity(
      addLiquidityInput,
      poolState
    );
  }
  validateRemoveLiquidity(removeLiquidityInput, poolState) {
    this.getValidator(poolState.type).validateRemoveLiquidity(
      removeLiquidityInput,
      poolState
    );
  }
  validateCreatePool(input) {
    this.getValidator(input.poolType).validateCreatePool(input);
  }
};

// src/entities/addLiquidity/index.ts
var AddLiquidity = class {
  constructor(config) {
    this.config = config;
    __publicField(this, "inputValidator", new InputValidator());
  }
  query(input, poolState) {
    this.inputValidator.validateAddLiquidity(input, poolState);
    switch (poolState.balancerVersion) {
      case 2: {
        const addLiquidity = new AddLiquidityV2(this.config);
        return addLiquidity.query(input, poolState);
      }
      case 3: {
        const addLiquidity = new AddLiquidityV3();
        return addLiquidity.query(input, poolState);
      }
    }
  }
  buildCall(input) {
    switch (input.balancerVersion) {
      case 2: {
        const addLiquidity = new AddLiquidityV2(this.config);
        return addLiquidity.buildCall(input);
      }
      case 3: {
        const addLiquidity = new AddLiquidityV3();
        return addLiquidity.buildCall(input);
      }
    }
  }
};

// src/entities/createPool/createPoolV2/composableStable/createPoolComposableStable.ts


// src/abi/composableStableFactoryV5.ts
var composableStableFactoryV5Abi = [
  {
    inputs: [
      { internalType: "contract IVault", name: "vault", type: "address" },
      {
        internalType: "contract IProtocolFeePercentagesProvider",
        name: "protocolFeeProvider",
        type: "address"
      },
      { internalType: "string", name: "factoryVersion", type: "string" },
      { internalType: "string", name: "poolVersion", type: "string" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  { anonymous: false, inputs: [], name: "FactoryDisabled", type: "event" },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "pool",
        type: "address"
      }
    ],
    name: "PoolCreated",
    type: "event"
  },
  {
    inputs: [
      { internalType: "string", name: "name", type: "string" },
      { internalType: "string", name: "symbol", type: "string" },
      {
        internalType: "contract IERC20[]",
        name: "tokens",
        type: "address[]"
      },
      {
        internalType: "uint256",
        name: "amplificationParameter",
        type: "uint256"
      },
      {
        internalType: "contract IRateProvider[]",
        name: "rateProviders",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "tokenRateCacheDurations",
        type: "uint256[]"
      },
      {
        internalType: "bool",
        name: "exemptFromYieldProtocolFeeFlag",
        type: "bool"
      },
      {
        internalType: "uint256",
        name: "swapFeePercentage",
        type: "uint256"
      },
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bytes32", name: "salt", type: "bytes32" }
    ],
    name: "create",
    outputs: [
      {
        internalType: "contract ComposableStablePool",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "disable",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "selector", type: "bytes4" }],
    name: "getActionId",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getAuthorizer",
    outputs: [
      { internalType: "contract IAuthorizer", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCreationCode",
    outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCreationCodeContracts",
    outputs: [
      { internalType: "address", name: "contractA", type: "address" },
      { internalType: "address", name: "contractB", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPauseConfiguration",
    outputs: [
      {
        internalType: "uint256",
        name: "pauseWindowDuration",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "bufferPeriodDuration",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPoolVersion",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getProtocolFeePercentagesProvider",
    outputs: [
      {
        internalType: "contract IProtocolFeePercentagesProvider",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getVault",
    outputs: [
      { internalType: "contract IVault", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "isDisabled",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "pool", type: "address" }],
    name: "isPoolFromFactory",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "version",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  }
];

// src/entities/utils/getRandomBytes32.ts
var getRandomBytes32 = () => {
  const getRandomBytes8 = () => Math.random().toString(16).slice(2, 10);
  const randomBytes32 = Array(8).fill(null).map(getRandomBytes8).join("");
  return `0x${randomBytes32}`;
};

// src/entities/createPool/createPoolV2/composableStable/createPoolComposableStable.ts
var CreatePoolComposableStable = class {
  buildCall(input) {
    const args = this.parseCreateFunctionArgs(input);
    const encodedCall = _viem.encodeFunctionData.call(void 0, {
      abi: composableStableFactoryV5Abi,
      functionName: "create",
      args
    });
    return { call: encodedCall };
  }
  parseCreateFunctionArgs(input) {
    const sortedTokenParams = input.tokens.sort(
      ({ tokenAddress: address1 }, { tokenAddress: address2 }) => {
        const diff = BigInt(address1) - BigInt(address2);
        return diff > 0 ? 1 : diff < 0 ? -1 : 0;
      }
    );
    const [tokens, rateProviders, tokenRateCacheDurations] = sortedTokenParams.reduce(
      (acc, curr) => {
        acc[0].push(curr.tokenAddress);
        acc[1].push(curr.rateProvider);
        acc[2].push(curr.tokenRateCacheDuration);
        return acc;
      },
      [[], [], []]
    );
    return [
      input.name || input.symbol,
      input.symbol,
      tokens,
      input.amplificationParameter,
      rateProviders,
      tokenRateCacheDurations,
      input.exemptFromYieldProtocolFeeFlag,
      _viem.parseEther.call(void 0, input.swapFee),
      input.poolOwnerAddress,
      input.salt || getRandomBytes32()
    ];
  }
};

// src/entities/createPool/createPoolV2/weighted/createPoolWeighted.ts

var CreatePoolWeighted = class {
  buildCall(input) {
    const args = this.parseCreateFunctionArgs(input);
    const encodedCall = _viem.encodeFunctionData.call(void 0, {
      abi: weightedFactoryV4Abi,
      functionName: "create",
      args
    });
    return { call: encodedCall };
  }
  parseCreateFunctionArgs(input) {
    const sortedTokenParams = input.tokens.sort(
      ({ tokenAddress: address1 }, { tokenAddress: address2 }) => {
        const diff = BigInt(address1) - BigInt(address2);
        return diff > 0 ? 1 : diff < 0 ? -1 : 0;
      }
    );
    const [tokens, weights, rateProviders] = sortedTokenParams.reduce(
      (acc, curr) => {
        acc[0].push(curr.tokenAddress);
        acc[1].push(curr.weight);
        acc[2].push(curr.rateProvider);
        return acc;
      },
      [[], [], []]
    );
    return [
      input.name || input.symbol,
      input.symbol,
      tokens,
      weights,
      rateProviders,
      _viem.parseEther.call(void 0, input.swapFee),
      input.poolOwnerAddress,
      input.salt || getRandomBytes32()
    ];
  }
};

// src/entities/createPool/createPoolV2/index.ts
var CreatePoolV2 = class {
  constructor() {
    // TODO: should we allow for custom create pool types?
    __publicField(this, "createPoolTypes", {});
    this.createPoolTypes = {
      ["Weighted" /* Weighted */]: new CreatePoolWeighted(),
      ["ComposableStable" /* ComposableStable */]: new CreatePoolComposableStable()
    };
  }
  getCreatePool(poolType) {
    if (!this.createPoolTypes[poolType]) {
      throw new Error("Unsupported pool type: ${poolType}");
    }
    return this.createPoolTypes[poolType];
  }
  buildCall(input) {
    return this.getCreatePool(input.poolType).buildCall(input);
  }
};

// src/entities/createPool/createPoolV3.ts
var CreatePoolV3 = class {
  buildCall(input) {
    console.log(input);
    throw new Error("Method not implemented.");
  }
};

// src/entities/createPool/index.ts
var CreatePool = class {
  constructor() {
    __publicField(this, "inputValidator");
    this.inputValidator = new InputValidator();
  }
  buildCall(input) {
    this.inputValidator.validateCreatePool(input);
    switch (input.balancerVersion) {
      case 2:
        return new CreatePoolV2().buildCall(input);
      case 3:
        return new CreatePoolV3().buildCall(input);
    }
  }
};

// src/entities/initPool/initPoolV2/composableStable/initPoolComposableStable.ts

var InitPoolComposableStable = class {
  buildCall(input, poolState) {
    const sortedTokens = getSortedTokens(poolState.tokens, input.chainId);
    const amounts = this.getAmounts(input, poolState.address, sortedTokens);
    const userData = ComposableStableEncoder.encodeInitPoolUserData(amounts);
    const { args } = parseAddLiquidityArgs({
      ...input,
      poolId: poolState.id,
      sortedTokens,
      maxAmountsIn: amounts.maxAmountsIn,
      userData,
      fromInternalBalance: _nullishCoalesce(input.fromInternalBalance, () => ( false))
    });
    const call = _viem.encodeFunctionData.call(void 0, {
      abi: vaultAbi,
      functionName: "joinPool",
      args
    });
    const value = _optionalChain([input, 'access', _37 => _37.amountsIn, 'access', _38 => _38.find, 'call', _39 => _39(
      (a) => a.address === ZERO_ADDRESS
    ), 'optionalAccess', _40 => _40.rawAmount]);
    return {
      call,
      to: BALANCER_VAULT,
      value: value === void 0 ? 0n : value
    };
  }
  getAmounts(input, poolAddress, poolTokens) {
    const bptIndex = poolTokens.findIndex((t) => t.address === poolAddress);
    const maxAmountsIn = getAmounts(poolTokens, [
      ...input.amountsIn.slice(0, bptIndex),
      {
        address: poolAddress,
        decimals: 18,
        rawAmount: MAX_UINT256
      },
      ...input.amountsIn.slice(bptIndex)
    ]);
    const amountsIn = getAmounts(poolTokens, [
      ...input.amountsIn.slice(0, bptIndex),
      {
        address: poolAddress,
        decimals: 18,
        rawAmount: BigInt(0)
      },
      ...input.amountsIn.slice(bptIndex)
    ]);
    return {
      maxAmountsIn,
      amountsIn
    };
  }
};

// src/entities/initPool/initPoolV2/weighted/initPoolWeighted.ts

var InitPoolWeighted = class {
  buildCall(input, poolState) {
    const sortedTokens = getSortedTokens(poolState.tokens, input.chainId);
    const amounts = this.getAmounts(input, sortedTokens);
    const userData = WeightedEncoder.encodeInitPoolUserData(amounts);
    const { args } = parseAddLiquidityArgs({
      ...input,
      poolId: poolState.id,
      sortedTokens,
      maxAmountsIn: amounts.maxAmountsIn,
      userData,
      fromInternalBalance: _nullishCoalesce(input.fromInternalBalance, () => ( false))
    });
    const call = _viem.encodeFunctionData.call(void 0, {
      abi: vaultAbi,
      functionName: "joinPool",
      args
    });
    const value = _optionalChain([input, 'access', _41 => _41.amountsIn, 'access', _42 => _42.find, 'call', _43 => _43(
      (a) => a.address === ZERO_ADDRESS
    ), 'optionalAccess', _44 => _44.rawAmount]);
    return {
      call,
      to: BALANCER_VAULT,
      value: value === void 0 ? 0n : value
    };
  }
  getAmounts(input, poolTokens) {
    return {
      maxAmountsIn: getAmounts(poolTokens, input.amountsIn)
    };
  }
};

// src/entities/initPool/initPoolV2/index.ts
var InitPoolV2 = class {
  constructor(config) {
    __publicField(this, "initPoolTypes", {});
    const { initPoolTypes: customAddLiquidityInitTypes } = config || {};
    this.initPoolTypes = {
      ["Weighted" /* Weighted */]: new InitPoolWeighted(),
      ["ComposableStable" /* ComposableStable */]: new InitPoolComposableStable(),
      ...customAddLiquidityInitTypes
    };
  }
  getInitPool(poolType) {
    if (!this.initPoolTypes[poolType]) {
      throw new Error("Unsupported pool type: ${poolType}");
    }
    return this.initPoolTypes[poolType];
  }
  buildCall(input, poolState) {
    return this.getInitPool(poolState.type).buildCall(input, poolState);
  }
};

// src/entities/initPool/initPoolV3.ts
var InitPoolV3 = class {
  buildCall(input, poolState) {
    console.log(input, poolState);
    throw new Error("Method not implemented.");
  }
};

// src/entities/initPool/index.ts
var InitPool = class {
  constructor(config) {
    this.config = config;
    __publicField(this, "inputValidator", new InputValidator());
  }
  buildCall(input, poolState) {
    this.inputValidator.validateAddLiquidity(input, poolState);
    switch (poolState.balancerVersion) {
      case 2:
        return new InitPoolV2().buildCall(input, poolState);
      case 3:
        return new InitPoolV3().buildCall(input, poolState);
    }
  }
};

// src/entities/path.ts
var Path = class {
  constructor(tokens, pools) {
    __publicField(this, "pools");
    __publicField(this, "tokens");
    if (pools.length === 0 || tokens.length < 2) {
      throw new Error(
        "Invalid path: must contain at least 1 pool and 2 tokens."
      );
    }
    if (tokens.length !== pools.length + 1) {
      throw new Error(
        "Invalid path: tokens length must equal pools length + 1"
      );
    }
    this.pools = pools;
    this.tokens = tokens;
  }
};
var PathWithAmount = class extends Path {
  constructor(tokens, pools, swapAmount, mutateBalances) {
    super(tokens, pools);
    __publicField(this, "swapAmount");
    __publicField(this, "swapKind");
    __publicField(this, "outputAmount");
    __publicField(this, "inputAmount");
    __publicField(this, "mutateBalances");
    __publicField(this, "printPath", []);
    this.swapAmount = swapAmount;
    this.mutateBalances = Boolean(mutateBalances);
    if (tokens[0].isUnderlyingEqual(swapAmount.token)) {
      this.swapKind = 0 /* GivenIn */;
    } else {
      this.swapKind = 1 /* GivenOut */;
    }
    try {
      if (this.swapKind === 0 /* GivenIn */) {
        const amounts = new Array(this.tokens.length);
        amounts[0] = this.swapAmount;
        for (let i = 0; i < this.pools.length; i++) {
          const pool = this.pools[i];
          const outputAmount = pool.swapGivenIn(
            this.tokens[i],
            this.tokens[i + 1],
            amounts[i],
            this.mutateBalances
          );
          amounts[i + 1] = outputAmount;
          this.printPath.push({
            pool: pool.id,
            input: `${amounts[i].amount.toString()} ${this.tokens[i].symbol}`,
            output: `${outputAmount.amount.toString()} ${this.tokens[i + 1].symbol}`
          });
        }
        this.outputAmount = amounts[amounts.length - 1];
        this.inputAmount = this.swapAmount;
      } else {
        const amounts = new Array(this.tokens.length);
        amounts[amounts.length - 1] = this.swapAmount;
        for (let i = this.pools.length; i >= 1; i--) {
          const pool = this.pools[i - 1];
          const inputAmount = pool.swapGivenOut(
            this.tokens[i - 1],
            this.tokens[i],
            amounts[i],
            this.mutateBalances
          );
          amounts[i - 1] = inputAmount;
          this.printPath.push({
            pool: pool.id,
            input: `${inputAmount.amount.toString()} ${this.tokens[i - 1].symbol}`,
            output: `${amounts[i].amount.toString()} ${this.tokens[i].symbol}`
          });
        }
        this.printPath = this.printPath.reverse();
        this.inputAmount = amounts[0];
        this.outputAmount = this.swapAmount;
      }
    } catch (e) {
      throw new Error(
        "Invalid path, swap amount exceeds maximum for pool"
      );
    }
  }
  print() {
    console.table(this.printPath);
  }
};

// src/entities/priceImpact/index.ts


// src/entities/priceImpactAmount.ts

var PriceImpactAmount = class {
  constructor(amount) {
    __publicField(this, "amount");
    // raw amount in wei (i.e. 18 decimals)
    __publicField(this, "decimal");
    // decimal = wei * 1e-18
    __publicField(this, "percentage");
    // percentage = decimal * 1e-2
    __publicField(this, "bps");
    this.amount = BigInt(amount);
    this.decimal = parseFloat(_viem.formatEther.call(void 0, this.amount));
    this.percentage = this.decimal * 100;
    this.bps = this.decimal * 1e4;
  }
  // bps = basis points = decimal * 1e-4
  static fromRawAmount(rawAmount) {
    return new PriceImpactAmount(rawAmount);
  }
  static fromDecimal(decimalAmount) {
    const rawAmount = _viem.parseEther.call(void 0, decimalAmount);
    return PriceImpactAmount.fromRawAmount(rawAmount);
  }
  static fromPercentage(percentageAmount) {
    const decimalAmount = Number(percentageAmount) / 100;
    return PriceImpactAmount.fromDecimal(`${decimalAmount}`);
  }
  static fromBasisPoints(bpsAmount) {
    const decimalAmount = Number(bpsAmount) / 1e4;
    return PriceImpactAmount.fromDecimal(`${decimalAmount}`);
  }
};

// src/entities/removeLiquidity/removeLiquidityV2/weighted/removeLiquidityWeighted.ts


// src/entities/utils/parseRemoveLiquidityArgs.ts
function parseRemoveLiquidityArgs({
  chainId,
  toNativeAsset,
  sortedTokens,
  poolId,
  sender,
  recipient,
  minAmountsOut,
  userData,
  toInternalBalance
}) {
  const tokensOut = chainId && toNativeAsset ? replaceWrapped([...sortedTokens], chainId) : [...sortedTokens];
  const exitPoolRequest = {
    assets: tokensOut.map((t) => t.address),
    // with BPT
    minAmountsOut,
    // with BPT
    userData,
    // wihtout BPT
    toInternalBalance
  };
  return {
    args: [poolId, sender, recipient, exitPoolRequest],
    tokensOut
  };
}

// src/entities/utils/doRemoveLiquidityQuery.ts

async function doRemoveLiquidityQuery(rpcUrl, chainId, args) {
  const client = _viem.createPublicClient.call(void 0, {
    transport: _viem.http.call(void 0, rpcUrl),
    chain: CHAINS[chainId]
  });
  const {
    result: [bptIn, amountsOut]
  } = await client.simulateContract({
    address: BALANCER_QUERIES[chainId],
    abi: balancerQueriesAbi,
    functionName: "queryExit",
    args
  });
  return {
    bptIn,
    amountsOut
  };
}

// src/entities/removeLiquidity/removeLiquidityV2/weighted/removeLiquidityWeighted.ts
var RemoveLiquidityWeighted = class {
  async query(input, poolState) {
    const sortedTokens = getSortedTokens(poolState.tokens, input.chainId);
    const amounts = this.getAmountsQuery(sortedTokens, input);
    const userData = WeightedEncoder.encodeRemoveLiquidityUserData(
      input.kind,
      amounts
    );
    const { args, tokensOut } = parseRemoveLiquidityArgs({
      chainId: input.chainId,
      toNativeAsset: !!input.toNativeAsset,
      poolId: poolState.id,
      sortedTokens,
      sender: ZERO_ADDRESS,
      recipient: ZERO_ADDRESS,
      minAmountsOut: amounts.minAmountsOut,
      userData,
      toInternalBalance: !!input.toInternalBalance
    });
    const queryOutput = await doRemoveLiquidityQuery(
      input.rpcUrl,
      input.chainId,
      args
    );
    const bpt = new Token(input.chainId, poolState.address, 18);
    const bptIn = TokenAmount.fromRawAmount(bpt, queryOutput.bptIn);
    const amountsOut = queryOutput.amountsOut.map(
      (a, i) => TokenAmount.fromRawAmount(tokensOut[i], a)
    );
    return {
      poolType: poolState.type,
      removeLiquidityKind: input.kind,
      poolId: poolState.id,
      bptIn,
      amountsOut,
      tokenOutIndex: amounts.tokenOutIndex,
      toInternalBalance: !!input.toInternalBalance,
      balancerVersion: poolState.balancerVersion
    };
  }
  getAmountsQuery(tokens, input) {
    switch (input.kind) {
      case "Unbalanced" /* Unbalanced */:
        return {
          minAmountsOut: getAmounts(tokens, input.amountsOut),
          tokenOutIndex: void 0,
          maxBptAmountIn: MAX_UINT256
        };
      case "SingleToken" /* SingleToken */:
        return {
          minAmountsOut: Array(tokens.length).fill(0n),
          tokenOutIndex: tokens.findIndex(
            (t) => t.isSameAddress(input.tokenOut)
          ),
          maxBptAmountIn: input.bptIn.rawAmount
        };
      case "Proportional" /* Proportional */:
        return {
          minAmountsOut: Array(tokens.length).fill(0n),
          tokenOutIndex: void 0,
          maxBptAmountIn: input.bptIn.rawAmount
        };
    }
  }
  buildCall(input) {
    const amounts = this.getAmountsCall(input);
    const userData = WeightedEncoder.encodeRemoveLiquidityUserData(
      input.removeLiquidityKind,
      amounts
    );
    const { args } = parseRemoveLiquidityArgs({
      poolId: input.poolId,
      sortedTokens: input.amountsOut.map((a) => a.token),
      sender: input.sender,
      recipient: input.recipient,
      minAmountsOut: amounts.minAmountsOut,
      userData,
      toInternalBalance: !!input.toInternalBalance
    });
    const call = _viem.encodeFunctionData.call(void 0, {
      abi: vaultAbi,
      functionName: "exitPool",
      args
    });
    return {
      call,
      to: BALANCER_VAULT,
      value: 0n,
      maxBptIn: TokenAmount.fromRawAmount(
        input.bptIn.token,
        amounts.maxBptAmountIn
      ),
      minAmountsOut: input.amountsOut.map(
        (a, i) => TokenAmount.fromRawAmount(a.token, amounts.minAmountsOut[i])
      )
    };
  }
  getAmountsCall(input) {
    switch (input.removeLiquidityKind) {
      case "Unbalanced" /* Unbalanced */:
        return {
          minAmountsOut: input.amountsOut.map((a) => a.amount),
          tokenOutIndex: input.tokenOutIndex,
          maxBptAmountIn: input.slippage.applyTo(input.bptIn.amount)
        };
      case "SingleToken" /* SingleToken */:
        if (input.tokenOutIndex === void 0) {
          throw new Error(
            "tokenOutIndex must be defined for RemoveLiquiditySingleToken"
          );
        }
        return {
          minAmountsOut: input.amountsOut.map(
            (a) => input.slippage.removeFrom(a.amount)
          ),
          tokenOutIndex: input.tokenOutIndex,
          maxBptAmountIn: input.bptIn.amount
        };
      case "Proportional" /* Proportional */:
        return {
          minAmountsOut: input.amountsOut.map(
            (a) => input.slippage.removeFrom(a.amount)
          ),
          tokenOutIndex: input.tokenOutIndex,
          maxBptAmountIn: input.bptIn.amount
        };
      default:
        throw Error("Unsupported Remove Liquidity Kind");
    }
  }
};

// src/entities/removeLiquidity/removeLiquidityV2/composableStable/removeLiquidityComposableStable.ts

var RemoveLiquidityComposableStable = class {
  async query(input, poolState) {
    const sortedTokens = getSortedTokens(poolState.tokens, input.chainId);
    const bptIndex = poolState.tokens.findIndex(
      (t) => t.address === poolState.address
    );
    const amounts = this.getAmountsQuery(sortedTokens, input, bptIndex);
    const amountsWithoutBpt = {
      ...amounts,
      minAmountsOut: [
        ...amounts.minAmountsOut.slice(0, bptIndex),
        ...amounts.minAmountsOut.slice(bptIndex + 1)
      ]
    };
    const userData = ComposableStableEncoder.encodeRemoveLiquidityUserData(
      input.kind,
      amountsWithoutBpt
    );
    const { args, tokensOut } = parseRemoveLiquidityArgs({
      chainId: input.chainId,
      toNativeAsset: !!input.toNativeAsset,
      poolId: poolState.id,
      sortedTokens,
      sender: ZERO_ADDRESS,
      recipient: ZERO_ADDRESS,
      minAmountsOut: amounts.minAmountsOut,
      userData,
      toInternalBalance: !!input.toInternalBalance
    });
    const queryOutput = await doRemoveLiquidityQuery(
      input.rpcUrl,
      input.chainId,
      args
    );
    const bpt = new Token(input.chainId, poolState.address, 18);
    const bptIn = TokenAmount.fromRawAmount(bpt, queryOutput.bptIn);
    const amountsOut = queryOutput.amountsOut.map(
      (a, i) => TokenAmount.fromRawAmount(tokensOut[i], a)
    );
    return {
      poolType: poolState.type,
      removeLiquidityKind: input.kind,
      poolId: poolState.id,
      bptIn,
      amountsOut,
      tokenOutIndex: amounts.tokenOutIndex,
      toInternalBalance: !!input.toInternalBalance,
      bptIndex,
      balancerVersion: poolState.balancerVersion
    };
  }
  getAmountsQuery(tokens, input, bptIndex) {
    switch (input.kind) {
      case "Unbalanced" /* Unbalanced */:
        return {
          minAmountsOut: getAmounts(tokens, input.amountsOut),
          tokenOutIndex: void 0,
          maxBptAmountIn: MAX_UINT256
        };
      case "SingleToken" /* SingleToken */:
        return {
          minAmountsOut: Array(tokens.length).fill(0n),
          tokenOutIndex: tokens.filter((_, index) => index !== bptIndex).findIndex((t) => t.isSameAddress(input.tokenOut)),
          maxBptAmountIn: input.bptIn.rawAmount
        };
      case "Proportional" /* Proportional */:
        return {
          minAmountsOut: Array(tokens.length).fill(0n),
          tokenOutIndex: void 0,
          maxBptAmountIn: input.bptIn.rawAmount
        };
    }
  }
  buildCall(input) {
    const amounts = this.getAmountsCall(input);
    const amountsWithoutBpt = {
      ...amounts,
      minAmountsOut: [
        ...amounts.minAmountsOut.slice(0, input.bptIndex),
        ...amounts.minAmountsOut.slice(input.bptIndex + 1)
      ]
    };
    const userData = ComposableStableEncoder.encodeRemoveLiquidityUserData(
      input.removeLiquidityKind,
      amountsWithoutBpt
    );
    const { args } = parseRemoveLiquidityArgs({
      poolId: input.poolId,
      sortedTokens: input.amountsOut.map((a) => a.token),
      sender: input.sender,
      recipient: input.recipient,
      minAmountsOut: amounts.minAmountsOut,
      userData,
      toInternalBalance: !!input.toInternalBalance
    });
    const call = _viem.encodeFunctionData.call(void 0, {
      abi: vaultAbi,
      functionName: "exitPool",
      args
    });
    return {
      call,
      to: BALANCER_VAULT,
      value: 0n,
      maxBptIn: TokenAmount.fromRawAmount(
        input.bptIn.token,
        amounts.maxBptAmountIn
      ),
      minAmountsOut: input.amountsOut.map(
        (a, i) => TokenAmount.fromRawAmount(a.token, amounts.minAmountsOut[i])
      )
    };
  }
  getAmountsCall(input) {
    switch (input.removeLiquidityKind) {
      case "Unbalanced" /* Unbalanced */:
        return {
          minAmountsOut: input.amountsOut.map((a) => a.amount),
          tokenOutIndex: input.tokenOutIndex,
          maxBptAmountIn: input.slippage.applyTo(input.bptIn.amount)
        };
      case "SingleToken" /* SingleToken */:
        if (input.tokenOutIndex === void 0) {
          throw new Error(
            "tokenOutIndex must be defined for RemoveLiquiditySingleToken"
          );
        }
        return {
          minAmountsOut: input.amountsOut.map(
            (a) => input.slippage.removeFrom(a.amount)
          ),
          tokenOutIndex: input.tokenOutIndex,
          maxBptAmountIn: input.bptIn.amount
        };
      case "Proportional" /* Proportional */:
        return {
          minAmountsOut: input.amountsOut.map(
            (a) => input.slippage.removeFrom(a.amount)
          ),
          tokenOutIndex: input.tokenOutIndex,
          maxBptAmountIn: input.bptIn.amount
        };
      default:
        throw Error("Unsupported Remove Liquidity Kind");
    }
  }
};

// src/entities/removeLiquidity/removeLiquidityV2/index.ts
var RemoveLiquidityV2 = class {
  constructor(config) {
    __publicField(this, "removeLiquidityTypes", {});
    const { customRemoveLiquidityTypes } = config || {};
    this.removeLiquidityTypes = {
      //GYRO2, GYRO3, GYROE only support Remove Liquidity Proportional(1 - EXACT_BPT_IN_FOR_TOKENS_OUT)
      ["Gyro2" /* Gyro2 */]: new RemoveLiquidityWeighted(),
      ["Gyro3" /* Gyro3 */]: new RemoveLiquidityWeighted(),
      ["GyroE" /* GyroE */]: new RemoveLiquidityWeighted(),
      ["Weighted" /* Weighted */]: new RemoveLiquidityWeighted(),
      ["ComposableStable" /* ComposableStable */]: new RemoveLiquidityComposableStable(),
      // custom remove liquidity types take precedence over base types
      ...customRemoveLiquidityTypes
    };
  }
  getRemoveLiquidity(poolType) {
    if (!this.removeLiquidityTypes[poolType]) {
      throw new Error("Unsupported pool type");
    }
    return this.removeLiquidityTypes[poolType];
  }
  async query(input, poolState) {
    return this.getRemoveLiquidity(poolState.type).query(input, poolState);
  }
  buildCall(input) {
    return this.getRemoveLiquidity(input.poolType).buildCall(input);
  }
};

// src/entities/removeLiquidity/removeLiquidityV3.ts
var RemoveLiquidityV3 = class {
  async query(input, poolState) {
    console.log(input, poolState);
    throw new Error("Method not implemented.");
  }
  buildCall(input) {
    console.log(input);
    throw new Error("Method not implemented.");
  }
};

// src/entities/removeLiquidity/index.ts
var RemoveLiquidity = class {
  constructor(config) {
    this.config = config;
    __publicField(this, "inputValidator", new InputValidator());
  }
  async query(input, poolState) {
    this.inputValidator.validateRemoveLiquidity(input, poolState);
    switch (poolState.balancerVersion) {
      case 2: {
        const removeLiquidity = new RemoveLiquidityV2(this.config);
        return removeLiquidity.query(input, poolState);
      }
      case 3: {
        const removeLiquidity = new RemoveLiquidityV3();
        return removeLiquidity.query(input, poolState);
      }
    }
  }
  buildCall(input) {
    switch (input.balancerVersion) {
      case 2: {
        const removeLiquidity = new RemoveLiquidityV2(this.config);
        return removeLiquidity.buildCall(input);
      }
      case 3: {
        const removeLiquidity = new RemoveLiquidityV3();
        return removeLiquidity.buildCall(input);
      }
    }
  }
};

// src/entities/utils/doSingleSwapQuery.ts

var doSingleSwapQuery = async ({
  rpcUrl,
  chainId,
  ...swap
}) => {
  const publicClient = _viem.createPublicClient.call(void 0, {
    transport: _viem.http.call(void 0, rpcUrl)
  });
  const queriesContract = _viem.getContract.call(void 0, {
    address: BALANCER_QUERIES[chainId],
    abi: balancerQueriesAbi,
    publicClient
  });
  const { result } = await queriesContract.simulate.querySwap([
    swap,
    DEFAULT_FUND_MANAGMENT
  ]);
  return result;
};

// src/entities/priceImpact/index.ts
var PriceImpact = class {
};
__publicField(PriceImpact, "addLiquiditySingleToken", async (input, poolState) => {
  const addLiquidity = new AddLiquidity();
  const { amountsIn } = await addLiquidity.query(input, poolState);
  const removeLiquidity = new RemoveLiquidity();
  const removeLiquidityInput = {
    chainId: input.chainId,
    rpcUrl: input.rpcUrl,
    bptIn: input.bptOut,
    tokenOut: input.tokenIn,
    kind: "SingleToken" /* SingleToken */
  };
  const { amountsOut } = await removeLiquidity.query(
    removeLiquidityInput,
    poolState
  );
  const sortedTokens = getSortedTokens(poolState.tokens, input.chainId);
  const tokenIndex = sortedTokens.findIndex(
    (t) => t.isSameAddress(input.tokenIn)
  );
  const amountInitial = parseFloat(amountsIn[tokenIndex].toSignificant());
  const amountFinal = parseFloat(amountsOut[tokenIndex].toSignificant());
  const priceImpact = (amountInitial - amountFinal) / amountInitial / 2;
  return PriceImpactAmount.fromDecimal(`${priceImpact}`);
});
__publicField(PriceImpact, "addLiquidityUnbalanced", async (input, poolState) => {
  const addLiquidity = new AddLiquidity();
  const { amountsIn, bptOut } = await addLiquidity.query(
    input,
    poolState
  );
  const poolTokens = amountsIn.map((a) => a.token);
  const removeLiquidity = new RemoveLiquidity();
  const removeLiquidityInput = {
    chainId: input.chainId,
    rpcUrl: input.rpcUrl,
    bptIn: bptOut.toInputAmount(),
    kind: "Proportional" /* Proportional */
  };
  const { amountsOut } = await removeLiquidity.query(
    removeLiquidityInput,
    poolState
  );
  const deltas = amountsOut.map((a, i) => a.amount - amountsIn[i].amount);
  const deltaBPTs = [];
  for (let i = 0; i < deltas.length; i++) {
    if (deltas[i] === 0n) {
      deltaBPTs.push(0n);
    } else {
      deltaBPTs.push(await queryAddLiquidityForTokenDelta(i));
    }
  }
  const remainingDeltaIndex = await zeroOutDeltas(deltas, deltaBPTs);
  const amountInitial = parseFloat(
    _viem.formatUnits.call(void 0, 
      amountsIn[remainingDeltaIndex].amount,
      amountsIn[remainingDeltaIndex].token.decimals
    )
  );
  const amountDelta = parseFloat(
    _viem.formatUnits.call(void 0, 
      abs(deltas[remainingDeltaIndex]),
      amountsIn[remainingDeltaIndex].token.decimals
    )
  );
  const priceImpact = amountDelta / amountInitial / 2;
  return PriceImpactAmount.fromDecimal(`${priceImpact}`);
  async function zeroOutDeltas(deltas2, deltaBPTs2) {
    let minNegativeDeltaIndex = 0;
    const nonZeroDeltas = deltas2.filter((d) => d !== 0n);
    for (let i = 0; i < nonZeroDeltas.length - 1; i++) {
      const minPositiveDeltaIndex = deltaBPTs2.findIndex(
        (deltaBPT) => deltaBPT === min(deltaBPTs2.filter((a) => a > 0n))
      );
      minNegativeDeltaIndex = deltaBPTs2.findIndex(
        (deltaBPT) => deltaBPT === max(deltaBPTs2.filter((a) => a < 0n))
      );
      let kind;
      let givenTokenIndex;
      let resultTokenIndex;
      if (deltaBPTs2[minPositiveDeltaIndex] < abs(deltaBPTs2[minNegativeDeltaIndex])) {
        kind = 0 /* GivenIn */;
        givenTokenIndex = minPositiveDeltaIndex;
        resultTokenIndex = minNegativeDeltaIndex;
      } else {
        kind = 1 /* GivenOut */;
        givenTokenIndex = minNegativeDeltaIndex;
        resultTokenIndex = minPositiveDeltaIndex;
      }
      const singleSwap = {
        poolId: poolState.id,
        kind,
        assetIn: poolTokens[minPositiveDeltaIndex].address,
        assetOut: poolTokens[minNegativeDeltaIndex].address,
        amount: abs(deltas2[givenTokenIndex]),
        userData: "0x"
      };
      const resultAmount = await doSingleSwapQuery({
        ...singleSwap,
        rpcUrl: input.rpcUrl,
        chainId: input.chainId
      });
      deltas2[givenTokenIndex] = 0n;
      deltaBPTs2[givenTokenIndex] = 0n;
      deltas2[resultTokenIndex] = deltas2[resultTokenIndex] + resultAmount;
      deltaBPTs2[resultTokenIndex] = await queryAddLiquidityForTokenDelta(resultTokenIndex);
    }
    return minNegativeDeltaIndex;
  }
  async function queryAddLiquidityForTokenDelta(tokenIndex) {
    const absDelta = TokenAmount.fromRawAmount(
      poolTokens[tokenIndex],
      abs(deltas[tokenIndex])
    );
    const { bptOut: deltaBPT } = await addLiquidity.query(
      {
        ...input,
        amountsIn: [absDelta.toInputAmount()]
      },
      poolState
    );
    const signal = deltas[tokenIndex] >= 0n ? 1n : -1n;
    return deltaBPT.amount * signal;
  }
});
__publicField(PriceImpact, "removeLiquidity", async (input, poolState) => {
  const removeLiquidity = new RemoveLiquidity();
  const { bptIn, amountsOut } = await removeLiquidity.query(
    input,
    poolState
  );
  const addLiquidity = new AddLiquidity();
  const addLiquidityInput = {
    chainId: input.chainId,
    rpcUrl: input.rpcUrl,
    amountsIn: amountsOut.map((a) => a.toInputAmount()),
    kind: "Unbalanced" /* Unbalanced */
  };
  const { bptOut } = await addLiquidity.query(
    addLiquidityInput,
    poolState
  );
  const amountInitial = parseFloat(bptIn.toSignificant());
  const amountFinal = parseFloat(bptOut.toSignificant());
  const priceImpact = (amountInitial - amountFinal) / amountInitial / 2;
  return PriceImpactAmount.fromDecimal(`${priceImpact}`);
});
__publicField(PriceImpact, "singleSwap", async ({
  poolId,
  kind,
  assetIn,
  assetOut,
  amount,
  userData,
  rpcUrl,
  chainId
}) => {
  const amountResult = await doSingleSwapQuery({
    poolId,
    kind,
    assetIn,
    assetOut,
    amount,
    userData,
    rpcUrl,
    chainId
  });
  const amountFinal = await doSingleSwapQuery({
    poolId,
    kind,
    assetIn: assetOut,
    assetOut: assetIn,
    amount: amountResult,
    userData,
    rpcUrl,
    chainId
  });
  const priceImpact = MathSol.divDownFixed(
    abs(amount - amountFinal),
    amount * 2n
  );
  return PriceImpactAmount.fromRawAmount(priceImpact);
});

// src/entities/swap.ts






var _lodash = require('lodash');
var Swap = class {
  constructor({
    paths,
    swapKind
  }) {
    __publicField(this, "chainId");
    __publicField(this, "isBatchSwap");
    __publicField(this, "paths");
    __publicField(this, "pathsImmutable");
    __publicField(this, "assets");
    __publicField(this, "swapKind");
    __publicField(this, "swaps");
    if (paths.length === 0)
      throw new Error("Invalid swap: must contain at least 1 path.");
    this.pathsImmutable = _lodash.cloneDeep.call(void 0, paths);
    this.paths = paths.map(
      (path) => new PathWithAmount(
        path.tokens,
        path.pools,
        path.swapAmount,
        true
      )
    );
    this.chainId = paths[0].tokens[0].chainId;
    this.swapKind = swapKind;
    this.isBatchSwap = paths.length > 1 || paths[0].pools.length > 1;
    this.assets = [
      ...new Set(paths.flatMap((p) => p.tokens).map((t) => t.address))
    ];
    const swaps = this.getSwaps(this.paths);
    this.assets = this.assets.map((a) => {
      return this.convertNativeAddressToZero(a);
    });
    this.swaps = swaps;
  }
  get quote() {
    return this.swapKind === 0 /* GivenIn */ ? this.outputAmount : this.inputAmount;
  }
  get inputAmount() {
    return this.getInputAmount(this.paths);
  }
  get outputAmount() {
    return this.getOutputAmount(this.paths);
  }
  // rpcUrl is optional, but recommended to prevent rate limiting
  async query(rpcUrl, block) {
    const publicClient = _viem.createPublicClient.call(void 0, {
      transport: _viem.http.call(void 0, rpcUrl)
    });
    const queriesContract = _viem.getContract.call(void 0, {
      address: BALANCER_QUERIES[this.chainId],
      abi: balancerQueriesAbi,
      publicClient
    });
    let amount;
    if (this.isBatchSwap) {
      const { result } = await queriesContract.simulate.queryBatchSwap(
        [
          this.swapKind,
          this.swaps,
          this.assets,
          DEFAULT_FUND_MANAGMENT
        ],
        {
          blockNumber: block
        }
      );
      amount = this.swapKind === 0 /* GivenIn */ ? TokenAmount.fromRawAmount(
        this.outputAmount.token,
        abs(
          result[this.assets.indexOf(
            this.convertNativeAddressToZero(
              this.outputAmount.token.address
            )
          )]
        )
      ) : TokenAmount.fromRawAmount(
        this.inputAmount.token,
        abs(
          result[this.assets.indexOf(
            this.convertNativeAddressToZero(
              this.inputAmount.token.address
            )
          )]
        )
      );
    } else {
      const { result } = await queriesContract.simulate.querySwap(
        [this.swaps, DEFAULT_FUND_MANAGMENT],
        { blockNumber: block }
      );
      amount = this.swapKind === 0 /* GivenIn */ ? TokenAmount.fromRawAmount(this.outputAmount.token, result) : TokenAmount.fromRawAmount(this.inputAmount.token, result);
    }
    return amount;
  }
  convertNativeAddressToZero(address) {
    return address === NATIVE_ADDRESS ? ZERO_ADDRESS : address;
  }
  queryCallData() {
    let callData;
    if (this.isBatchSwap) {
      callData = _viem.encodeFunctionData.call(void 0, {
        abi: balancerQueriesAbi,
        functionName: "queryBatchSwap",
        args: [
          this.swapKind,
          this.swaps,
          this.assets,
          DEFAULT_FUND_MANAGMENT
        ]
      });
    } else {
      callData = _viem.encodeFunctionData.call(void 0, {
        abi: balancerQueriesAbi,
        functionName: "querySwap",
        args: [this.swaps, DEFAULT_FUND_MANAGMENT]
      });
    }
    return callData;
  }
  get priceImpact() {
    const paths = this.pathsImmutable;
    const pathsReverse = paths.map(
      (path) => new PathWithAmount(
        [...path.tokens].reverse(),
        [...path.pools].reverse(),
        this.swapKind === 0 /* GivenIn */ ? path.outputAmount : path.inputAmount
      )
    );
    const amountInitial = this.swapKind === 0 /* GivenIn */ ? this.getInputAmount(paths).amount : this.getOutputAmount(paths).amount;
    const amountFinal = this.swapKind === 0 /* GivenIn */ ? this.getOutputAmount(pathsReverse).amount : this.getInputAmount(pathsReverse).amount;
    const priceImpact = MathSol.divDownFixed(
      abs(amountInitial - amountFinal),
      amountInitial * 2n
    );
    return PriceImpactAmount.fromRawAmount(priceImpact);
  }
  // public get executionPrice(): Price {}
  // helper methods
  getSwaps(paths) {
    let swaps;
    if (this.isBatchSwap) {
      swaps = [];
      if (this.swapKind === 0 /* GivenIn */) {
        paths.map((p) => {
          p.pools.map((pool, i) => {
            swaps.push({
              poolId: pool.id,
              assetInIndex: BigInt(
                this.assets.indexOf(p.tokens[i].address)
              ),
              assetOutIndex: BigInt(
                this.assets.indexOf(p.tokens[i + 1].address)
              ),
              amount: i === 0 ? p.inputAmount.amount : 0n,
              userData: DEFAULT_USERDATA
            });
          });
        });
      } else {
        paths.map((p) => {
          const reversedPools = [...p.pools].reverse();
          const reversedTokens = [...p.tokens].reverse();
          reversedPools.map((pool, i) => {
            swaps.push({
              poolId: pool.id,
              assetInIndex: BigInt(
                this.assets.indexOf(
                  reversedTokens[i + 1].address
                )
              ),
              assetOutIndex: BigInt(
                this.assets.indexOf(reversedTokens[i].address)
              ),
              amount: i === 0 ? p.outputAmount.amount : 0n,
              userData: DEFAULT_USERDATA
            });
          });
        });
      }
    } else {
      const path = this.paths[0];
      const pool = path.pools[0];
      const assetIn = this.convertNativeAddressToZero(
        path.tokens[0].address
      );
      const assetOut = this.convertNativeAddressToZero(
        path.tokens[1].address
      );
      swaps = {
        poolId: pool.id,
        kind: this.swapKind,
        assetIn,
        assetOut,
        amount: path.swapAmount.amount,
        userData: DEFAULT_USERDATA
      };
    }
    return swaps;
  }
  getInputAmount(paths) {
    if (!paths.every(
      (p) => p.inputAmount.token.isEqual(paths[0].inputAmount.token)
    )) {
      throw new Error(
        "Input amount can only be calculated if all paths have the same input token"
      );
    }
    const amounts = paths.map((path) => path.inputAmount);
    return amounts.reduce((a, b) => a.add(b));
  }
  getOutputAmount(paths) {
    if (!paths.every(
      (p) => p.outputAmount.token.isEqual(paths[0].outputAmount.token)
    )) {
      throw new Error(
        "Output amount can only be calculated if all paths have the same output token"
      );
    }
    const amounts = paths.map((path) => path.outputAmount);
    return amounts.reduce((a, b) => a.add(b));
  }
};

// src/entities/slippage.ts

var Slippage = class {
  constructor(amount) {
    __publicField(this, "amount");
    __publicField(this, "decimal");
    __publicField(this, "percentage");
    __publicField(this, "bps");
    this.amount = BigInt(amount);
    this.decimal = parseFloat(_viem.formatEther.call(void 0, this.amount));
    this.percentage = this.decimal * 100;
    this.bps = this.decimal * 1e4;
  }
  static fromRawAmount(rawAmount) {
    return new Slippage(rawAmount);
  }
  static fromDecimal(decimalAmount) {
    const rawAmount = _viem.parseEther.call(void 0, decimalAmount);
    return Slippage.fromRawAmount(rawAmount);
  }
  static fromPercentage(percentageAmount) {
    const decimalAmount = Number(percentageAmount) / 100;
    return Slippage.fromDecimal(`${decimalAmount}`);
  }
  static fromBasisPoints(bpsAmount) {
    const decimalAmount = Number(bpsAmount) / 1e4;
    return Slippage.fromDecimal(`${decimalAmount}`);
  }
  applyTo(amount) {
    return MathSol.mulDownFixed(amount, this.amount + WAD);
  }
  removeFrom(amount) {
    return MathSol.divDownFixed(amount, this.amount + WAD);
  }
};

// src/utils/logger.ts
var _pino = require('pino'); var _pino2 = _interopRequireDefault(_pino);
var LOG_LEVEL = process.env.LOG_LEVEL || "info";
var logger = _pino2.default.call(void 0, {
  formatters: {
    level(level) {
      return { level };
    }
  },
  base: void 0,
  level: LOG_LEVEL
});

// src/pathGraph/pathGraph.ts
var DEFAULT_MAX_PATHS_PER_TOKEN_PAIR = 2;
var PathGraph = class {
  constructor() {
    __publicField(this, "nodes");
    __publicField(this, "edges");
    __publicField(this, "poolAddressMap");
    __publicField(this, "maxPathsPerTokenPair", DEFAULT_MAX_PATHS_PER_TOKEN_PAIR);
    this.nodes = /* @__PURE__ */ new Map();
    this.edges = /* @__PURE__ */ new Map();
    this.poolAddressMap = /* @__PURE__ */ new Map();
  }
  // We build a directed graph for all pools.
  // Nodes are tokens and edges are triads: [pool.id, tokenIn, tokenOut].
  // The current criterion for including a pool path into this graph is the following:
  // (a) We include every path that includes a phantom BPT.
  // (b) For any token pair x -> y, we include only the most liquid ${maxPathsPerTokenPair}
  // pool pairs (default 2).
  buildGraph({
    pools,
    maxPathsPerTokenPair = DEFAULT_MAX_PATHS_PER_TOKEN_PAIR
  }) {
    this.poolAddressMap = /* @__PURE__ */ new Map();
    this.nodes = /* @__PURE__ */ new Map();
    this.edges = /* @__PURE__ */ new Map();
    this.maxPathsPerTokenPair = maxPathsPerTokenPair;
    this.buildPoolAddressMap(pools);
    this.addAllTokensAsGraphNodes(pools);
    this.addTokenPairsAsGraphEdges({ pools, maxPathsPerTokenPair });
  }
  // Since the path combinations here can get quite large, we use configurable parameters
  // to enforce upper limits across several dimensions, defined in the pathConfig.
  // (a) maxDepth - the max depth of the traversal (length of token path), defaults to 7.
  // (b) maxNonBoostedPathDepth - the max depth for any path that does not contain a phantom bpt.
  // (c) maxNonBoostedHopTokensInBoostedPath - The max number of non boosted hop tokens
  // allowed in a boosted path.
  // (d) approxPathsToReturn - search for up to this many paths. Since all paths for a single traversal
  // are added, its possible that the amount returned is larger than this number.
  // (e) poolIdsToInclude - Only include paths with these poolIds (optional)
  // Additionally, we impose the following requirements for a path to be considered valid
  // (a) It does not visit the same token twice
  // (b) It does not use the same pool twice
  getCandidatePaths({
    tokenIn,
    tokenOut,
    graphTraversalConfig
  }) {
    const config = {
      maxDepth: 6,
      maxNonBoostedPathDepth: 3,
      maxNonBoostedHopTokensInBoostedPath: 2,
      approxPathsToReturn: 5,
      ...graphTraversalConfig
    };
    const tokenPaths = this.findAllValidTokenPaths({
      token: tokenIn.wrapped,
      tokenIn: tokenIn.wrapped,
      tokenOut: tokenOut.wrapped,
      config,
      tokenPath: [tokenIn.wrapped]
    }).sort((a, b) => a.length < b.length ? -1 : 1);
    const paths = [];
    const selectedPathIds = [];
    for (let idx = 0; idx < this.maxPathsPerTokenPair; idx++) {
      for (let i = 0; i < tokenPaths.length; i++) {
        const path = this.expandTokenPath({
          tokenPath: tokenPaths[i],
          tokenPairIndex: idx
        });
        if (this.isValidPath({
          path,
          seenPoolAddresses: [],
          selectedPathIds,
          config
        })) {
          selectedPathIds.push(this.getIdForPath(path));
          paths.push(path);
        }
      }
      if (paths.length >= config.approxPathsToReturn) {
        break;
      }
    }
    return this.sortAndFilterPaths(paths).map((path) => {
      const pathTokens = [
        ...path.map((segment) => segment.tokenOut)
      ];
      pathTokens.unshift(tokenIn);
      pathTokens[pathTokens.length - 1] = tokenOut;
      return {
        tokens: pathTokens,
        pools: path.map((segment) => segment.pool)
      };
    });
  }
  sortAndFilterPaths(paths) {
    const pathsWithLimits = paths.map((path) => {
      try {
        const limit = this.getLimitAmountSwapForPath(
          path,
          0 /* GivenIn */
        );
        return { path, limit };
      } catch (_e) {
        console.error(
          "Error getting limit for path",
          path.map((p) => p.pool.id).join(" -> ")
        );
        return void 0;
      }
    }).filter(
      (path) => !!path
    ).sort((a, b) => a.limit < b.limit ? 1 : -1);
    const filtered = [];
    for (const { path } of pathsWithLimits) {
      let seenPools = [];
      let isValid = true;
      for (const segment of path) {
        if (seenPools.includes(segment.pool.id)) {
          isValid = false;
          break;
        }
      }
      if (isValid) {
        filtered.push(path);
        seenPools = [
          ...seenPools,
          ...path.map((segment) => segment.pool.id)
        ];
      }
    }
    return filtered;
  }
  buildPoolAddressMap(pools) {
    for (const pool of pools) {
      this.poolAddressMap.set(pool.address, pool);
    }
  }
  addAllTokensAsGraphNodes(pools) {
    for (const pool of pools) {
      for (const tokenAmount of pool.tokens) {
        const token = tokenAmount.token;
        if (!this.nodes.has(token.wrapped)) {
          this.addNode(token);
        }
      }
    }
  }
  addTokenPairsAsGraphEdges({
    pools,
    maxPathsPerTokenPair
  }) {
    for (const pool of pools) {
      for (let i = 0; i < pool.tokens.length - 1; i++) {
        for (let j = i + 1; j < pool.tokens.length; j++) {
          const tokenI = pool.tokens[i].token;
          const tokenJ = pool.tokens[j].token;
          this.addEdge({
            edgeProps: {
              pool,
              tokenIn: tokenI,
              tokenOut: tokenJ,
              normalizedLiquidity: pool.getNormalizedLiquidity(
                tokenI,
                tokenJ
              )
            },
            maxPathsPerTokenPair
          });
          this.addEdge({
            edgeProps: {
              pool,
              tokenIn: tokenJ,
              tokenOut: tokenI,
              normalizedLiquidity: pool.getNormalizedLiquidity(
                tokenJ,
                tokenI
              )
            },
            maxPathsPerTokenPair
          });
        }
      }
    }
  }
  addNode(token) {
    this.nodes.set(token.wrapped, {
      isPhantomBpt: !!this.poolAddressMap[token.wrapped]
    });
    if (!this.edges.has(token.wrapped)) {
      this.edges.set(token.wrapped, /* @__PURE__ */ new Map());
    }
  }
  /**
   * Returns the vertices connected to a given vertex
   */
  getConnectedVertices(tokenAddress) {
    const result = [];
    const edges = this.edges.get(tokenAddress) || [];
    for (const [otherToken] of edges) {
      result.push(otherToken);
    }
    return result;
  }
  /**
   * Adds a directed edge from a source vertex to a destination
   */
  addEdge({
    edgeProps,
    maxPathsPerTokenPair
  }) {
    const tokenInVertex = this.nodes.get(edgeProps.tokenIn.wrapped);
    const tokenOutVertex = this.nodes.get(edgeProps.tokenOut.wrapped);
    const tokenInNode = this.edges.get(edgeProps.tokenIn.wrapped);
    if (!tokenInVertex || !tokenOutVertex || !tokenInNode) {
      throw new Error("Attempting to add invalid edge");
    }
    const hasPhantomBpt = tokenInVertex.isPhantomBpt || tokenOutVertex.isPhantomBpt;
    const existingEdges = tokenInNode.get(edgeProps.tokenOut.wrapped) || [];
    const sorted = [...existingEdges, edgeProps].sort(
      (a, b) => a.normalizedLiquidity > b.normalizedLiquidity ? -1 : 1
    );
    tokenInNode.set(
      edgeProps.tokenOut.wrapped,
      sorted.length > maxPathsPerTokenPair && !hasPhantomBpt ? sorted.slice(0, 2) : sorted
    );
  }
  findAllValidTokenPaths(args) {
    const tokenPaths = [];
    this.traverseBfs({
      ...args,
      callback: (tokenPath) => {
        tokenPaths.push(tokenPath);
      }
    });
    return tokenPaths;
  }
  expandTokenPath({
    tokenPath,
    tokenPairIndex
  }) {
    const segments = [];
    for (let i = 0; i < tokenPath.length - 1; i++) {
      const edge = _optionalChain([this, 'access', _45 => _45.edges, 'access', _46 => _46.get, 'call', _47 => _47(tokenPath[i]), 'optionalAccess', _48 => _48.get, 'call', _49 => _49(tokenPath[i + 1])]);
      if (!edge || edge.length === 0) {
        throw new Error(
          `Missing edge for pair ${tokenPath[i]} -> ${tokenPath[i + 1]}`
        );
      }
      segments.push(edge[tokenPairIndex] || edge[0]);
    }
    return segments;
  }
  traverseBfs({
    token,
    tokenIn,
    tokenOut,
    tokenPath,
    callback,
    config
  }) {
    const neighbors = this.getConnectedVertices(token);
    for (const neighbor of neighbors) {
      const validTokenPath = this.isValidTokenPath({
        tokenPath: [...tokenPath, neighbor],
        tokenIn,
        tokenOut,
        config
      });
      if (validTokenPath && neighbor === tokenOut) {
        callback([...tokenPath, neighbor]);
      } else if (validTokenPath && !tokenPath.includes(neighbor)) {
        this.traverseBfs({
          tokenPath: [...tokenPath, neighbor],
          token: neighbor,
          tokenIn,
          tokenOut,
          callback,
          config
        });
      }
    }
  }
  isValidTokenPath({
    tokenPath,
    config,
    tokenIn,
    tokenOut
  }) {
    const isCompletePath = tokenPath[tokenPath.length - 1] === tokenOut;
    const hopTokens = tokenPath.filter(
      (token) => token !== tokenIn && token !== tokenOut
    );
    const numStandardHopTokens = hopTokens.filter(
      (token) => !this.poolAddressMap.has(token)
    ).length;
    const isBoostedPath = tokenPath.filter((token) => this.poolAddressMap.has(token)).length > 0;
    if (tokenPath.length > config.maxDepth) {
      return false;
    }
    if (isBoostedPath && numStandardHopTokens > config.maxNonBoostedHopTokensInBoostedPath) {
      return false;
    }
    if (tokenPath.length > config.maxNonBoostedPathDepth && numStandardHopTokens > config.maxNonBoostedHopTokensInBoostedPath) {
      return false;
    }
    if (isCompletePath && !isBoostedPath && tokenPath.length > config.maxNonBoostedPathDepth) {
      return false;
    }
    return true;
  }
  isValidPath({
    path,
    seenPoolAddresses,
    selectedPathIds,
    config
  }) {
    const poolIdsInPath = path.map((segment) => segment.pool.id);
    const uniquePools = [...new Set(poolIdsInPath)];
    if (config.poolIdsToInclude) {
      for (const poolId of poolIdsInPath) {
        if (!config.poolIdsToInclude.includes(poolId)) {
          return false;
        }
      }
    }
    if (uniquePools.length !== poolIdsInPath.length) {
      return false;
    }
    for (const segment of path) {
      if (seenPoolAddresses.includes(segment.pool.address)) {
        return false;
      }
    }
    if (selectedPathIds.includes(this.getIdForPath(path))) {
      return false;
    }
    return true;
  }
  getIdForPath(path) {
    let id = "";
    for (const segment of path) {
      if (id.length > 0) {
        id += "_";
      }
      id += `${segment.pool.id}-${segment.tokenIn}-${segment.tokenOut}`;
    }
    return id;
  }
  filterVolatilePools(poolAddresses) {
    const filtered = [];
    for (const poolAddress of poolAddresses) {
      if (_optionalChain([this, 'access', _50 => _50.poolAddressMap, 'access', _51 => _51.get, 'call', _52 => _52(poolAddress), 'optionalAccess', _53 => _53.poolType]) === "Weighted" /* Weighted */) {
        filtered.push(poolAddress);
      }
    }
    return filtered;
  }
  getLimitAmountSwapForPath(path, swapKind) {
    let limit = path[path.length - 1].pool.getLimitAmountSwap(
      path[path.length - 1].tokenIn,
      path[path.length - 1].tokenOut,
      swapKind
    );
    for (let i = path.length - 2; i >= 0; i--) {
      const poolLimitExactIn = path[i].pool.getLimitAmountSwap(
        path[i].tokenIn,
        path[i].tokenOut,
        0 /* GivenIn */
      );
      const poolLimitExactOut = path[i].pool.getLimitAmountSwap(
        path[i].tokenIn,
        path[i].tokenOut,
        1 /* GivenOut */
      );
      if (poolLimitExactOut <= limit) {
        limit = poolLimitExactIn;
      } else {
        const pulledLimit = path[i].pool.swapGivenOut(
          path[i].tokenIn,
          path[i].tokenOut,
          TokenAmount.fromRawAmount(path[i].tokenOut, limit)
        ).amount;
        limit = pulledLimit > poolLimitExactIn ? poolLimitExactIn : pulledLimit;
      }
    }
    return limit;
  }
};

// src/router.ts
var Router = class {
  constructor() {
    __publicField(this, "pathGraph");
    this.pathGraph = new PathGraph();
  }
  getCandidatePaths(tokenIn, tokenOut, pools, graphTraversalConfig) {
    this.pathGraph.buildGraph({ pools });
    const candidatePaths = this.pathGraph.getCandidatePaths({
      tokenIn,
      tokenOut,
      graphTraversalConfig
    });
    return candidatePaths;
  }
  getBestPaths(paths, swapKind, swapAmount) {
    if (paths.length === 0) {
      throw new Error("No potential swap paths provided");
    }
    const quotePaths = [];
    paths.forEach((path) => {
      try {
        quotePaths.push(
          new PathWithAmount(path.tokens, path.pools, swapAmount)
        );
      } catch (e2) {
        logger.trace("Invalid path:");
        logger.trace(
          path.tokens.map((token) => token.symbol).join(" -> ")
        );
        logger.trace(path.pools.map((pool) => pool.id).join(" -> "));
        return;
      }
    });
    if (quotePaths.length === 0) {
      logger.info("No valid paths found");
      return null;
    }
    let valueArr;
    if (swapKind === 0 /* GivenIn */) {
      valueArr = quotePaths.map((item) => {
        return {
          item,
          value: Number(item.outputAmount.amount)
        };
      });
      valueArr.sort((a, b) => b.value - a.value);
    } else {
      valueArr = quotePaths.map((item) => {
        return {
          item,
          value: Number(item.inputAmount.amount)
        };
      });
      valueArr.sort((a, b) => a.value - b.value);
    }
    const orderedQuotePaths = valueArr.map((item) => item.item);
    if (orderedQuotePaths.length === 1) {
      return orderedQuotePaths;
    }
    const swapAmount50up = swapAmount.mulDownFixed(WAD / 2n);
    const swapAmount50down = swapAmount.sub(swapAmount50up);
    const path50up = new PathWithAmount(
      orderedQuotePaths[0].tokens,
      orderedQuotePaths[0].pools,
      swapAmount50up
    );
    const path50down = new PathWithAmount(
      orderedQuotePaths[1].tokens,
      orderedQuotePaths[1].pools,
      swapAmount50down
    );
    if (swapKind === 0 /* GivenIn */) {
      if (orderedQuotePaths[0].outputAmount.amount > path50up.outputAmount.amount + path50down.outputAmount.amount) {
        return orderedQuotePaths.slice(0, 1);
      }
      return [path50up, path50down];
    }
    if (orderedQuotePaths[0].inputAmount.amount < path50up.inputAmount.amount + path50down.inputAmount.amount) {
      return orderedQuotePaths.slice(0, 1);
    }
    return [path50up, path50down];
  }
};

// src/entities/pools/weighted/weightedPool.ts


// src/entities/pools/weighted/weightedMath.ts
function _calcOutGivenIn(balanceIn, weightIn, balanceOut, weightOut, amountIn, version) {
  const denominator = balanceIn + amountIn;
  const base = MathSol.divUpFixed(balanceIn, denominator);
  const exponent = MathSol.divDownFixed(weightIn, weightOut);
  const power = MathSol.powUpFixed(base, exponent, version);
  return MathSol.mulDownFixed(balanceOut, MathSol.complementFixed(power));
}
function _calcInGivenOut(balanceIn, weightIn, balanceOut, weightOut, amountOut, version) {
  const base = MathSol.divUpFixed(balanceOut, balanceOut - amountOut);
  const exponent = MathSol.divUpFixed(weightOut, weightIn);
  const power = MathSol.powUpFixed(base, exponent, version);
  const ratio = power - WAD;
  return MathSol.mulUpFixed(balanceIn, ratio);
}

// src/entities/pools/weighted/weightedPool.ts
var WeightedPoolToken = class extends TokenAmount {
  constructor(token, amount, weight, index) {
    super(token, amount);
    __publicField(this, "weight");
    __publicField(this, "index");
    this.weight = BigInt(weight);
    this.index = index;
  }
  increase(amount) {
    this.amount = this.amount + amount;
    this.scale18 = this.amount * this.scalar;
    return this;
  }
  decrease(amount) {
    this.amount = this.amount - amount;
    this.scale18 = this.amount * this.scalar;
    return this;
  }
};
var WeightedPool = class {
  constructor(id, poolTypeVersion, swapFee, tokens) {
    __publicField(this, "chainId");
    __publicField(this, "id");
    __publicField(this, "address");
    __publicField(this, "poolType", "Weighted" /* Weighted */);
    __publicField(this, "poolTypeVersion");
    __publicField(this, "swapFee");
    __publicField(this, "tokens");
    __publicField(this, "tokenMap");
    __publicField(this, "MAX_IN_RATIO", 300000000000000000n);
    // 0.3
    __publicField(this, "MAX_OUT_RATIO", 300000000000000000n);
    this.chainId = tokens[0].token.chainId;
    this.id = id;
    this.poolTypeVersion = poolTypeVersion;
    this.address = getPoolAddress(id);
    this.swapFee = swapFee;
    this.tokens = tokens;
    this.tokenMap = new Map(
      tokens.map((token) => [token.token.address, token])
    );
  }
  // 0.3
  static fromRawPool(chainId, pool) {
    const poolTokens = [];
    for (const t of pool.tokens) {
      if (!t.weight) {
        throw new Error("Weighted pool token does not have a weight");
      }
      const token = new Token(
        chainId,
        t.address,
        t.decimals,
        t.symbol,
        t.name
      );
      const tokenAmount = TokenAmount.fromHumanAmount(token, t.balance);
      poolTokens.push(
        new WeightedPoolToken(
          token,
          tokenAmount.amount,
          _viem.parseEther.call(void 0, t.weight),
          t.index
        )
      );
    }
    return new WeightedPool(
      pool.id,
      pool.poolTypeVersion,
      _viem.parseEther.call(void 0, pool.swapFee),
      poolTokens
    );
  }
  getNormalizedLiquidity(tokenIn, tokenOut) {
    const { tIn, tOut } = this.getRequiredTokenPair(tokenIn, tokenOut);
    return tIn.amount * tOut.weight / (tIn.weight + tOut.weight);
  }
  getLimitAmountSwap(tokenIn, tokenOut, swapKind) {
    const { tIn, tOut } = this.getRequiredTokenPair(tokenIn, tokenOut);
    if (swapKind === 0 /* GivenIn */) {
      return tIn.amount * this.MAX_IN_RATIO / WAD;
    }
    return tOut.amount * this.MAX_OUT_RATIO / WAD;
  }
  swapGivenIn(tokenIn, tokenOut, swapAmount, mutateBalances) {
    const { tIn, tOut } = this.getRequiredTokenPair(tokenIn, tokenOut);
    if (swapAmount.amount > this.getLimitAmountSwap(tokenIn, tokenOut, 0 /* GivenIn */)) {
      throw new Error("Swap amount exceeds the pool limit");
    }
    const amountWithFee = this.subtractSwapFeeAmount(swapAmount);
    const tokenOutScale18 = _calcOutGivenIn(
      tIn.scale18,
      tIn.weight,
      tOut.scale18,
      tOut.weight,
      amountWithFee.scale18,
      this.poolTypeVersion
    );
    const tokenOutAmount = TokenAmount.fromScale18Amount(
      tokenOut,
      tokenOutScale18
    );
    if (mutateBalances) {
      tIn.increase(swapAmount.amount);
      tOut.decrease(tokenOutAmount.amount);
    }
    return tokenOutAmount;
  }
  swapGivenOut(tokenIn, tokenOut, swapAmount, mutateBalances) {
    const { tIn, tOut } = this.getRequiredTokenPair(tokenIn, tokenOut);
    if (swapAmount.amount > this.getLimitAmountSwap(tokenIn, tokenOut, 1 /* GivenOut */)) {
      throw new Error("Swap amount exceeds the pool limit");
    }
    const tokenInScale18 = _calcInGivenOut(
      tIn.scale18,
      tIn.weight,
      tOut.scale18,
      tOut.weight,
      swapAmount.scale18,
      this.poolTypeVersion
    );
    const tokenInAmount = this.addSwapFeeAmount(
      TokenAmount.fromScale18Amount(tokenIn, tokenInScale18, true)
    );
    if (mutateBalances) {
      tIn.increase(tokenInAmount.amount);
      tOut.decrease(swapAmount.amount);
    }
    return tokenInAmount;
  }
  subtractSwapFeeAmount(amount) {
    const feeAmount = amount.mulUpFixed(this.swapFee);
    return amount.sub(feeAmount);
  }
  addSwapFeeAmount(amount) {
    return amount.divUpFixed(MathSol.complementFixed(this.swapFee));
  }
  getRequiredTokenPair(tokenIn, tokenOut) {
    const tIn = this.tokenMap.get(tokenIn.wrapped);
    const tOut = this.tokenMap.get(tokenOut.wrapped);
    if (!tIn || !tOut) {
      throw new Error("Pool does not contain the tokens provided");
    }
    return { tIn, tOut };
  }
};

// src/entities/pools/weighted/weightedFactory.ts
var WeightedPoolFactory = class {
  isPoolForFactory(pool) {
    return pool.poolType === "Weighted";
  }
  create(chainId, pool) {
    return WeightedPool.fromRawPool(chainId, pool);
  }
};

// src/entities/pools/stable/stablePool.ts


// src/entities/pools/stable/stableMath.ts
var AMP_PRECISION = 1000n;
function _calculateInvariant(amplificationParameter, balances, roundUp) {
  let sum = 0n;
  const numTokens = balances.length;
  for (let i = 0; i < numTokens; i++) {
    sum += balances[i];
  }
  if (sum === 0n) {
    return 0n;
  }
  let prevInvariant;
  let invariant = sum;
  const ampTimesTotal = amplificationParameter * BigInt(numTokens);
  for (let i = 0; i < 255; i++) {
    let D_P = invariant;
    for (let j = 0; j < numTokens; j++) {
      D_P = roundUp ? MathSol.divUp(
        D_P * invariant,
        balances[j] * BigInt(numTokens)
      ) : D_P * invariant / (balances[j] * BigInt(numTokens));
    }
    prevInvariant = invariant;
    invariant = roundUp ? MathSol.divUp(
      (ampTimesTotal * sum / AMP_PRECISION + D_P * BigInt(numTokens)) * invariant,
      MathSol.divUp(
        (ampTimesTotal - AMP_PRECISION) * invariant,
        AMP_PRECISION
      ) + (BigInt(numTokens) + 1n) * D_P
    ) : (ampTimesTotal * sum / AMP_PRECISION + D_P * BigInt(numTokens)) * invariant / ((ampTimesTotal - AMP_PRECISION) * invariant / AMP_PRECISION + (BigInt(numTokens) + 1n) * D_P);
    if (invariant > prevInvariant) {
      if (invariant - prevInvariant <= 1n) {
        return invariant;
      }
    } else if (prevInvariant - invariant <= 1n) {
      return invariant;
    }
  }
  throw new Error("Errors.STABLE_INVARIANT_DIDNT_CONVERGE");
}
function _calcOutGivenIn2(amplificationParameter, balances, tokenIndexIn, tokenIndexOut, tokenAmountIn, invariant) {
  balances[tokenIndexIn] = balances[tokenIndexIn] + tokenAmountIn;
  const finalBalanceOut = _getTokenBalanceGivenInvariantAndAllOtherBalances(
    amplificationParameter,
    balances,
    invariant,
    tokenIndexOut
  );
  balances[tokenIndexIn] = balances[tokenIndexIn] - tokenAmountIn;
  return balances[tokenIndexOut] - finalBalanceOut - 1n;
}
function _calcInGivenOut2(amplificationParameter, balances, tokenIndexIn, tokenIndexOut, tokenAmountOut, invariant) {
  balances[tokenIndexOut] = balances[tokenIndexOut] - tokenAmountOut;
  const finalBalanceIn = _getTokenBalanceGivenInvariantAndAllOtherBalances(
    amplificationParameter,
    balances,
    invariant,
    tokenIndexIn
  );
  balances[tokenIndexOut] = balances[tokenIndexOut] - tokenAmountOut;
  return finalBalanceIn - balances[tokenIndexIn] + 1n;
}
function _calcBptOutGivenExactTokensIn(amp, balances, amountsIn, bptTotalSupply, currentInvariant, swapFee) {
  let sumBalances = 0n;
  for (let i = 0; i < balances.length; i++) {
    sumBalances += balances[i];
  }
  const balanceRatiosWithFee = new Array(amountsIn.length);
  let invariantRatioWithFees = 0n;
  for (let i = 0; i < balances.length; i++) {
    const currentWeight = MathSol.divDownFixed(balances[i], sumBalances);
    balanceRatiosWithFee[i] = MathSol.divDownFixed(
      balances[i] + amountsIn[i],
      balances[i]
    );
    invariantRatioWithFees = invariantRatioWithFees + MathSol.mulDownFixed(balanceRatiosWithFee[i], currentWeight);
  }
  const newBalances = new Array(balances.length);
  for (let i = 0; i < balances.length; i++) {
    let amountInWithoutFee;
    if (balanceRatiosWithFee[i] > invariantRatioWithFees) {
      const nonTaxableAmount = MathSol.mulDownFixed(
        balances[i],
        invariantRatioWithFees - WAD
      );
      const taxableAmount = amountsIn[i] - nonTaxableAmount;
      amountInWithoutFee = nonTaxableAmount + MathSol.mulDownFixed(taxableAmount, WAD - swapFee);
    } else {
      amountInWithoutFee = amountsIn[i];
    }
    newBalances[i] = balances[i] + amountInWithoutFee;
  }
  const newInvariant = _calculateInvariant(amp, newBalances);
  const invariantRatio = MathSol.divDownFixed(newInvariant, currentInvariant);
  if (invariantRatio > WAD) {
    return MathSol.mulDownFixed(bptTotalSupply, invariantRatio - WAD);
  }
  return 0n;
}
function _calcTokenInGivenExactBptOut(amp, balances, tokenIndex, bptAmountOut, bptTotalSupply, currentInvariant, swapFee) {
  const newInvariant = MathSol.mulUpFixed(
    MathSol.divUpFixed(bptTotalSupply + bptAmountOut, bptTotalSupply),
    currentInvariant
  );
  const newBalanceTokenIndex = _getTokenBalanceGivenInvariantAndAllOtherBalances(
    amp,
    balances,
    newInvariant,
    tokenIndex
  );
  const amountInWithoutFee = newBalanceTokenIndex - balances[tokenIndex];
  let sumBalances = 0n;
  for (let i = 0; i < balances.length; i++) {
    sumBalances += balances[i];
  }
  const currentWeight = MathSol.divDownFixed(
    balances[tokenIndex],
    sumBalances
  );
  const taxablePercentage = MathSol.complementFixed(currentWeight);
  const taxableAmount = MathSol.mulUpFixed(
    amountInWithoutFee,
    taxablePercentage
  );
  const nonTaxableAmount = amountInWithoutFee - taxableAmount;
  return nonTaxableAmount + MathSol.divUpFixed(taxableAmount, WAD - swapFee);
}
function _calcBptInGivenExactTokensOut(amp, balances, amountsOut, bptTotalSupply, currentInvariant, swapFee) {
  let sumBalances = 0n;
  for (let i = 0; i < balances.length; i++) {
    sumBalances += balances[i];
  }
  const balanceRatiosWithoutFee = new Array(amountsOut.length);
  let invariantRatioWithoutFees = 0n;
  for (let i = 0; i < balances.length; i++) {
    const currentWeight = MathSol.divUpFixed(balances[i], sumBalances);
    balanceRatiosWithoutFee[i] = MathSol.divUpFixed(
      balances[i] - amountsOut[i],
      balances[i]
    );
    invariantRatioWithoutFees += MathSol.mulUpFixed(
      balanceRatiosWithoutFee[i],
      currentWeight
    );
  }
  const newBalances = new Array(balances.length);
  for (let i = 0; i < balances.length; i++) {
    let amountOutWithFee;
    if (invariantRatioWithoutFees > balanceRatiosWithoutFee[i]) {
      const nonTaxableAmount = MathSol.mulDownFixed(
        balances[i],
        MathSol.complementFixed(invariantRatioWithoutFees)
      );
      const taxableAmount = amountsOut[i] - nonTaxableAmount;
      amountOutWithFee = nonTaxableAmount + MathSol.divUpFixed(taxableAmount, WAD - swapFee);
    } else {
      amountOutWithFee = amountsOut[i];
    }
    newBalances[i] = balances[i] - amountOutWithFee;
  }
  const newInvariant = _calculateInvariant(amp, newBalances);
  const invariantRatio = MathSol.divDownFixed(newInvariant, currentInvariant);
  return MathSol.mulUpFixed(
    bptTotalSupply,
    MathSol.complementFixed(invariantRatio)
  );
}
function _calcTokenOutGivenExactBptIn(amp, balances, tokenIndex, bptAmountIn, bptTotalSupply, currentInvariant, swapFee) {
  const newInvariant = MathSol.mulUpFixed(
    MathSol.divUpFixed(bptTotalSupply - bptAmountIn, bptTotalSupply),
    currentInvariant
  );
  const newBalanceTokenIndex = _getTokenBalanceGivenInvariantAndAllOtherBalances(
    amp,
    balances,
    newInvariant,
    tokenIndex
  );
  const amountOutWithoutFee = balances[tokenIndex] - newBalanceTokenIndex;
  let sumBalances = 0n;
  for (let i = 0; i < balances.length; i++) {
    sumBalances += balances[i];
  }
  const currentWeight = MathSol.divDownFixed(
    balances[tokenIndex],
    sumBalances
  );
  const taxablePercentage = MathSol.complementFixed(currentWeight);
  const taxableAmount = MathSol.mulUpFixed(
    amountOutWithoutFee,
    taxablePercentage
  );
  const nonTaxableAmount = amountOutWithoutFee - taxableAmount;
  return nonTaxableAmount + MathSol.mulDownFixed(taxableAmount, WAD - swapFee);
}
function _getTokenBalanceGivenInvariantAndAllOtherBalances(amplificationParameter, balances, invariant, tokenIndex) {
  const ampTimesTotal = amplificationParameter * BigInt(balances.length);
  let sum = balances[0];
  let P_D = balances[0] * BigInt(balances.length);
  for (let j = 1; j < balances.length; j++) {
    P_D = P_D * balances[j] * BigInt(balances.length) / invariant;
    sum += balances[j];
  }
  sum = sum - balances[tokenIndex];
  const inv2 = invariant * invariant;
  const c = MathSol.divUp(inv2, ampTimesTotal * P_D) * AMP_PRECISION * balances[tokenIndex];
  const b = sum + invariant / ampTimesTotal * AMP_PRECISION;
  let prevTokenBalance = 0n;
  let tokenBalance = MathSol.divUp(inv2 + c, invariant + b);
  for (let i = 0; i < 255; i++) {
    prevTokenBalance = tokenBalance;
    tokenBalance = MathSol.divUp(
      tokenBalance * tokenBalance + c,
      tokenBalance * 2n + b - invariant
    );
    if (tokenBalance > prevTokenBalance) {
      if (tokenBalance - prevTokenBalance <= 1n) {
        return tokenBalance;
      }
    } else if (prevTokenBalance - tokenBalance <= 1n) {
      return tokenBalance;
    }
  }
  throw new Error("Errors.STABLE_GET_BALANCE_DIDNT_CONVERGE");
}

// src/entities/pools/stable/stablePool.ts
var StablePoolToken = class extends TokenAmount {
  constructor(token, amount, rate, index) {
    super(token, amount);
    __publicField(this, "rate");
    __publicField(this, "index");
    __publicField(this, "scale18");
    this.rate = BigInt(rate);
    this.scale18 = this.amount * this.scalar * this.rate / WAD;
    this.index = index;
  }
  increase(amount) {
    this.amount = this.amount + amount;
    this.scale18 = this.amount * this.scalar * this.rate / WAD;
    return this;
  }
  decrease(amount) {
    this.amount = this.amount - amount;
    this.scale18 = this.amount * this.scalar * this.rate / WAD;
    return this;
  }
};
var StablePool = class {
  constructor(id, amp, swapFee, tokens, totalShares) {
    __publicField(this, "chainId");
    __publicField(this, "id");
    __publicField(this, "address");
    __publicField(this, "poolType", "ComposableStable" /* ComposableStable */);
    __publicField(this, "amp");
    __publicField(this, "swapFee");
    __publicField(this, "bptIndex");
    __publicField(this, "totalShares");
    __publicField(this, "tokens");
    __publicField(this, "tokenMap");
    __publicField(this, "tokenIndexMap");
    this.chainId = tokens[0].token.chainId;
    this.id = id;
    this.address = getPoolAddress(id);
    this.amp = amp;
    this.swapFee = swapFee;
    this.totalShares = totalShares;
    this.tokens = tokens.sort((a, b) => a.index - b.index);
    this.tokenMap = new Map(
      this.tokens.map((token) => [token.token.address, token])
    );
    this.tokenIndexMap = new Map(
      this.tokens.map((token) => [token.token.address, token.index])
    );
    this.bptIndex = this.tokens.findIndex(
      (t) => t.token.address === this.address
    );
  }
  static fromRawPool(chainId, pool) {
    const poolTokens = [];
    for (const t of pool.tokens) {
      if (!t.priceRate)
        throw new Error("Stable pool token does not have a price rate");
      const token = new Token(
        chainId,
        t.address,
        t.decimals,
        t.symbol,
        t.name
      );
      const tokenAmount = TokenAmount.fromHumanAmount(token, t.balance);
      const tokenIndex = _nullishCoalesce(t.index, () => ( pool.tokensList.findIndex((t2) => t2 === token.address)));
      poolTokens.push(
        new StablePoolToken(
          token,
          tokenAmount.amount,
          _viem.parseEther.call(void 0, t.priceRate),
          tokenIndex
        )
      );
    }
    const totalShares = _viem.parseEther.call(void 0, pool.totalShares);
    const amp = _viem.parseUnits.call(void 0, pool.amp, 3);
    return new StablePool(
      pool.id,
      amp,
      _viem.parseEther.call(void 0, pool.swapFee),
      poolTokens,
      totalShares
    );
  }
  getNormalizedLiquidity(tokenIn, tokenOut) {
    const tIn = this.tokenMap.get(tokenIn.wrapped);
    const tOut = this.tokenMap.get(tokenOut.wrapped);
    if (!tIn || !tOut)
      throw new Error("Pool does not contain the tokens provided");
    return tOut.amount * this.amp;
  }
  swapGivenIn(tokenIn, tokenOut, swapAmount, mutateBalances) {
    const tInIndex = this.tokenIndexMap.get(tokenIn.wrapped);
    const tOutIndex = this.tokenIndexMap.get(tokenOut.wrapped);
    if (typeof tInIndex !== "number" || typeof tOutIndex !== "number") {
      throw new Error("Pool does not contain the tokens provided");
    }
    const balancesNoBpt = this.dropBptItem(
      this.tokens.map((t) => t.scale18)
    );
    if (swapAmount.scale18 > this.tokens[tInIndex].scale18) {
      throw new Error("Swap amount exceeds the pool limit");
    }
    const invariant = _calculateInvariant(this.amp, balancesNoBpt);
    let tokenOutScale18;
    if (tokenIn.isUnderlyingEqual(this.tokens[this.bptIndex].token)) {
      const amountInWithRate = swapAmount.mulDownFixed(
        this.tokens[tInIndex].rate
      );
      tokenOutScale18 = _calcTokenOutGivenExactBptIn(
        this.amp,
        [...balancesNoBpt],
        this.skipBptIndex(tOutIndex),
        amountInWithRate.scale18,
        this.totalShares,
        invariant,
        this.swapFee
      );
    } else if (tokenOut.isUnderlyingEqual(this.tokens[this.bptIndex].token)) {
      const amountsIn = new Array(balancesNoBpt.length).fill(0n);
      const amountInWithRate = swapAmount.mulDownFixed(
        this.tokens[tInIndex].rate
      );
      amountsIn[this.skipBptIndex(tInIndex)] = amountInWithRate.scale18;
      tokenOutScale18 = _calcBptOutGivenExactTokensIn(
        this.amp,
        [...balancesNoBpt],
        amountsIn,
        this.totalShares,
        invariant,
        this.swapFee
      );
    } else {
      const amountInWithFee = this.subtractSwapFeeAmount(swapAmount);
      const amountInWithRate = amountInWithFee.mulDownFixed(
        this.tokens[tInIndex].rate
      );
      tokenOutScale18 = _calcOutGivenIn2(
        this.amp,
        [...balancesNoBpt],
        this.skipBptIndex(tInIndex),
        this.skipBptIndex(tOutIndex),
        amountInWithRate.scale18,
        invariant
      );
    }
    const amountOut = TokenAmount.fromScale18Amount(
      tokenOut,
      tokenOutScale18
    );
    const amountOutWithRate = amountOut.divDownFixed(
      this.tokens[tOutIndex].rate
    );
    if (amountOutWithRate.amount < 0n)
      throw new Error("Swap output negative");
    if (mutateBalances) {
      this.tokens[tInIndex].increase(swapAmount.amount);
      this.tokens[tOutIndex].decrease(amountOutWithRate.amount);
      if (tInIndex === this.bptIndex) {
        this.totalShares = this.totalShares - swapAmount.amount;
      } else if (tOutIndex === this.bptIndex) {
        this.totalShares = this.totalShares + amountOutWithRate.amount;
      }
    }
    return amountOutWithRate;
  }
  swapGivenOut(tokenIn, tokenOut, swapAmount, mutateBalances) {
    const tInIndex = this.tokenIndexMap.get(tokenIn.wrapped);
    const tOutIndex = this.tokenIndexMap.get(tokenOut.wrapped);
    if (typeof tInIndex !== "number" || typeof tOutIndex !== "number") {
      throw new Error("Pool does not contain the tokens provided");
    }
    const balancesNoBpt = this.dropBptItem(
      this.tokens.map((t) => t.scale18)
    );
    if (swapAmount.scale18 > this.tokens[tOutIndex].scale18) {
      throw new Error("Swap amount exceeds the pool limit");
    }
    const amountOutWithRate = swapAmount.mulDownFixed(
      this.tokens[tOutIndex].rate
    );
    const invariant = _calculateInvariant(this.amp, balancesNoBpt);
    let amountIn;
    if (tokenIn.isUnderlyingEqual(this.tokens[this.bptIndex].token)) {
      const amountsOut = new Array(balancesNoBpt.length).fill(0n);
      amountsOut[this.skipBptIndex(tOutIndex)] = amountOutWithRate.scale18;
      const tokenInScale18 = _calcBptInGivenExactTokensOut(
        this.amp,
        [...balancesNoBpt],
        amountsOut,
        this.totalShares,
        invariant,
        this.swapFee
      );
      amountIn = TokenAmount.fromScale18Amount(
        tokenIn,
        tokenInScale18,
        true
      ).divDownFixed(this.tokens[tInIndex].rate);
    } else if (tokenOut.isUnderlyingEqual(this.tokens[this.bptIndex].token)) {
      const tokenInScale18 = _calcTokenInGivenExactBptOut(
        this.amp,
        [...balancesNoBpt],
        this.skipBptIndex(tInIndex),
        amountOutWithRate.scale18,
        this.totalShares,
        invariant,
        this.swapFee
      );
      amountIn = TokenAmount.fromScale18Amount(
        tokenIn,
        tokenInScale18,
        true
      ).divDownFixed(this.tokens[tInIndex].rate);
    } else {
      const tokenInScale18 = _calcInGivenOut2(
        this.amp,
        [...balancesNoBpt],
        this.skipBptIndex(tInIndex),
        this.skipBptIndex(tOutIndex),
        amountOutWithRate.scale18,
        invariant
      );
      const amountInWithoutFee = TokenAmount.fromScale18Amount(
        tokenIn,
        tokenInScale18,
        true
      );
      const amountInWithFee = this.addSwapFeeAmount(amountInWithoutFee);
      amountIn = amountInWithFee.divDownFixed(this.tokens[tInIndex].rate);
    }
    if (amountIn.amount < 0n)
      throw new Error("Swap output negative");
    if (mutateBalances) {
      this.tokens[tInIndex].increase(amountIn.amount);
      this.tokens[tOutIndex].decrease(swapAmount.amount);
      if (tInIndex === this.bptIndex) {
        this.totalShares = this.totalShares - amountIn.amount;
      } else if (tOutIndex === this.bptIndex) {
        this.totalShares = this.totalShares + swapAmount.amount;
      }
    }
    return amountIn;
  }
  subtractSwapFeeAmount(amount) {
    const feeAmount = amount.mulUpFixed(this.swapFee);
    return amount.sub(feeAmount);
  }
  addSwapFeeAmount(amount) {
    return amount.divUpFixed(MathSol.complementFixed(this.swapFee));
  }
  getLimitAmountSwap(tokenIn, tokenOut, swapKind) {
    const tIn = this.tokenMap.get(tokenIn.address);
    const tOut = this.tokenMap.get(tokenOut.address);
    if (!tIn || !tOut)
      throw new Error("Pool does not contain the tokens provided");
    if (swapKind === 0 /* GivenIn */) {
      return tIn.amount * WAD / tIn.rate;
    }
    return tOut.amount * WAD / tOut.rate;
  }
  skipBptIndex(index) {
    if (index === this.bptIndex)
      throw new Error("Cannot skip BPT index");
    return index < this.bptIndex ? index : index - 1;
  }
  dropBptItem(amounts) {
    const amountsWithoutBpt = new Array(amounts.length - 1).fill(0n);
    for (let i = 0; i < amountsWithoutBpt.length; i++) {
      amountsWithoutBpt[i] = amounts[i < this.bptIndex ? i : i + 1];
    }
    return amountsWithoutBpt;
  }
};

// src/entities/pools/stable/stableFactory.ts
var StablePoolFactory = class {
  isPoolForFactory(pool) {
    return pool.poolType === "ComposableStable";
  }
  create(chainId, pool) {
    return StablePool.fromRawPool(chainId, pool);
  }
};

// src/entities/pools/metastable/metastablePool.ts

var MetaStablePool = class {
  constructor(id, amp, swapFee, tokens) {
    __publicField(this, "chainId");
    __publicField(this, "id");
    __publicField(this, "address");
    __publicField(this, "poolType", "MetaStable" /* MetaStable */);
    __publicField(this, "amp");
    __publicField(this, "swapFee");
    __publicField(this, "tokens");
    __publicField(this, "tokenMap");
    __publicField(this, "tokenIndexMap");
    this.chainId = tokens[0].token.chainId;
    this.id = id;
    this.address = getPoolAddress(id);
    this.amp = amp;
    this.swapFee = swapFee;
    this.tokens = tokens.sort((a, b) => a.index - b.index);
    this.tokenMap = new Map(
      this.tokens.map((token) => [token.token.address, token])
    );
    this.tokenIndexMap = new Map(
      this.tokens.map((token) => [token.token.address, token.index])
    );
  }
  static fromRawPool(chainId, pool) {
    const poolTokens = [];
    for (const t of pool.tokens) {
      if (!t.priceRate)
        throw new Error(
          "Meta Stable pool token does not have a price rate"
        );
      const token = new Token(
        chainId,
        t.address,
        t.decimals,
        t.symbol,
        t.name
      );
      const tokenAmount = TokenAmount.fromHumanAmount(token, t.balance);
      const tokenIndex = _nullishCoalesce(t.index, () => ( pool.tokensList.findIndex((t2) => t2 === token.address)));
      poolTokens.push(
        new StablePoolToken(
          token,
          tokenAmount.amount,
          _viem.parseEther.call(void 0, t.priceRate),
          tokenIndex
        )
      );
    }
    const amp = BigInt(pool.amp) * 1000n;
    return new MetaStablePool(
      pool.id,
      amp,
      _viem.parseEther.call(void 0, pool.swapFee),
      poolTokens
    );
  }
  getNormalizedLiquidity(tokenIn, tokenOut) {
    const tIn = this.tokenMap.get(tokenIn.address);
    const tOut = this.tokenMap.get(tokenOut.address);
    if (!tIn || !tOut)
      throw new Error("Pool does not contain the tokens provided");
    return tOut.amount * this.amp;
  }
  swapGivenIn(tokenIn, tokenOut, swapAmount, mutateBalances) {
    const tInIndex = this.tokenIndexMap.get(tokenIn.address);
    const tOutIndex = this.tokenIndexMap.get(tokenOut.address);
    if (typeof tInIndex !== "number" || typeof tOutIndex !== "number") {
      throw new Error("Pool does not contain the tokens provided");
    }
    if (swapAmount.amount > this.tokens[tInIndex].amount) {
      throw new Error("Swap amount exceeds the pool limit");
    }
    const amountInWithFee = this.subtractSwapFeeAmount(swapAmount);
    const amountInWithRate = amountInWithFee.mulDownFixed(
      this.tokens[tInIndex].rate
    );
    const balances = this.tokens.map((t) => t.scale18);
    const invariant = _calculateInvariant(this.amp, [...balances], true);
    const tokenOutScale18 = _calcOutGivenIn2(
      this.amp,
      [...balances],
      tInIndex,
      tOutIndex,
      amountInWithRate.scale18,
      invariant
    );
    const amountOut = TokenAmount.fromScale18Amount(
      tokenOut,
      tokenOutScale18
    );
    const amountOutWithRate = amountOut.divDownFixed(
      this.tokens[tOutIndex].rate
    );
    if (amountOutWithRate.amount < 0n)
      throw new Error("Swap output negative");
    if (mutateBalances) {
      this.tokens[tInIndex].increase(swapAmount.amount);
      this.tokens[tOutIndex].decrease(amountOutWithRate.amount);
    }
    return amountOutWithRate;
  }
  swapGivenOut(tokenIn, tokenOut, swapAmount, mutateBalances) {
    const tInIndex = this.tokenIndexMap.get(tokenIn.address);
    const tOutIndex = this.tokenIndexMap.get(tokenOut.address);
    if (typeof tInIndex !== "number" || typeof tOutIndex !== "number") {
      throw new Error("Pool does not contain the tokens provided");
    }
    if (swapAmount.amount > this.tokens[tOutIndex].amount) {
      throw new Error("Swap amount exceeds the pool limit");
    }
    const amountOutWithRate = swapAmount.mulDownFixed(
      this.tokens[tOutIndex].rate
    );
    const balances = this.tokens.map((t) => t.scale18);
    const invariant = _calculateInvariant(this.amp, balances, true);
    const tokenInScale18 = _calcInGivenOut2(
      this.amp,
      [...balances],
      tInIndex,
      tOutIndex,
      amountOutWithRate.scale18,
      invariant
    );
    const amountIn = TokenAmount.fromScale18Amount(
      tokenIn,
      tokenInScale18,
      true
    );
    const amountInWithFee = this.addSwapFeeAmount(amountIn);
    const amountInWithRate = amountInWithFee.divDownFixed(
      this.tokens[tInIndex].rate
    );
    if (amountInWithRate.amount < 0n)
      throw new Error("Swap output negative");
    if (mutateBalances) {
      this.tokens[tInIndex].increase(amountInWithRate.amount);
      this.tokens[tOutIndex].decrease(swapAmount.amount);
    }
    return amountInWithRate;
  }
  subtractSwapFeeAmount(amount) {
    const feeAmount = amount.mulUpFixed(this.swapFee);
    return amount.sub(feeAmount);
  }
  addSwapFeeAmount(amount) {
    return amount.divUpFixed(MathSol.complementFixed(this.swapFee));
  }
  getLimitAmountSwap(tokenIn, tokenOut, swapKind) {
    const tIn = this.tokenMap.get(tokenIn.address);
    const tOut = this.tokenMap.get(tokenOut.address);
    if (!tIn || !tOut)
      throw new Error("Pool does not contain the tokens provided");
    if (swapKind === 0 /* GivenIn */) {
      return tIn.amount * WAD / tIn.rate;
    }
    return tOut.amount * WAD / tOut.rate;
  }
};

// src/entities/pools/metastable/metastableFactory.ts
var MetaStablePoolFactory = class {
  isPoolForFactory(pool) {
    return pool.poolType === "MetaStable";
  }
  create(chainId, pool) {
    return MetaStablePool.fromRawPool(chainId, pool);
  }
};

// src/entities/pools/linear/linearPool.ts


// src/entities/pools/linear/linearMath.ts
function _calcWrappedOutPerMainIn(mainIn, mainBalance, params) {
  const previousNominalMain = _toNominal(mainBalance, params);
  const afterNominalMain = _toNominal(mainBalance + mainIn, params);
  return afterNominalMain - previousNominalMain;
}
function _calcBptOutPerMainIn(mainIn, mainBalance, wrappedBalance, bptSupply, params) {
  if (bptSupply === 0n) {
    return _toNominal(mainIn, params);
  }
  const previousNominalMain = _toNominal(mainBalance, params);
  const afterNominalMain = _toNominal(mainBalance + mainIn, params);
  const deltaNominalMain = afterNominalMain - previousNominalMain;
  const invariant = _calcInvariant(previousNominalMain, wrappedBalance);
  return bptSupply * deltaNominalMain / invariant;
}
function _calcMainOutPerWrappedIn(wrappedIn, mainBalance, params) {
  const previousNominalMain = _toNominal(mainBalance, params);
  const afterNominalMain = previousNominalMain - wrappedIn;
  const newMainBalance = _fromNominal(afterNominalMain, params);
  return mainBalance - newMainBalance;
}
function _calcBptOutPerWrappedIn(wrappedIn, mainBalance, wrappedBalance, bptSupply, params) {
  if (bptSupply === 0n) {
    return wrappedIn;
  }
  const nominalMain = _toNominal(mainBalance, params);
  const previousInvariant = _calcInvariant(nominalMain, wrappedBalance);
  const newWrappedBalance = wrappedBalance + wrappedIn;
  const newInvariant = _calcInvariant(nominalMain, newWrappedBalance);
  const newBptBalance = bptSupply * newInvariant / previousInvariant;
  return newBptBalance - bptSupply;
}
function _calcMainOutPerBptIn(bptIn, mainBalance, wrappedBalance, bptSupply, params) {
  const previousNominalMain = _toNominal(mainBalance, params);
  const invariant = _calcInvariant(previousNominalMain, wrappedBalance);
  const deltaNominalMain = invariant * bptIn / bptSupply;
  const afterNominalMain = previousNominalMain - deltaNominalMain;
  const newMainBalance = _fromNominal(afterNominalMain, params);
  return mainBalance - newMainBalance;
}
function _calcWrappedOutPerBptIn(bptIn, mainBalance, wrappedBalance, bptSupply, params) {
  const nominalMain = _toNominal(mainBalance, params);
  const previousInvariant = _calcInvariant(nominalMain, wrappedBalance);
  const newBptBalance = bptSupply - bptIn;
  const newWrappedBalance = newBptBalance * previousInvariant / bptSupply - nominalMain;
  return wrappedBalance - newWrappedBalance;
}
function _calcMainInPerWrappedOut(wrappedOut, mainBalance, params) {
  const previousNominalMain = _toNominal(mainBalance, params);
  const afterNominalMain = previousNominalMain + wrappedOut;
  const newMainBalance = _fromNominal(afterNominalMain, params);
  return newMainBalance - mainBalance;
}
function _calcMainInPerBptOut(bptOut, mainBalance, wrappedBalance, bptSupply, params) {
  if (bptSupply === 0n) {
    return _fromNominal(bptOut, params);
  }
  const previousNominalMain = _toNominal(mainBalance, params);
  const invariant = _calcInvariant(previousNominalMain, wrappedBalance);
  const deltaNominalMain = invariant * bptOut / bptSupply;
  const afterNominalMain = previousNominalMain + deltaNominalMain;
  const newMainBalance = _fromNominal(afterNominalMain, params);
  return newMainBalance - mainBalance;
}
function _calcWrappedInPerMainOut(mainOut, mainBalance, params) {
  const previousNominalMain = _toNominal(mainBalance, params);
  const afterNominalMain = _toNominal(mainBalance - mainOut, params);
  return previousNominalMain - afterNominalMain;
}
function _calcWrappedInPerBptOut(bptOut, mainBalance, wrappedBalance, bptSupply, params) {
  if (bptSupply === 0n) {
    return bptOut;
  }
  const nominalMain = _toNominal(mainBalance, params);
  const previousInvariant = _calcInvariant(nominalMain, wrappedBalance);
  const newBptBalance = bptSupply + bptOut;
  const newWrappedBalance = newBptBalance * previousInvariant / bptSupply - nominalMain;
  return newWrappedBalance - wrappedBalance;
}
function _calcBptInPerWrappedOut(wrappedOut, mainBalance, wrappedBalance, bptSupply, params) {
  const nominalMain = _toNominal(mainBalance, params);
  const previousInvariant = _calcInvariant(nominalMain, wrappedBalance);
  const newWrappedBalance = wrappedBalance - wrappedOut;
  const newInvariant = _calcInvariant(nominalMain, newWrappedBalance);
  const newBptBalance = bptSupply * newInvariant / previousInvariant;
  return bptSupply - newBptBalance;
}
function _calcBptInPerMainOut(mainOut, mainBalance, wrappedBalance, bptSupply, params) {
  const previousNominalMain = _toNominal(mainBalance, params);
  const afterNominalMain = _toNominal(mainBalance - mainOut, params);
  const deltaNominalMain = previousNominalMain - afterNominalMain;
  const invariant = _calcInvariant(previousNominalMain, wrappedBalance);
  return bptSupply * deltaNominalMain / invariant;
}
function _calcInvariant(nominalMainBalance, wrappedBalance) {
  return nominalMainBalance + wrappedBalance;
}
function _toNominal(real, params) {
  if (real < params.lowerTarget) {
    const fees2 = MathSol.mulDownFixed(
      params.lowerTarget - real,
      params.fee
    );
    return real - fees2;
  }
  if (real <= params.upperTarget) {
    return real;
  }
  const fees = MathSol.mulDownFixed(real - params.upperTarget, params.fee);
  return real - fees;
}
function _fromNominal(nominal, params) {
  if (nominal < params.lowerTarget) {
    return MathSol.divDownFixed(
      nominal + MathSol.mulDownFixed(params.fee, params.lowerTarget),
      WAD + params.fee
    );
  }
  if (nominal <= params.upperTarget) {
    return nominal;
  }
  return MathSol.divDownFixed(
    nominal - MathSol.mulDownFixed(params.fee, params.upperTarget),
    WAD - params.fee
  );
}

// src/entities/pools/linear/linearPool.ts
var MAX_RATIO = _viem.parseEther.call(void 0, "10");
var MAX_TOKEN_BALANCE = MAX_UINT112 - 1n;
var BPT = class extends TokenAmount {
  constructor(token, amount, index) {
    super(token, amount);
    __publicField(this, "rate");
    __publicField(this, "index");
    __publicField(this, "virtualBalance");
    this.rate = WAD;
    this.virtualBalance = MAX_TOKEN_BALANCE - this.amount;
    this.index = index;
  }
  increase(amount) {
    this.amount = this.amount + amount;
    this.virtualBalance = this.virtualBalance + amount;
    this.scale18 = this.amount * this.scalar;
    return this;
  }
  decrease(amount) {
    this.amount = this.amount - amount;
    this.virtualBalance = this.virtualBalance - amount;
    this.scale18 = this.amount * this.scalar;
    return this;
  }
};
var LinearPool = class {
  constructor(id, poolTypeVersion, params, mainToken, wrappedToken, bptToken) {
    __publicField(this, "chainId");
    __publicField(this, "id");
    __publicField(this, "address");
    __publicField(this, "poolType", "AaveLinear" /* AaveLinear */);
    __publicField(this, "poolTypeVersion");
    __publicField(this, "swapFee");
    __publicField(this, "mainToken");
    __publicField(this, "wrappedToken");
    __publicField(this, "bptToken");
    __publicField(this, "params");
    __publicField(this, "tokens");
    __publicField(this, "tokenMap");
    this.chainId = mainToken.token.chainId;
    this.id = id;
    this.poolTypeVersion = poolTypeVersion;
    this.swapFee = params.fee;
    this.mainToken = mainToken;
    this.wrappedToken = wrappedToken;
    this.bptToken = bptToken;
    this.address = getPoolAddress(id);
    this.params = params;
    this.tokens = [this.mainToken, this.wrappedToken, this.bptToken];
    this.tokenMap = new Map(
      this.tokens.map((token) => [token.token.address, token])
    );
  }
  static fromRawPool(chainId, pool) {
    const orderedTokens = pool.tokens.sort((a, b) => a.index - b.index);
    const swapFee = _viem.parseEther.call(void 0, pool.swapFee);
    const mT = orderedTokens[pool.mainIndex];
    const mTRate = _viem.parseEther.call(void 0, mT.priceRate || "1.0");
    const mToken = new Token(
      chainId,
      mT.address,
      mT.decimals,
      mT.symbol,
      mT.name
    );
    const lowerTarget = TokenAmount.fromHumanAmount(
      mToken,
      pool.lowerTarget
    );
    const upperTarget = TokenAmount.fromHumanAmount(
      mToken,
      pool.upperTarget
    );
    const mTokenAmount = TokenAmount.fromHumanAmount(mToken, mT.balance);
    const mainToken = new StablePoolToken(
      mToken,
      mTokenAmount.amount,
      mTRate,
      mT.index
    );
    const wT = orderedTokens[pool.wrappedIndex];
    const wTRate = _viem.parseEther.call(void 0, wT.priceRate || "1.0");
    const wToken = new Token(
      chainId,
      wT.address,
      wT.decimals,
      wT.symbol,
      wT.name
    );
    const wTokenAmount = TokenAmount.fromHumanAmount(wToken, wT.balance);
    const wrappedToken = new StablePoolToken(
      wToken,
      wTokenAmount.amount,
      wTRate,
      wT.index
    );
    const bptIndex = orderedTokens.findIndex(
      (t) => t.address === pool.address
    );
    const bT = orderedTokens[bptIndex];
    const bToken = new Token(
      chainId,
      bT.address,
      bT.decimals,
      bT.symbol,
      bT.name
    );
    const bTokenAmount = TokenAmount.fromHumanAmount(bToken, bT.balance);
    const bptToken = new BPT(bToken, bTokenAmount.amount, bT.index);
    const params = {
      fee: swapFee,
      rate: wTRate,
      lowerTarget: lowerTarget.scale18,
      upperTarget: upperTarget.scale18
    };
    return new LinearPool(
      pool.id,
      pool.poolTypeVersion,
      params,
      mainToken,
      wrappedToken,
      bptToken
    );
  }
  getNormalizedLiquidity(tokenIn, tokenOut) {
    const tIn = this.tokenMap.get(tokenIn.wrapped);
    const tOut = this.tokenMap.get(tokenOut.wrapped);
    if (!tIn || !tOut)
      throw new Error("Pool does not contain the tokens provided");
    return tOut.amount;
  }
  swapGivenIn(tokenIn, tokenOut, swapAmount, mutateBalances) {
    const { tIn, tOut } = this.getRequiredTokenPair(tokenIn, tokenOut);
    let _swapAmount = swapAmount;
    let output;
    if (tokenIn.isEqual(this.mainToken.token)) {
      if (tokenOut.isEqual(this.wrappedToken.token)) {
        output = this._exactMainTokenInForWrappedOut(_swapAmount);
        output = output.divDownFixed(this.wrappedToken.rate);
      } else {
        output = this._exactMainTokenInForBptOut(_swapAmount);
      }
    } else if (tokenIn.isEqual(this.wrappedToken.token)) {
      _swapAmount = _swapAmount.mulDownFixed(this.wrappedToken.rate);
      if (tokenOut.isEqual(this.mainToken.token)) {
        output = this._exactWrappedTokenInForMainOut(_swapAmount);
      } else {
        output = this._exactWrappedTokenInForBptOut(_swapAmount);
      }
    } else if (tokenIn.isEqual(this.bptToken.token)) {
      if (tokenOut.isEqual(this.mainToken.token)) {
        output = this._exactBptInForMainOut(_swapAmount);
      } else {
        output = this._exactBptInForWrappedOut(_swapAmount);
        output = output.divDownFixed(this.wrappedToken.rate);
      }
    } else {
      throw new Error("Pool does not contain the tokens provided");
    }
    if (output.amount > (_optionalChain([tOut, 'optionalAccess', _54 => _54.amount]) || 0n)) {
      throw new Error("Swap amount exceeds the pool limit");
    }
    if (output.amount < 0n)
      throw new Error("Swap amount is negative");
    if (mutateBalances) {
      tIn.increase(_swapAmount.amount);
      tOut.decrease(output.amount);
    }
    return output;
  }
  swapGivenOut(tokenIn, tokenOut, swapAmount, mutateBalances) {
    const { tIn, tOut } = this.getRequiredTokenPair(tokenIn, tokenOut);
    if (swapAmount.amount > (_optionalChain([tOut, 'optionalAccess', _55 => _55.amount]) || 0n)) {
      throw new Error("Swap amount exceeds the pool limit");
    }
    let _swapAmount = swapAmount;
    let input;
    if (tokenIn.isEqual(this.mainToken.token)) {
      if (tokenOut.isEqual(this.wrappedToken.token)) {
        _swapAmount = _swapAmount.mulDownFixed(this.wrappedToken.rate);
        input = this._mainTokenInForExactWrappedOut(_swapAmount);
      } else {
        input = this._mainTokenInForExactBptOut(_swapAmount);
      }
    } else if (tokenIn.isEqual(this.wrappedToken.token)) {
      if (tokenOut.isEqual(this.mainToken.token)) {
        input = this._wrappedTokenInForExactMainOut(_swapAmount);
      } else {
        input = this._wrappedTokenInForExactBptOut(_swapAmount);
      }
      input = input.mulDownFixed(this.wrappedToken.rate);
    } else if (tokenIn.isEqual(this.bptToken.token)) {
      if (tokenOut.isEqual(this.mainToken.token)) {
        input = this._bptInForExactMainOut(_swapAmount);
      } else {
        _swapAmount = _swapAmount.mulDownFixed(this.wrappedToken.rate);
        input = this._bptInForExactWrappedOut(_swapAmount);
      }
    } else {
      throw new Error("Pool does not contain the tokens provided");
    }
    if (input.amount < 0n)
      throw new Error("Swap amount is negative");
    if (mutateBalances) {
      tIn.increase(input.amount);
      tOut.decrease(_swapAmount.amount);
    }
    return input;
  }
  getLimitAmountSwap(tokenIn, tokenOut, swapKind) {
    const tIn = this.tokenMap.get(tokenIn.wrapped);
    const tOut = this.tokenMap.get(tokenOut.wrapped);
    if (!tIn || !tOut)
      throw new Error("Pool does not contain the tokens provided");
    if (swapKind === 0 /* GivenIn */) {
      if (tokenOut.isEqual(this.bptToken.token)) {
        return MAX_TOKEN_BALANCE;
      }
      const amount = TokenAmount.fromRawAmount(tokenOut, tOut.amount);
      return this.swapGivenOut(tokenIn, tokenOut, amount).amount;
    }
    if (tokenOut.isEqual(this.bptToken.token)) {
      return tOut.amount * MAX_RATIO / WAD;
    }
    return tOut.amount;
  }
  _exactMainTokenInForWrappedOut(swapAmount) {
    const tokenOutScale18 = _calcWrappedOutPerMainIn(
      swapAmount.scale18,
      this.mainToken.scale18,
      this.params
    );
    return TokenAmount.fromScale18Amount(
      this.wrappedToken.token,
      tokenOutScale18
    );
  }
  _exactMainTokenInForBptOut(swapAmount) {
    const tokenOutScale18 = _calcBptOutPerMainIn(
      swapAmount.scale18,
      this.mainToken.scale18,
      this.wrappedToken.scale18,
      this.bptToken.virtualBalance,
      this.params
    );
    return TokenAmount.fromScale18Amount(
      this.bptToken.token,
      tokenOutScale18
    );
  }
  _exactWrappedTokenInForMainOut(swapAmount) {
    const tokenOutScale18 = _calcMainOutPerWrappedIn(
      swapAmount.scale18,
      this.mainToken.scale18,
      this.params
    );
    return TokenAmount.fromScale18Amount(
      this.mainToken.token,
      tokenOutScale18
    );
  }
  _exactWrappedTokenInForBptOut(swapAmount) {
    const tokenOutScale18 = _calcBptOutPerWrappedIn(
      swapAmount.scale18,
      this.mainToken.scale18,
      this.wrappedToken.scale18,
      this.bptToken.virtualBalance,
      this.params
    );
    return TokenAmount.fromScale18Amount(
      this.bptToken.token,
      tokenOutScale18
    );
  }
  _exactBptInForMainOut(swapAmount) {
    const tokenOutScale18 = _calcMainOutPerBptIn(
      swapAmount.scale18,
      this.mainToken.scale18,
      this.wrappedToken.scale18,
      this.bptToken.virtualBalance,
      this.params
    );
    return TokenAmount.fromScale18Amount(
      this.mainToken.token,
      tokenOutScale18
    );
  }
  _exactBptInForWrappedOut(swapAmount) {
    const tokenOutScale18 = _calcWrappedOutPerBptIn(
      swapAmount.scale18,
      this.mainToken.scale18,
      this.wrappedToken.scale18,
      this.bptToken.virtualBalance,
      this.params
    );
    return TokenAmount.fromScale18Amount(
      this.wrappedToken.token,
      tokenOutScale18
    );
  }
  _mainTokenInForExactWrappedOut(swapAmount) {
    const tokenOutScale18 = _calcMainInPerWrappedOut(
      swapAmount.scale18,
      this.mainToken.scale18,
      this.params
    );
    return TokenAmount.fromScale18Amount(
      this.mainToken.token,
      tokenOutScale18,
      true
    );
  }
  _mainTokenInForExactBptOut(swapAmount) {
    const tokenOutScale18 = _calcMainInPerBptOut(
      swapAmount.scale18,
      this.mainToken.scale18,
      this.wrappedToken.scale18,
      this.bptToken.virtualBalance,
      this.params
    );
    return TokenAmount.fromScale18Amount(
      this.mainToken.token,
      tokenOutScale18,
      true
    );
  }
  _wrappedTokenInForExactMainOut(swapAmount) {
    const tokenOutScale18 = _calcWrappedInPerMainOut(
      swapAmount.scale18,
      this.mainToken.scale18,
      this.params
    );
    return TokenAmount.fromScale18Amount(
      this.wrappedToken.token,
      tokenOutScale18,
      true
    );
  }
  _wrappedTokenInForExactBptOut(swapAmount) {
    const tokenOutScale18 = _calcWrappedInPerBptOut(
      swapAmount.scale18,
      this.mainToken.scale18,
      this.wrappedToken.scale18,
      this.bptToken.virtualBalance,
      this.params
    );
    return TokenAmount.fromScale18Amount(
      this.wrappedToken.token,
      tokenOutScale18,
      true
    );
  }
  _bptInForExactMainOut(swapAmount) {
    const tokenOutScale18 = _calcBptInPerMainOut(
      swapAmount.scale18,
      this.mainToken.scale18,
      this.wrappedToken.scale18,
      this.bptToken.virtualBalance,
      this.params
    );
    return TokenAmount.fromScale18Amount(
      this.bptToken.token,
      tokenOutScale18,
      true
    );
  }
  _bptInForExactWrappedOut(swapAmount) {
    const tokenOutScale18 = _calcBptInPerWrappedOut(
      swapAmount.scale18,
      this.mainToken.scale18,
      this.wrappedToken.scale18,
      this.bptToken.virtualBalance,
      this.params
    );
    return TokenAmount.fromScale18Amount(
      this.bptToken.token,
      tokenOutScale18,
      true
    );
  }
  getRequiredTokenPair(tokenIn, tokenOut) {
    const tIn = this.tokenMap.get(tokenIn.wrapped);
    const tOut = this.tokenMap.get(tokenOut.wrapped);
    if (!tIn || !tOut) {
      throw new Error("Pool does not contain the tokens provided");
    }
    return { tIn, tOut };
  }
};

// src/entities/pools/linear/linearFactory.ts
var LinearPoolFactory = class {
  isPoolForFactory(pool) {
    return pool.poolType.includes("Linear");
  }
  create(chainId, pool) {
    return LinearPool.fromRawPool(chainId, pool);
  }
};

// src/entities/pools/fx/fxPool.ts


// src/entities/pools/fx/fxMath.ts

var CURVEMATH_MAX_DIFF = _viem.parseUnits.call(void 0, "-0.000001000000000000024", 36);
var ONE_TO_THE_THIRTEEN_NUM = _viem.parseUnits.call(void 0, "10000000000000", 36);
var CURVEMATH_MAX = _viem.parseUnits.call(void 0, "0.25", 36);
function _calcOutGivenIn3(poolPairData) {
  const _amt = calculateTrade(poolPairData);
  if (_amt === void 0)
    throw new Error("CannotSwap" /* CannotSwap */);
  let amountOut = _amt[0];
  amountOut = amountOut < 0n ? amountOut * -1n : amountOut;
  return amountOut;
}
function _calcInGivenOut3(poolPairData) {
  const _amt = calculateTrade(poolPairData);
  if (_amt === void 0)
    throw new Error("CannotSwap" /* CannotSwap */);
  let amountIn = _amt[0];
  amountIn = amountIn < 0n ? amountIn * -1n : amountIn;
  return amountIn;
}
var calculateMicroFee = (_bal, _ideal, _beta, _delta) => {
  let _threshold;
  let _feeMargin;
  let fee_ = 0n;
  if (_bal < _ideal) {
    _threshold = _ideal * (RAY - _beta) / RAY;
    if (_bal < _threshold) {
      _feeMargin = _threshold - _bal;
      fee_ = _feeMargin * RAY / _ideal;
      fee_ = fee_ * _delta / RAY;
      if (fee_ > CURVEMATH_MAX) {
        fee_ = CURVEMATH_MAX;
      }
      fee_ = fee_ * _feeMargin / RAY;
    } else {
      fee_ = 0n;
    }
  } else {
    _threshold = _ideal * (_beta + RAY) / RAY;
    if (_bal > _threshold) {
      _feeMargin = _bal - _threshold;
      fee_ = _feeMargin * RAY / _ideal;
      fee_ = fee_ * _delta / RAY;
      if (fee_ > CURVEMATH_MAX)
        fee_ = CURVEMATH_MAX;
      fee_ = fee_ * _feeMargin / RAY;
    } else {
      fee_ = 0n;
    }
  }
  return fee_;
};
var calculateFee = (_gLiq, _bals, _beta, _delta, _weights) => {
  const _length = _bals.length;
  let psi = 0n;
  for (let i = 0; i < _length; i++) {
    const _ideal = _gLiq * _weights[i] / RAY;
    psi = psi + calculateMicroFee(_bals[i], _ideal, _beta, _delta);
  }
  return psi;
};
var calculateTrade = (poolPairData) => {
  const {
    alpha,
    beta,
    delta,
    lambda,
    _oGLiq,
    _nGLiq,
    _oBals,
    _nBals,
    givenToken,
    swapKind
  } = poolPairData;
  const weights_ = [RAY / 2n, RAY / 2n];
  const omega = calculateFee(_oGLiq, _oBals, beta, delta, weights_);
  const _outputIndex = givenToken.index === 0 ? 1 : 0;
  const _inputAmt = swapKind === 0 /* GivenIn */ ? givenToken.numeraire : givenToken.numeraire * -1n;
  let outputAmt_ = _inputAmt * -1n;
  let _nGLiq_ = _nGLiq;
  let psi;
  for (let i = 0; i < 32; i++) {
    psi = calculateFee(_nGLiq_, _nBals, beta, delta, weights_);
    const prevAmount = outputAmt_;
    outputAmt_ = omega < psi ? (_inputAmt + (omega - psi)) * -1n : (_inputAmt + lambda * (omega - psi) / RAY) * -1n;
    if (outputAmt_ * RAY / ONE_TO_THE_THIRTEEN_NUM === prevAmount * RAY / ONE_TO_THE_THIRTEEN_NUM) {
      _nGLiq_ = _oGLiq + _inputAmt + outputAmt_;
      _nBals[_outputIndex] = _oBals[_outputIndex] + outputAmt_;
      enforceHalts(_oGLiq, _nGLiq_, _oBals, _nBals, weights_, alpha);
      enforceSwapInvariant(_oGLiq, omega, _nGLiq_, psi);
      return [outputAmt_, _nGLiq_];
    }
    _nGLiq_ = _oGLiq + _inputAmt + outputAmt_;
    _nBals[_outputIndex] = _oBals[_outputIndex] + outputAmt_;
  }
  throw new Error("CurveMath/swap-convergence-failed" /* SwapConvergenceFailed */);
};
var enforceHalts = (_oGLiq, _nGLiq, _oBals, _nBals, _weights, alpha) => {
  const _length = _nBals.length;
  for (let i = 0; i < _length; i++) {
    const _nIdeal = _nGLiq * _weights[i] / RAY;
    if (_nBals[i] > _nIdeal) {
      const _upperAlpha = alpha + RAY;
      const _nHalt = _nIdeal * _upperAlpha / RAY;
      if (_nBals[i] > _nHalt) {
        const _oHalt = _oGLiq * _weights[i] / RAY * _upperAlpha / RAY;
        if (_oBals[i] < _oHalt) {
          throw new Error("CurveMath/upper-halt" /* UpperHalt */);
        }
        if (_nBals[i] - _nHalt > _oBals[i] - _oHalt) {
          throw new Error("CurveMath/upper-halt" /* UpperHalt */);
        }
      }
    } else {
      const _lowerAlpha = RAY - alpha;
      const _nHalt = _nIdeal * _lowerAlpha / RAY;
      if (_nBals[i] < _nHalt) {
        let _oHalt = _oGLiq * _weights[i] / RAY;
        _oHalt = _oHalt * _lowerAlpha / RAY;
        if (_oBals[i] > _oHalt) {
          throw new Error("CurveMath/lower-halt" /* LowerHalt */);
        }
        if (_nHalt - _nBals[i] > _oHalt - _oBals[i]) {
          throw new Error("CurveMath/lower-halt" /* LowerHalt */);
        }
      }
    }
  }
  return true;
};
var enforceSwapInvariant = (_oGLiq, _omega, _nGLiq, _psi) => {
  const _nextUtil = _nGLiq - _psi;
  const _prevUtil = _oGLiq - _omega;
  const _diff = _nextUtil - _prevUtil;
  if (_diff > 0 || _diff >= CURVEMATH_MAX_DIFF) {
    return true;
  }
  throw new Error("CurveMath/swap-invariant-violation" /* SwapInvariantViolation */);
};

// src/entities/pools/fx/helpers.ts

var MathFx = class {
  static mulDownFixed(a, b, decimals = 36) {
    const product = a * b;
    return product / 10n ** BigInt(decimals);
  }
  static mulUpFixed(a, b, decimals = 36) {
    const product = a * b;
    if (product === 0n) {
      return 0n;
    }
    return (product - 1n) / 10n ** BigInt(decimals) + 1n;
  }
  static divDownFixed(a, b, decimals = 36) {
    if (a === 0n) {
      return 0n;
    }
    const aInflated = a * 10n ** BigInt(decimals);
    return aInflated / b;
  }
  static divUpFixed(a, b, decimals = 36) {
    if (a === 0n) {
      return 0n;
    }
    const aInflated = a * 10n ** BigInt(decimals);
    return (aInflated - 1n) / b + 1n;
  }
};
var parseFixedCurveParam = (param) => {
  const param64 = (BigInt(_viem.parseUnits.call(void 0, param, 18)) + 1n << 64n) / 10n ** 18n * 10n ** 36n >> 64n;
  const truncatedParam64 = (param64 / 10n ** 15n + 1n) * 10n ** 15n;
  return truncatedParam64;
};

// src/entities/pools/fx/fxPoolToken.ts

var FxPoolToken = class extends TokenAmount {
  constructor(token, amount, latestFXPrice, fxOracleDecimals, index) {
    super(token, amount);
    __publicField(this, "index");
    __publicField(this, "latestFXPrice");
    __publicField(this, "fxOracleDecimals");
    __publicField(this, "numeraire");
    // in 36 decimals
    __publicField(this, "scalar36", this.scalar * WAD);
    this.latestFXPrice = latestFXPrice;
    this.fxOracleDecimals = fxOracleDecimals;
    const truncatedNumeraire = MathFx.mulDownFixed(
      this.amount,
      _viem.parseUnits.call(void 0, this.latestFXPrice, this.fxOracleDecimals),
      this.fxOracleDecimals
    );
    this.numeraire = truncatedNumeraire * this.scalar36;
    this.index = index;
  }
  increase(amount) {
    this.amount = this.amount + amount;
    this.scale18 = this.amount * this.scalar;
    const truncatedNumeraire = MathFx.mulDownFixed(
      this.amount,
      _viem.parseUnits.call(void 0, this.latestFXPrice, this.fxOracleDecimals),
      this.fxOracleDecimals
    );
    this.numeraire = truncatedNumeraire * this.scalar36;
    return this;
  }
  decrease(amount) {
    this.amount = this.amount - amount;
    this.scale18 = this.amount * this.scalar;
    const truncatedNumeraire = MathFx.mulDownFixed(
      this.amount,
      _viem.parseUnits.call(void 0, this.latestFXPrice, this.fxOracleDecimals),
      this.fxOracleDecimals
    );
    this.numeraire = truncatedNumeraire * this.scalar36;
    return this;
  }
  static fromNumeraire(poolToken, numeraire, divUp) {
    const truncatedNumeraire = BigInt(numeraire) / poolToken.scalar36;
    const amount = divUp ? MathFx.divUpFixed(
      BigInt(truncatedNumeraire),
      _viem.parseUnits.call(void 0, 
        poolToken.latestFXPrice,
        poolToken.fxOracleDecimals
      ),
      poolToken.fxOracleDecimals
    ) : MathFx.divDownFixed(
      BigInt(truncatedNumeraire),
      _viem.parseUnits.call(void 0, 
        poolToken.latestFXPrice,
        poolToken.fxOracleDecimals
      ),
      poolToken.fxOracleDecimals
    );
    return new FxPoolToken(
      poolToken.token,
      amount,
      poolToken.latestFXPrice,
      poolToken.fxOracleDecimals,
      poolToken.index
    );
  }
};

// src/entities/pools/fx/fxPool.ts
var isUSDC = (address) => {
  return address.toLowerCase() === "0x2791bca1f2de4661ed88a30c99a7a9449aa84174" || address.toLowerCase() === "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48";
};
var FxPool = class {
  constructor(id, poolTypeVersion, swapFee, alpha, beta, lambda, delta, epsilon, tokens) {
    __publicField(this, "chainId");
    __publicField(this, "id");
    __publicField(this, "address");
    __publicField(this, "poolType", "FX" /* Fx */);
    __publicField(this, "poolTypeVersion");
    __publicField(this, "swapFee");
    __publicField(this, "alpha");
    __publicField(this, "beta");
    __publicField(this, "lambda");
    __publicField(this, "delta");
    __publicField(this, "epsilon");
    __publicField(this, "tokens");
    __publicField(this, "tokenMap");
    this.chainId = tokens[0].token.chainId;
    this.id = id;
    this.poolTypeVersion = poolTypeVersion;
    this.swapFee = swapFee;
    this.alpha = alpha;
    this.beta = beta;
    this.lambda = lambda;
    this.delta = delta;
    this.epsilon = epsilon;
    this.address = getPoolAddress(id);
    this.tokens = tokens;
    this.tokenMap = new Map(
      this.tokens.map((token) => [token.token.address, token])
    );
  }
  static fromRawPool(chainId, pool) {
    const poolTokens = [];
    for (const t of pool.tokens) {
      if (!t.token.latestFXPrice) {
        throw new Error("FX pool token does not have latestFXPrice");
      }
      const token = new Token(
        chainId,
        t.address,
        t.decimals,
        t.symbol,
        t.name
      );
      const tokenAmount = TokenAmount.fromHumanAmount(token, t.balance);
      poolTokens.push(
        new FxPoolToken(
          token,
          tokenAmount.amount,
          t.token.latestFXPrice,
          t.token.fxOracleDecimals || 8,
          t.index
        )
      );
    }
    return new FxPool(
      pool.id,
      pool.poolTypeVersion,
      _viem.parseEther.call(void 0, pool.swapFee),
      parseFixedCurveParam(pool.alpha),
      parseFixedCurveParam(pool.beta),
      parseFixedCurveParam(pool.lambda),
      _viem.parseUnits.call(void 0, pool.delta, 36),
      parseFixedCurveParam(pool.epsilon),
      poolTokens
    );
  }
  getNormalizedLiquidity(tokenIn, tokenOut) {
    const tIn = this.tokenMap.get(tokenIn.wrapped);
    const tOut = this.tokenMap.get(tokenOut.wrapped);
    if (!tIn || !tOut)
      throw new Error("Pool does not contain the tokens provided");
    return tOut.amount;
  }
  swapGivenIn(tokenIn, tokenOut, swapAmount, mutateBalances) {
    const poolPairData = this.getPoolPairData(
      tokenIn,
      tokenOut,
      swapAmount.amount,
      0 /* GivenIn */
    );
    if (poolPairData.tIn === poolPairData.tOut)
      return poolPairData.tIn;
    const amountOutNumeraire = _calcOutGivenIn3(poolPairData);
    const amountOutNumeraireLessFee = MathFx.mulDownFixed(
      amountOutNumeraire,
      RAY - this.epsilon
    );
    const fxAmountOut = FxPoolToken.fromNumeraire(
      poolPairData.tOut,
      amountOutNumeraireLessFee
    );
    const amountOut = TokenAmount.fromRawAmount(
      fxAmountOut.token,
      fxAmountOut.amount
    );
    if (mutateBalances) {
      poolPairData.tIn.increase(swapAmount.amount);
      poolPairData.tOut.decrease(amountOut.amount);
    }
    return amountOut;
  }
  swapGivenOut(tokenIn, tokenOut, swapAmount, mutateBalances) {
    const poolPairData = this.getPoolPairData(
      tokenIn,
      tokenOut,
      swapAmount.amount,
      1 /* GivenOut */
    );
    if (poolPairData.tIn === poolPairData.tOut)
      return poolPairData.tOut;
    const amountInNumeraire = _calcInGivenOut3(poolPairData);
    const amountInNumeraireWithFee = MathFx.mulDownFixed(
      amountInNumeraire,
      RAY + this.epsilon
    );
    const fxAmountIn = FxPoolToken.fromNumeraire(
      poolPairData.tIn,
      amountInNumeraireWithFee
    );
    const amountIn = TokenAmount.fromRawAmount(
      fxAmountIn.token,
      fxAmountIn.amount
    );
    if (mutateBalances) {
      poolPairData.tIn.decrease(amountIn.amount);
      poolPairData.tOut.increase(swapAmount.amount);
    }
    return amountIn;
  }
  /**
   * Fx pool logic has an alpha region where it halts swaps.
   * maxLimit  = [(1 + alpha) * oGLiq * 0.5] - token liquidity
   */
  getLimitAmountSwap(tokenIn, tokenOut, swapKind) {
    const { _oGLiq, tIn, tOut } = this.getPoolPairData(
      tokenIn,
      tokenOut,
      0n,
      swapKind
    );
    const maxLimit = MathFx.mulDownFixed(this.alpha + RAY, _oGLiq) / 2n;
    if (swapKind === 0 /* GivenIn */) {
      const maxAmount2 = maxLimit - tIn.numeraire;
      return FxPoolToken.fromNumeraire(tIn, maxAmount2).amount;
    }
    const maxAmount = maxLimit - tOut.numeraire;
    return FxPoolToken.fromNumeraire(tOut, maxAmount).amount;
  }
  getPoolPairData(tokenIn, tokenOut, swapAmount, swapKind) {
    const tIn = this.tokenMap.get(tokenIn.address);
    const tOut = this.tokenMap.get(tokenOut.address);
    if (!tIn || !tOut) {
      throw new Error("Token not found");
    }
    const usdcToken = isUSDC(tokenIn.address) ? tIn : tOut;
    const baseToken = isUSDC(tokenIn.address) ? tOut : tIn;
    const givenToken = swapKind === 0 /* GivenIn */ ? new FxPoolToken(
      tIn.token,
      swapAmount,
      tIn.latestFXPrice,
      tIn.fxOracleDecimals,
      tIn.index
    ) : new FxPoolToken(
      tOut.token,
      swapAmount,
      tOut.latestFXPrice,
      tOut.fxOracleDecimals,
      tOut.index
    );
    return {
      tIn,
      tOut,
      alpha: this.alpha,
      beta: this.beta,
      delta: this.delta,
      lambda: this.lambda,
      _oGLiq: baseToken.numeraire + usdcToken.numeraire,
      _nGLiq: baseToken.numeraire + usdcToken.numeraire,
      _oBals: [usdcToken.numeraire, baseToken.numeraire],
      _nBals: isUSDC(tokenIn.address) ? [
        usdcToken.numeraire + givenToken.numeraire,
        baseToken.numeraire - givenToken.numeraire
      ] : [
        usdcToken.numeraire - givenToken.numeraire,
        baseToken.numeraire + givenToken.numeraire
      ],
      givenToken,
      swapKind
    };
  }
};

// src/entities/pools/fx/fxFactory.ts
var FxPoolFactory = class {
  isPoolForFactory(pool) {
    return pool.poolType.includes("FX");
  }
  create(chainId, pool) {
    return FxPool.fromRawPool(chainId, pool);
  }
};

// src/entities/pools/gyro2/gyro2Pool.ts


// src/utils/gyroHelpers/math.ts
var SQRT_1E_NEG_1 = 316227766016837933n;
var SQRT_1E_NEG_3 = 31622776601683793n;
var SQRT_1E_NEG_5 = 3162277660168379n;
var SQRT_1E_NEG_7 = 316227766016837n;
var SQRT_1E_NEG_9 = 31622776601683n;
var SQRT_1E_NEG_11 = 3162277660168n;
var SQRT_1E_NEG_13 = 316227766016n;
var SQRT_1E_NEG_15 = 31622776601n;
var SQRT_1E_NEG_17 = 3162277660n;
var ONE_XP = 10n ** 38n;
var SMALL = 10n ** 8n;
var SWAP_LIMIT_FACTOR = 999999000000000000n;
var MathGyro = class {
  static mulUp(a, b) {
    const product = a * b;
    return (product - 1n) / WAD + 1n;
  }
  static divUp(a, b) {
    const aInflated = a * WAD;
    return (aInflated - 1n) / b + 1n;
  }
  static mulDown(a, b) {
    const product = a * b;
    return product / WAD;
  }
  static divDown(a, b) {
    const aInflated = a * WAD;
    return aInflated / b;
  }
  static mulXpU(a, b) {
    return a * b / ONE_XP;
  }
  static divXpU(a, b) {
    if (b === 0n)
      throw new Error("ZERO DIVISION");
    return a * ONE_XP / b;
  }
  static mulDownMagU(a, b) {
    return a * b / WAD;
  }
  static divDownMagU(a, b) {
    if (b === 0n)
      throw new Error("ZERO DIVISION");
    return a * WAD / b;
  }
  static mulUpMagU(a, b) {
    const product = a * b;
    if (product > 0n)
      return (product - 1n) / WAD + 1n;
    if (product < 0n)
      return (product + 1n) / WAD - 1n;
    return 0n;
  }
  static divUpMagU(a, b) {
    if (b === 0n)
      throw new Error("ZERO DIVISION");
    if (a === 0n)
      return 0n;
    let _b = b;
    let _a = a;
    if (b < 0n) {
      _b = b * -1n;
      _a = a * -1n;
    }
    return _a > 0n ? (_a * WAD - 1n) / _b + 1n : (_a * WAD + 1n) / (_b - 1n);
  }
  static mulUpXpToNpU(a, b) {
    const TenPower19 = 10n ** 19n;
    const b1 = b / TenPower19;
    const b2 = b < 0n ? b * -1n % TenPower19 * -1n : b % TenPower19;
    const prod1 = a * b1;
    const prod2 = a * b2;
    return prod1 <= 0n && prod2 <= 0n ? (prod1 + prod2 / TenPower19) / TenPower19 : (prod1 + prod2 / TenPower19 - 1n) / TenPower19 + 1n;
  }
  static mulDownXpToNpU(a, b) {
    const TenPower19 = 10n ** 19n;
    const b1 = b / TenPower19;
    const b2 = b < 0n ? b * -1n % TenPower19 * -1n : b % TenPower19;
    const prod1 = a * b1;
    const prod2 = a * b2;
    return prod1 >= 0n && prod2 >= 0n ? (prod1 + prod2 / TenPower19) / TenPower19 : (prod1 + prod2 / TenPower19 + 1n) / TenPower19 - 1n;
  }
  /////////
  /// SQUARE ROOT
  /////////
  static sqrt(input, tolerance) {
    if (input === 0n) {
      return 0n;
    }
    let guess = MathGyro.makeInitialGuess(input);
    for (let i = 0; i < 7; i++) {
      guess = (guess + input * WAD / guess) / 2n;
    }
    const guessSquared = guess * guess / WAD;
    if (!(guessSquared <= input + MathGyro.mulUp(guess, tolerance) && guessSquared >= input - MathGyro.mulUp(guess, tolerance)))
      throw new Error("GyroEPool: sqrt failed");
    return guess;
  }
  static makeInitialGuess(input) {
    if (input > WAD) {
      return 2n ** MathGyro.intLog2Halved(input / WAD) * WAD;
    }
    if (input <= 10n) {
      return SQRT_1E_NEG_17;
    }
    if (input <= 100n) {
      return 10000000000n;
    }
    if (input <= 1000n) {
      return SQRT_1E_NEG_15;
    }
    if (input <= 10000n) {
      return 100000000000n;
    }
    if (input <= 100000n) {
      return SQRT_1E_NEG_13;
    }
    if (input <= 1000000n) {
      return 1000000000000n;
    }
    if (input <= 10000000n) {
      return SQRT_1E_NEG_11;
    }
    if (input <= 100000000n) {
      return 10000000000000n;
    }
    if (input <= 1000000000n) {
      return SQRT_1E_NEG_9;
    }
    if (input <= 10000000000n) {
      return 100000000000000n;
    }
    if (input <= 100000000000n) {
      return SQRT_1E_NEG_7;
    }
    if (input <= 1000000000000n) {
      return 1000000000000000n;
    }
    if (input <= 10000000000000n) {
      return SQRT_1E_NEG_5;
    }
    if (input <= 100000000000000n) {
      return 10000000000000000n;
    }
    if (input <= 1000000000000000n) {
      return SQRT_1E_NEG_3;
    }
    if (input <= 10000000000000000n) {
      return 100000000000000000n;
    }
    if (input <= 100000000000000000n) {
      return SQRT_1E_NEG_1;
    }
    return input;
  }
  static intLog2Halved(x) {
    let n = 0n;
    let _x = x;
    for (let i = 128n; i >= 2n; i = i / 2n) {
      const factor = 2n ** i;
      if (_x >= factor) {
        _x = _x / factor;
        n += i / 2n;
      }
    }
    return n;
  }
};

// src/entities/pools/gyro2/gyro2Math.ts
function _calcOutGivenIn4(balanceIn, balanceOut, amountIn, virtualParamIn, virtualParamOut) {
  const virtInOver = balanceIn + MathSol.mulUpFixed(virtualParamIn, WAD + 2n);
  const virtOutUnder = balanceOut + MathSol.mulDownFixed(virtualParamOut, WAD - 1n);
  const amountOut = MathSol.divDownFixed(
    MathSol.mulDownFixed(virtOutUnder, amountIn),
    virtInOver + amountIn
  );
  return amountOut;
}
function _calcInGivenOut4(balanceIn, balanceOut, amountOut, virtualParamIn, virtualParamOut) {
  const virtInOver = balanceIn + MathSol.mulUpFixed(virtualParamIn, WAD + 2n);
  const virtOutUnder = balanceOut + MathSol.mulDownFixed(virtualParamOut, WAD - 1n);
  const amountIn = MathSol.divUpFixed(
    MathSol.mulUpFixed(virtInOver, amountOut),
    virtOutUnder - amountOut
  );
  return amountIn;
}
function _findVirtualParams(invariant, sqrtAlpha, sqrtBeta) {
  return [
    MathSol.divDownFixed(invariant, sqrtBeta),
    MathSol.mulDownFixed(invariant, sqrtAlpha)
  ];
}
function _calculateInvariant2(balances, sqrtAlpha, sqrtBeta) {
  const [a, mb, bSquare, mc] = _calculateQuadraticTerms(
    balances,
    sqrtAlpha,
    sqrtBeta
  );
  const invariant = _calculateQuadratic(a, mb, bSquare, mc);
  return invariant;
}
function _calculateQuadraticTerms(balances, sqrtAlpha, sqrtBeta) {
  const a = WAD - MathSol.divDownFixed(sqrtAlpha, sqrtBeta);
  const bterm0 = MathSol.divDownFixed(balances[1], sqrtBeta);
  const bterm1 = MathSol.mulDownFixed(balances[0], sqrtAlpha);
  const mb = bterm0 + bterm1;
  const mc = MathSol.mulDownFixed(balances[0], balances[1]);
  let bSquare = MathSol.mulDownFixed(
    MathSol.mulDownFixed(
      MathSol.mulDownFixed(balances[0], balances[0]),
      sqrtAlpha
    ),
    sqrtAlpha
  );
  const bSq2 = MathSol.divDownFixed(
    MathSol.mulDownFixed(
      MathSol.mulDownFixed(
        MathSol.mulDownFixed(balances[0], balances[1]),
        TWO_WAD
      ),
      sqrtAlpha
    ),
    sqrtBeta
  );
  const bSq3 = MathSol.divDownFixed(
    MathSol.mulDownFixed(balances[1], balances[1]),
    MathSol.mulUpFixed(sqrtBeta, sqrtBeta)
  );
  bSquare = bSquare + bSq2 + bSq3;
  return [a, mb, bSquare, mc];
}
function _calculateQuadratic(a, mb, bSquare, mc) {
  const denominator = MathSol.mulUpFixed(a, TWO_WAD);
  const addTerm = MathSol.mulDownFixed(MathSol.mulDownFixed(mc, FOUR_WAD), a);
  const radicand = bSquare + addTerm;
  const sqrResult = MathGyro.sqrt(radicand, 5n);
  const numerator = mb + sqrResult;
  const invariant = MathSol.divDownFixed(numerator, denominator);
  return invariant;
}

// src/entities/pools/gyro2/gyro2Pool.ts
var Gyro2PoolToken = class extends TokenAmount {
  constructor(token, amount, index) {
    super(token, amount);
    __publicField(this, "index");
    this.index = index;
  }
  increase(amount) {
    this.amount = this.amount + amount;
    this.scale18 = this.amount * this.scalar;
    return this;
  }
  decrease(amount) {
    this.amount = this.amount - amount;
    this.scale18 = this.amount * this.scalar;
    return this;
  }
};
var Gyro2Pool = class {
  constructor(id, poolTypeVersion, swapFee, sqrtAlpha, sqrtBeta, tokens) {
    __publicField(this, "chainId");
    __publicField(this, "id");
    __publicField(this, "address");
    __publicField(this, "poolType", "Gyro2" /* Gyro2 */);
    __publicField(this, "poolTypeVersion");
    __publicField(this, "swapFee");
    __publicField(this, "tokens");
    __publicField(this, "sqrtAlpha");
    __publicField(this, "sqrtBeta");
    __publicField(this, "tokenMap");
    this.chainId = tokens[0].token.chainId;
    this.id = id;
    this.poolTypeVersion = poolTypeVersion;
    this.swapFee = swapFee;
    this.sqrtAlpha = sqrtAlpha;
    this.sqrtBeta = sqrtBeta;
    this.address = getPoolAddress(id);
    this.tokens = tokens;
    this.tokenMap = new Map(
      this.tokens.map((token) => [token.token.address, token])
    );
  }
  static fromRawPool(chainId, pool) {
    const poolTokens = [];
    for (const t of pool.tokens) {
      const token = new Token(
        chainId,
        t.address,
        t.decimals,
        t.symbol,
        t.name
      );
      const tokenAmount = TokenAmount.fromHumanAmount(token, t.balance);
      poolTokens.push(
        new Gyro2PoolToken(token, tokenAmount.amount, t.index)
      );
    }
    return new Gyro2Pool(
      pool.id,
      pool.poolTypeVersion,
      _viem.parseEther.call(void 0, pool.swapFee),
      _viem.parseEther.call(void 0, pool.sqrtAlpha),
      _viem.parseEther.call(void 0, pool.sqrtBeta),
      poolTokens
    );
  }
  getNormalizedLiquidity(tokenIn, tokenOut) {
    const tIn = this.tokenMap.get(tokenIn.wrapped);
    const tOut = this.tokenMap.get(tokenOut.wrapped);
    if (!tIn || !tOut)
      throw new Error("Pool does not contain the tokens provided");
    return tOut.amount;
  }
  swapGivenIn(tokenIn, tokenOut, swapAmount, mutateBalances) {
    const { tIn, tOut, sqrtAlpha, sqrtBeta } = this.getPoolPairData(
      tokenIn,
      tokenOut
    );
    const invariant = _calculateInvariant2(
      [tIn.scale18, tOut.scale18],
      sqrtAlpha,
      sqrtBeta
    );
    const [virtualParamIn, virtualParamOut] = _findVirtualParams(
      invariant,
      sqrtAlpha,
      sqrtBeta
    );
    const inAmountLessFee = this.subtractSwapFeeAmount(swapAmount);
    const outAmountScale18 = _calcOutGivenIn4(
      tIn.scale18,
      tOut.scale18,
      inAmountLessFee.scale18,
      virtualParamIn,
      virtualParamOut
    );
    if (outAmountScale18 > tOut.scale18)
      throw new Error("ASSET_BOUNDS_EXCEEDED");
    const outAmount = TokenAmount.fromScale18Amount(
      tokenOut,
      outAmountScale18
    );
    if (mutateBalances) {
      tIn.increase(swapAmount.amount);
      tOut.decrease(outAmount.amount);
    }
    return outAmount;
  }
  swapGivenOut(tokenIn, tokenOut, swapAmount, mutateBalances) {
    const { tIn, tOut, sqrtAlpha, sqrtBeta } = this.getPoolPairData(
      tokenIn,
      tokenOut
    );
    if (swapAmount.scale18 > tOut.scale18)
      throw new Error("ASSET_BOUNDS_EXCEEDED");
    const invariant = _calculateInvariant2(
      [tIn.scale18, tOut.scale18],
      sqrtAlpha,
      sqrtBeta
    );
    const [virtualParamIn, virtualParamOut] = _findVirtualParams(
      invariant,
      sqrtAlpha,
      sqrtBeta
    );
    const inAmountLessFee = _calcInGivenOut4(
      tIn.scale18,
      tOut.scale18,
      swapAmount.scale18,
      virtualParamIn,
      virtualParamOut
    );
    const inAmount = this.addSwapFeeAmount(
      TokenAmount.fromScale18Amount(tokenIn, inAmountLessFee)
    );
    if (mutateBalances) {
      tIn.decrease(inAmount.amount);
      tOut.increase(swapAmount.amount);
    }
    return inAmount;
  }
  getLimitAmountSwap(tokenIn, tokenOut, swapKind) {
    const { tIn, tOut, sqrtAlpha, sqrtBeta } = this.getPoolPairData(
      tokenIn,
      tokenOut
    );
    if (swapKind === 0 /* GivenIn */) {
      const invariant = _calculateInvariant2(
        [tIn.scale18, tOut.scale18],
        sqrtAlpha,
        sqrtBeta
      );
      const maxAmountInAssetInPool = MathSol.mulUpFixed(
        invariant,
        MathSol.divDownFixed(WAD, sqrtAlpha) - MathSol.divDownFixed(WAD, sqrtBeta)
      );
      const limitAmountIn = maxAmountInAssetInPool - tIn.scale18;
      const limitAmountInPlusSwapFee = MathSol.divDownFixed(
        limitAmountIn,
        WAD - this.swapFee
      );
      return MathSol.mulDownFixed(
        limitAmountInPlusSwapFee,
        SWAP_LIMIT_FACTOR
      );
    }
    return MathSol.mulDownFixed(tOut.amount, SWAP_LIMIT_FACTOR);
  }
  subtractSwapFeeAmount(amount) {
    const feeAmount = amount.mulUpFixed(this.swapFee);
    return amount.sub(feeAmount);
  }
  addSwapFeeAmount(amount) {
    return amount.divUpFixed(MathSol.complementFixed(this.swapFee));
  }
  getPoolPairData(tokenIn, tokenOut) {
    const tIn = this.tokenMap.get(tokenIn.wrapped);
    const tOut = this.tokenMap.get(tokenOut.wrapped);
    if (!tIn || !tOut) {
      throw new Error("Pool does not contain the tokens provided");
    }
    const sqrtAlpha = tIn.index === 0 ? this.sqrtAlpha : MathSol.divDownFixed(WAD, this.sqrtBeta);
    const sqrtBeta = tIn.index === 0 ? this.sqrtBeta : MathSol.divDownFixed(WAD, this.sqrtAlpha);
    return { tIn, tOut, sqrtAlpha, sqrtBeta };
  }
};

// src/entities/pools/gyro2/gyro2Factory.ts
var Gyro2PoolFactory = class {
  isPoolForFactory(pool) {
    return pool.poolType.includes("Gyro2");
  }
  create(chainId, pool) {
    return Gyro2Pool.fromRawPool(chainId, pool);
  }
};

// src/entities/pools/gyro3/gyro3Pool.ts


// src/entities/pools/gyro3/constants.ts
var _SAFE_LARGE_POW3_THRESHOLD = 10n ** 29n * 487n;
var MIDDECIMAL = 10n ** 9n;
var _INVARIANT_SHRINKING_FACTOR_PER_STEP = 8n;
var _INVARIANT_MIN_ITERATIONS = 5n;

// src/entities/pools/gyro3/helpers.ts
function _safeLargePow3ADown(l, root3Alpha, d) {
  let ret = 0n;
  if (l <= _SAFE_LARGE_POW3_THRESHOLD) {
    ret = l * l / WAD * l / WAD;
    ret = ret - ret * root3Alpha / WAD * root3Alpha / WAD * root3Alpha / WAD;
    ret = ret * WAD / d;
  } else {
    ret = l * l / WAD;
    ret = ret * (l / WAD) + ret * l % WAD / WAD;
    let x = ret;
    for (let i = 0; i < 3; i++) {
      x = x * (root3Alpha / MIDDECIMAL) / MIDDECIMAL + x * root3Alpha % MIDDECIMAL;
    }
    ret = ret - x;
    ret = ret * MIDDECIMAL / (d / MIDDECIMAL);
  }
  return ret;
}

// src/entities/pools/gyro3/gyro3Math.ts
function _calculateInvariant3(balances, root3Alpha) {
  const [a, mb, mc, md] = _calculateCubicTerms(balances, root3Alpha);
  return _calculateCubic(a, mb, mc, md, root3Alpha);
}
function _calculateCubicTerms(balances, root3Alpha) {
  const alpha23 = MathGyro.mulDown(root3Alpha, root3Alpha);
  const alpha = MathGyro.mulDown(alpha23, root3Alpha);
  const a = WAD - alpha;
  const bterm = balances[0] + balances[1] + balances[2];
  const mb = MathGyro.mulDown(
    MathGyro.mulDown(bterm, root3Alpha),
    root3Alpha
  );
  const cterm = MathGyro.mulDown(balances[0], balances[1]) + MathGyro.mulDown(balances[1], balances[2]) + MathGyro.mulDown(balances[2], balances[0]);
  const mc = MathGyro.mulDown(cterm, root3Alpha);
  const md = MathGyro.mulDown(
    MathGyro.mulDown(balances[0], balances[1]),
    balances[2]
  );
  return [a, mb, mc, md];
}
function _calculateCubic(a, mb, mc, md, root3Alpha) {
  let rootEst = _calculateCubicStartingPoint(a, mb, mc);
  rootEst = _runNewtonIteration(a, mb, mc, md, root3Alpha, rootEst);
  return rootEst;
}
function _calculateCubicStartingPoint(a, mb, mc) {
  const radic = MathGyro.mulUp(mb, mb) + MathGyro.mulUp(MathGyro.mulUp(a, mc), WAD * 3n);
  const lmin = MathGyro.divUp(mb, a * 3n) + MathGyro.divUp(MathGyro.sqrt(radic, 5n), a * 3n);
  const alpha = WAD - a;
  const factor = alpha >= WAD / 2n ? WAD * 3n / 2n : WAD * 2n;
  const l0 = MathGyro.mulUp(lmin, factor);
  return l0;
}
function _runNewtonIteration(a, mb, mc, md, root3Alpha, rootEst) {
  let deltaAbsPrev = 0n;
  let _rootEst = rootEst;
  for (let iteration = 0; iteration < 255; ++iteration) {
    const [deltaAbs, deltaIsPos] = _calcNewtonDelta(
      a,
      mb,
      mc,
      md,
      root3Alpha,
      _rootEst
    );
    if (deltaAbs <= 1 || iteration >= _INVARIANT_MIN_ITERATIONS && deltaIsPos)
      return _rootEst;
    if (iteration >= _INVARIANT_MIN_ITERATIONS && deltaAbs >= deltaAbsPrev / _INVARIANT_SHRINKING_FACTOR_PER_STEP) {
      return _rootEst;
    }
    deltaAbsPrev = deltaAbs;
    if (deltaIsPos)
      _rootEst = _rootEst + deltaAbs;
    else
      _rootEst = _rootEst - deltaAbs;
  }
  throw new Error(
    "Gyro3Pool: Newton Method did not converge on required invariant"
  );
}
function _calcNewtonDelta(_, mb, mc, md, root3Alpha, rootEst) {
  let dfRootEst = 0n;
  const rootEst2 = MathGyro.mulDown(rootEst, rootEst);
  dfRootEst = rootEst2 * 3n;
  dfRootEst = dfRootEst - MathGyro.mulDown(
    MathGyro.mulDown(
      MathGyro.mulDown(dfRootEst, root3Alpha),
      root3Alpha
    ),
    root3Alpha
  );
  dfRootEst = dfRootEst - MathGyro.mulDown(rootEst, mb) * 2n - mc;
  const deltaMinus = _safeLargePow3ADown(rootEst, root3Alpha, dfRootEst);
  let deltaPlus = MathGyro.mulDown(MathGyro.mulDown(rootEst, rootEst), mb);
  deltaPlus = MathGyro.divDown(
    deltaPlus + MathGyro.mulDown(rootEst, mc),
    dfRootEst
  );
  deltaPlus = deltaPlus + MathGyro.divDown(md, dfRootEst);
  const deltaIsPos = deltaPlus >= deltaMinus;
  const deltaAbs = deltaIsPos ? deltaPlus - deltaMinus : deltaMinus - deltaPlus;
  return [deltaAbs, deltaIsPos];
}
function _calcOutGivenIn5(balanceIn, balanceOut, amountIn, virtualOffset) {
  const virtInOver = balanceIn + MathGyro.mulUp(virtualOffset, WAD + 2n);
  const virtOutUnder = balanceOut + MathGyro.mulDown(virtualOffset, WAD - 1n);
  const amountOut = virtOutUnder * amountIn / (virtInOver + amountIn);
  return amountOut;
}
function _calcInGivenOut5(balanceIn, balanceOut, amountOut, virtualOffset) {
  const virtInOver = balanceIn + MathGyro.mulUp(virtualOffset, WAD + 2n);
  const virtOutUnder = balanceOut + MathGyro.mulDown(virtualOffset, WAD - 1n);
  const amountIn = MathGyro.divUp(
    MathGyro.mulUp(virtInOver, amountOut),
    virtOutUnder - amountOut
  );
  return amountIn;
}

// src/entities/pools/gyro3/gyro3Pool.ts
var Gyro3PoolToken = class extends TokenAmount {
  constructor(token, amount, index) {
    super(token, amount);
    __publicField(this, "index");
    this.index = index;
  }
  increase(amount) {
    this.amount = this.amount + amount;
    this.scale18 = this.amount * this.scalar;
    return this;
  }
  decrease(amount) {
    this.amount = this.amount - amount;
    this.scale18 = this.amount * this.scalar;
    return this;
  }
};
var Gyro3Pool = class {
  constructor(id, poolTypeVersion, swapFee, root3Alpha, tokens) {
    __publicField(this, "chainId");
    __publicField(this, "id");
    __publicField(this, "address");
    __publicField(this, "poolType", "Gyro2" /* Gyro2 */);
    __publicField(this, "poolTypeVersion");
    __publicField(this, "swapFee");
    __publicField(this, "tokens");
    __publicField(this, "root3Alpha");
    __publicField(this, "tokenMap");
    this.chainId = tokens[0].token.chainId;
    this.id = id;
    this.poolTypeVersion = poolTypeVersion;
    this.swapFee = swapFee;
    this.root3Alpha = root3Alpha;
    this.address = getPoolAddress(id);
    this.tokens = tokens;
    this.tokenMap = new Map(
      this.tokens.map((token) => [token.token.address, token])
    );
  }
  static fromRawPool(chainId, pool) {
    const poolTokens = [];
    for (const t of pool.tokens) {
      const token = new Token(
        chainId,
        t.address,
        t.decimals,
        t.symbol,
        t.name
      );
      const tokenAmount = TokenAmount.fromHumanAmount(token, t.balance);
      poolTokens.push(
        new Gyro3PoolToken(token, tokenAmount.amount, t.index)
      );
    }
    return new Gyro3Pool(
      pool.id,
      pool.poolTypeVersion,
      _viem.parseEther.call(void 0, pool.swapFee),
      _viem.parseEther.call(void 0, pool.root3Alpha),
      poolTokens
    );
  }
  getNormalizedLiquidity(tokenIn, tokenOut) {
    const tIn = this.tokenMap.get(tokenIn.wrapped);
    const tOut = this.tokenMap.get(tokenOut.wrapped);
    if (!tIn || !tOut)
      throw new Error("Pool does not contain the tokens provided");
    return tOut.amount;
  }
  swapGivenIn(tokenIn, tokenOut, swapAmount, mutateBalances) {
    const { tIn, tOut, tertiary } = this.getPoolPairData(tokenIn, tokenOut);
    const invariant = _calculateInvariant3(
      [tIn.scale18, tOut.scale18, tertiary.scale18],
      this.root3Alpha
    );
    const virtualOffsetInOut = MathGyro.mulDown(invariant, this.root3Alpha);
    const inAmountLessFee = this.subtractSwapFeeAmount(swapAmount);
    const outAmountScale18 = _calcOutGivenIn5(
      tIn.scale18,
      tOut.scale18,
      inAmountLessFee.scale18,
      virtualOffsetInOut
    );
    if (outAmountScale18 > tOut.scale18)
      throw new Error("ASSET_BOUNDS_EXCEEDED");
    const outAmount = TokenAmount.fromScale18Amount(
      tokenOut,
      outAmountScale18
    );
    if (mutateBalances) {
      tIn.increase(swapAmount.amount);
      tOut.decrease(outAmount.amount);
    }
    return outAmount;
  }
  swapGivenOut(tokenIn, tokenOut, swapAmount, mutateBalances) {
    const { tIn, tOut, tertiary } = this.getPoolPairData(tokenIn, tokenOut);
    if (swapAmount.scale18 > tOut.scale18)
      throw new Error("ASSET_BOUNDS_EXCEEDED");
    const invariant = _calculateInvariant3(
      [tIn.scale18, tOut.scale18, tertiary.scale18],
      this.root3Alpha
    );
    const virtualOffsetInOut = MathGyro.mulDown(invariant, this.root3Alpha);
    const inAmountLessFee = _calcInGivenOut5(
      tIn.scale18,
      tOut.scale18,
      swapAmount.scale18,
      virtualOffsetInOut
    );
    const inAmount = this.addSwapFeeAmount(
      TokenAmount.fromScale18Amount(tokenIn, inAmountLessFee, true)
    );
    if (mutateBalances) {
      tIn.decrease(inAmount.amount);
      tOut.increase(swapAmount.amount);
    }
    return inAmount;
  }
  getLimitAmountSwap(tokenIn, tokenOut, swapKind) {
    const { tIn, tOut, tertiary } = this.getPoolPairData(tokenIn, tokenOut);
    if (swapKind === 0 /* GivenIn */) {
      const invariant = _calculateInvariant3(
        [tIn.scale18, tOut.scale18, tertiary.scale18],
        this.root3Alpha
      );
      const a = MathGyro.mulDown(invariant, this.root3Alpha);
      const maxAmountInAssetInPool = MathGyro.divDown(
        MathGyro.mulDown(tIn.scale18 + a, tOut.scale18 + a),
        a
      ) - a;
      const limitAmountIn = maxAmountInAssetInPool - tIn.scale18;
      const limitAmountInPlusSwapFee = MathGyro.divDown(
        limitAmountIn,
        WAD - this.swapFee
      );
      return MathGyro.mulDown(
        limitAmountInPlusSwapFee,
        SWAP_LIMIT_FACTOR
      );
    }
    return MathGyro.mulDown(tOut.amount, SWAP_LIMIT_FACTOR);
  }
  subtractSwapFeeAmount(amount) {
    const feeAmount = amount.mulUpFixed(this.swapFee);
    return amount.sub(feeAmount);
  }
  addSwapFeeAmount(amount) {
    return amount.divUpFixed(MathSol.complementFixed(this.swapFee));
  }
  getPoolPairData(tokenIn, tokenOut) {
    const tIn = this.tokenMap.get(tokenIn.wrapped);
    const tOut = this.tokenMap.get(tokenOut.wrapped);
    const tertiaryAddress = this.tokens.map((t) => t.token.wrapped).find((a) => a !== tokenIn.wrapped && a !== tokenOut.wrapped);
    const tertiary = this.tokenMap.get(tertiaryAddress);
    if (!tIn || !tOut || !tertiary) {
      throw new Error("Pool does not contain the tokens provided");
    }
    return { tIn, tOut, tertiary };
  }
};

// src/entities/pools/gyro3/gyro3Factory.ts
var Gyro3PoolFactory = class {
  isPoolForFactory(pool) {
    return pool.poolType.includes("Gyro3");
  }
  create(chainId, pool) {
    return Gyro3Pool.fromRawPool(chainId, pool);
  }
};

// src/entities/pools/gyroE/gyroEPool.ts


// src/entities/pools/gyroE/constants.ts
var MAX_BALANCES = 10n ** 34n;
var MAX_INVARIANT = 10n ** 37n * 3n;

// src/entities/pools/gyroE/gyroEMathHelpers.ts
function balancesFromTokenInOut(balanceTokenIn, balanceTokenOut, tokenInIsToken0) {
  return tokenInIsToken0 ? [balanceTokenIn, balanceTokenOut] : [balanceTokenOut, balanceTokenIn];
}
function calcAtAChi(x, y, p, d) {
  const dSq2 = MathGyro.mulXpU(d.dSq, d.dSq);
  const termXp = MathGyro.divXpU(
    MathGyro.divDownMagU(
      MathGyro.divDownMagU(d.w, p.lambda) + d.z,
      p.lambda
    ),
    dSq2
  );
  let val = MathGyro.mulDownXpToNpU(
    MathGyro.mulDownMagU(x, p.c) - MathGyro.mulDownMagU(y, p.s),
    termXp
  );
  let termNp = MathGyro.mulDownMagU(MathGyro.mulDownMagU(x, p.lambda), p.s) + MathGyro.mulDownMagU(MathGyro.mulDownMagU(y, p.lambda), p.c);
  val = val + MathGyro.mulDownXpToNpU(termNp, MathGyro.divXpU(d.u, dSq2));
  termNp = MathGyro.mulDownMagU(x, p.s) + MathGyro.mulDownMagU(y, p.c);
  val = val + MathGyro.mulDownXpToNpU(termNp, MathGyro.divXpU(d.v, dSq2));
  return val;
}
function calcInvariantSqrt(x, y, p, d) {
  let val = calcMinAtxAChiySqPlusAtxSq(x, y, p, d) + calc2AtxAtyAChixAChiy(x, y, p, d);
  val = val + calcMinAtyAChixSqPlusAtySq(x, y, p, d);
  const err = (MathGyro.mulUpMagU(x, x) + MathGyro.mulUpMagU(y, y)) / ONE_XP;
  val = val > 0 ? MathGyro.sqrt(val, 5n) : 0n;
  return [val, err];
}
function calcMinAtxAChiySqPlusAtxSq(x, y, p, d) {
  let termNp = MathGyro.mulUpMagU(
    MathGyro.mulUpMagU(MathGyro.mulUpMagU(x, x), p.c),
    p.c
  ) + MathGyro.mulUpMagU(
    MathGyro.mulUpMagU(MathGyro.mulUpMagU(y, y), p.s),
    p.s
  );
  termNp = termNp - MathGyro.mulDownMagU(
    MathGyro.mulDownMagU(MathGyro.mulDownMagU(x, y), p.c * 2n),
    p.s
  );
  const termXp = MathGyro.mulXpU(d.u, d.u) + MathGyro.divDownMagU(MathGyro.mulXpU(d.u * 2n, d.v), p.lambda) + MathGyro.divDownMagU(
    MathGyro.divDownMagU(MathGyro.mulXpU(d.v, d.v), p.lambda),
    p.lambda
  );
  let val = MathGyro.mulDownXpToNpU(termNp * -1n, termXp);
  val = val + MathGyro.mulDownXpToNpU(
    MathGyro.divDownMagU(
      MathGyro.divDownMagU(termNp - 9n, p.lambda),
      p.lambda
    ),
    MathGyro.divXpU(ONE_XP, d.dSq)
  );
  return val;
}
function calc2AtxAtyAChixAChiy(x, y, p, d) {
  let termNp = MathGyro.mulDownMagU(
    MathGyro.mulDownMagU(
      MathGyro.mulDownMagU(x, x) - MathGyro.mulUpMagU(y, y),
      p.c * 2n
    ),
    p.s
  );
  const xy = MathGyro.mulDownMagU(y, x * 2n);
  termNp = termNp + MathGyro.mulDownMagU(MathGyro.mulDownMagU(xy, p.c), p.c) - MathGyro.mulDownMagU(MathGyro.mulDownMagU(xy, p.s), p.s);
  let termXp = MathGyro.mulXpU(d.z, d.u) + MathGyro.divDownMagU(
    MathGyro.divDownMagU(MathGyro.mulXpU(d.w, d.v), p.lambda),
    p.lambda
  );
  termXp = termXp + MathGyro.divDownMagU(
    MathGyro.mulXpU(d.w, d.u) + MathGyro.mulXpU(d.z, d.v),
    p.lambda
  );
  termXp = MathGyro.divXpU(
    termXp,
    MathGyro.mulXpU(
      MathGyro.mulXpU(MathGyro.mulXpU(d.dSq, d.dSq), d.dSq),
      d.dSq
    )
  );
  const val = MathGyro.mulDownXpToNpU(termNp, termXp);
  return val;
}
function calcMinAtyAChixSqPlusAtySq(x, y, p, d) {
  let termNp = MathGyro.mulUpMagU(
    MathGyro.mulUpMagU(MathGyro.mulUpMagU(x, x), p.s),
    p.s
  ) + MathGyro.mulUpMagU(
    MathGyro.mulUpMagU(MathGyro.mulUpMagU(y, y), p.c),
    p.c
  );
  termNp = termNp + MathGyro.mulUpMagU(
    MathGyro.mulUpMagU(MathGyro.mulUpMagU(x, y), p.s * 2n),
    p.c
  );
  let termXp = MathGyro.mulXpU(d.z, d.z) + MathGyro.divDownMagU(
    MathGyro.divDownMagU(MathGyro.mulXpU(d.w, d.w), p.lambda),
    p.lambda
  );
  termXp = termXp + MathGyro.divDownMagU(MathGyro.mulXpU(d.z * 2n, d.w), p.lambda);
  termXp = MathGyro.divXpU(
    termXp,
    MathGyro.mulXpU(
      MathGyro.mulXpU(MathGyro.mulXpU(d.dSq, d.dSq), d.dSq),
      d.dSq
    )
  );
  let val = MathGyro.mulDownXpToNpU(termNp * -1n, termXp);
  val = val + MathGyro.mulDownXpToNpU(termNp - 9n, MathGyro.divXpU(ONE_XP, d.dSq));
  return val;
}
function calcAChiAChiInXp(p, d) {
  const dSq3 = MathGyro.mulXpU(MathGyro.mulXpU(d.dSq, d.dSq), d.dSq);
  let val = MathGyro.mulUpMagU(
    p.lambda,
    MathGyro.divXpU(MathGyro.mulXpU(d.u * 2n, d.v), dSq3)
  );
  val = val + MathGyro.mulUpMagU(
    MathGyro.mulUpMagU(
      MathGyro.divXpU(MathGyro.mulXpU(d.u + 1n, d.u + 1n), dSq3),
      p.lambda
    ),
    p.lambda
  );
  val = val + MathGyro.divXpU(MathGyro.mulXpU(d.v, d.v), dSq3);
  const termXp = MathGyro.divUpMagU(d.w, p.lambda) + d.z;
  val = val + MathGyro.divXpU(MathGyro.mulXpU(termXp, termXp), dSq3);
  return val;
}
function checkAssetBounds(params, derived, invariant, newBal, assetIndex) {
  if (assetIndex === 0) {
    const xPlus = maxBalances0(params, derived, invariant);
    if (newBal > MAX_BALANCES || newBal > xPlus)
      throw new Error("ASSET BOUNDS EXCEEDED");
  } else {
    const yPlus = maxBalances1(params, derived, invariant);
    if (newBal > MAX_BALANCES || newBal > yPlus)
      throw new Error("ASSET BOUNDS EXCEEDED");
  }
}
function maxBalances0(p, d, r) {
  const termXp1 = MathGyro.divXpU(d.tauBeta.x - d.tauAlpha.x, d.dSq);
  const termXp2 = MathGyro.divXpU(d.tauBeta.y - d.tauAlpha.y, d.dSq);
  let xp = MathGyro.mulDownXpToNpU(
    MathGyro.mulDownMagU(MathGyro.mulDownMagU(r.y, p.lambda), p.c),
    termXp1
  );
  xp = xp + (termXp2 > 0n ? MathGyro.mulDownMagU(r.y, p.s) : MathGyro.mulDownXpToNpU(MathGyro.mulUpMagU(r.x, p.s), termXp2));
  return xp;
}
function maxBalances1(p, d, r) {
  const termXp1 = MathGyro.divXpU(d.tauBeta.x - d.tauAlpha.x, d.dSq);
  const termXp2 = MathGyro.divXpU(d.tauBeta.y - d.tauAlpha.y, d.dSq);
  let yp = MathGyro.mulDownXpToNpU(
    MathGyro.mulDownMagU(MathGyro.mulDownMagU(r.y, p.lambda), p.s),
    termXp1
  );
  yp = yp + (termXp2 > 0n ? MathGyro.mulDownMagU(r.y, p.c) : MathGyro.mulDownXpToNpU(MathGyro.mulUpMagU(r.x, p.c), termXp2));
  return yp;
}
function calcYGivenX(x, params, d, r) {
  const ab = {
    x: virtualOffset0(params, d, r),
    y: virtualOffset1(params, d, r)
  };
  const y = solveQuadraticSwap(
    params.lambda,
    x,
    params.s,
    params.c,
    r,
    ab,
    d.tauBeta,
    d.dSq
  );
  return y;
}
function calcXGivenY(y, params, d, r) {
  const ba = {
    x: virtualOffset1(params, d, r),
    y: virtualOffset0(params, d, r)
  };
  const x = solveQuadraticSwap(
    params.lambda,
    y,
    params.c,
    params.s,
    r,
    ba,
    {
      x: d.tauAlpha.x * -1n,
      y: d.tauAlpha.y
    },
    d.dSq
  );
  return x;
}
function virtualOffset0(p, d, r, switchTau) {
  const tauValue = switchTau ? d.tauAlpha : d.tauBeta;
  const termXp = MathGyro.divXpU(tauValue.x, d.dSq);
  let a = tauValue.x > 0n ? MathGyro.mulUpXpToNpU(
    MathGyro.mulUpMagU(MathGyro.mulUpMagU(r.x, p.lambda), p.c),
    termXp
  ) : MathGyro.mulUpXpToNpU(
    MathGyro.mulDownMagU(
      MathGyro.mulDownMagU(r.y, p.lambda),
      p.c
    ),
    termXp
  );
  a = a + MathGyro.mulUpXpToNpU(
    MathGyro.mulUpMagU(r.x, p.s),
    MathGyro.divXpU(tauValue.y, d.dSq)
  );
  return a;
}
function virtualOffset1(p, d, r, switchTau) {
  const tauValue = switchTau ? d.tauBeta : d.tauAlpha;
  const termXp = MathGyro.divXpU(tauValue.x, d.dSq);
  let b = tauValue.x < 0n ? MathGyro.mulUpXpToNpU(
    MathGyro.mulUpMagU(MathGyro.mulUpMagU(r.x, p.lambda), p.s),
    termXp * -1n
  ) : MathGyro.mulUpXpToNpU(
    MathGyro.mulDownMagU(
      MathGyro.mulDownMagU(r.y * -1n, p.lambda),
      p.s
    ),
    termXp
  );
  b = b + MathGyro.mulUpXpToNpU(
    MathGyro.mulUpMagU(r.x, p.c),
    MathGyro.divXpU(tauValue.y, d.dSq)
  );
  return b;
}
function solveQuadraticSwap(lambda, x, s, c, r, ab, tauBeta, dSq) {
  const lamBar = {
    x: ONE_XP - MathGyro.divDownMagU(MathGyro.divDownMagU(ONE_XP, lambda), lambda),
    y: ONE_XP - MathGyro.divUpMagU(MathGyro.divUpMagU(ONE_XP, lambda), lambda)
  };
  const q = {
    a: 0n,
    b: 0n,
    c: 0n
  };
  const xp = x - ab.x;
  if (xp > 0n) {
    q.b = MathGyro.mulUpXpToNpU(
      MathGyro.mulDownMagU(MathGyro.mulDownMagU(xp * -1n, s), c),
      MathGyro.divXpU(lamBar.y, dSq)
    );
  } else {
    q.b = MathGyro.mulUpXpToNpU(
      MathGyro.mulUpMagU(MathGyro.mulUpMagU(xp * -1n, s), c),
      MathGyro.divXpU(lamBar.x, dSq) + 1n
    );
  }
  const sTerm = {
    x: MathGyro.divXpU(
      MathGyro.mulDownMagU(MathGyro.mulDownMagU(lamBar.y, s), s),
      dSq
    ),
    y: MathGyro.divXpU(
      MathGyro.mulUpMagU(MathGyro.mulUpMagU(lamBar.x, s), s),
      dSq + 1n
    ) + 1n
  };
  sTerm.x = ONE_XP - sTerm.x;
  sTerm.y = ONE_XP - sTerm.y;
  q.c = calcXpXpDivLambdaLambda(x, r, lambda, s, c, tauBeta, dSq) * -1n;
  q.c = q.c + MathGyro.mulDownXpToNpU(MathGyro.mulDownMagU(r.y, r.y), sTerm.y);
  q.c = q.c > 0n ? MathGyro.sqrt(q.c, 5n) : 0n;
  if (q.b - q.c > 0n) {
    q.a = MathGyro.mulUpXpToNpU(
      q.b - q.c,
      MathGyro.divXpU(ONE_XP, sTerm.y) + 1n
    );
  } else {
    q.a = MathGyro.mulUpXpToNpU(
      q.b - q.c,
      MathGyro.divXpU(ONE_XP, sTerm.x)
    );
  }
  return q.a + ab.y;
}
function calcXpXpDivLambdaLambda(x, r, lambda, s, c, tauBeta, dSq) {
  const sqVars = {
    x: MathGyro.mulXpU(dSq, dSq),
    y: MathGyro.mulUpMagU(r.x, r.x)
  };
  const q = {
    a: 0n,
    b: 0n,
    c: 0n
  };
  let termXp = MathGyro.divXpU(
    MathGyro.mulXpU(tauBeta.x, tauBeta.y),
    sqVars.x
  );
  if (termXp > 0n) {
    q.a = MathGyro.mulUpMagU(sqVars.y, s * 2n);
    q.a = MathGyro.mulUpXpToNpU(MathGyro.mulUpMagU(q.a, c), termXp + 7n);
  } else {
    q.a = MathGyro.mulDownMagU(MathGyro.mulDownMagU(r.y, r.y), s * 2n);
    q.a = MathGyro.mulUpXpToNpU(MathGyro.mulDownMagU(q.a, c), termXp);
  }
  if (tauBeta.x < 0n) {
    q.b = MathGyro.mulUpXpToNpU(
      MathGyro.mulUpMagU(MathGyro.mulUpMagU(r.x, x), c * 2n),
      MathGyro.divXpU(tauBeta.x, dSq) * -1n + 3n
    );
  } else {
    q.b = MathGyro.mulUpXpToNpU(
      MathGyro.mulDownMagU(MathGyro.mulDownMagU(r.y * -1n, x), c * 2n),
      MathGyro.divXpU(tauBeta.x, dSq)
    );
  }
  q.a = q.a + q.b;
  termXp = MathGyro.divXpU(MathGyro.mulXpU(tauBeta.y, tauBeta.y), sqVars.x) + 7n;
  q.b = MathGyro.mulUpMagU(sqVars.y, s);
  q.b = MathGyro.mulUpXpToNpU(MathGyro.mulUpMagU(q.b, s), termXp);
  q.c = MathGyro.mulUpXpToNpU(
    MathGyro.mulDownMagU(MathGyro.mulDownMagU(r.y * -1n, x), s * 2n),
    MathGyro.divXpU(tauBeta.y, dSq)
  );
  q.b = q.b + q.c + MathGyro.mulUpMagU(x, x);
  q.b = q.b > 0n ? MathGyro.divUpMagU(q.b, lambda) : MathGyro.divDownMagU(q.b, lambda);
  q.a = q.a + q.b;
  q.a = q.a > 0n ? MathGyro.divUpMagU(q.a, lambda) : MathGyro.divDownMagU(q.a, lambda);
  termXp = MathGyro.divXpU(MathGyro.mulXpU(tauBeta.x, tauBeta.x), sqVars.x) + 7n;
  const val = MathGyro.mulUpMagU(MathGyro.mulUpMagU(sqVars.y, c), c);
  return MathGyro.mulUpXpToNpU(val, termXp) + q.a;
}

// src/entities/pools/gyroE/gyroEMath.ts
function calculateInvariantWithError(balances, params, derived) {
  const [x, y] = balances;
  if (x + y > MAX_BALANCES)
    throw new Error("MAX ASSETS EXCEEDED");
  const AtAChi = calcAtAChi(x, y, params, derived);
  const invariantResult = calcInvariantSqrt(x, y, params, derived);
  const square_root = invariantResult[0];
  let err = invariantResult[1];
  if (square_root > 0) {
    err = MathGyro.divUpMagU(err + 1n, square_root * 2n);
  } else {
    err = err > 0 ? MathGyro.sqrt(err, 5n) : 10n ** 9n;
  }
  err = (MathGyro.mulUpMagU(params.lambda, x + y) / ONE_XP + err + 1n) * 20n;
  const mulDenominator = MathGyro.divXpU(
    ONE_XP,
    calcAChiAChiInXp(params, derived) - ONE_XP
  );
  const invariant = MathGyro.mulDownXpToNpU(
    AtAChi + square_root - err,
    mulDenominator
  );
  err = MathGyro.mulUpXpToNpU(err, mulDenominator);
  err = err + MathGyro.mulUpXpToNpU(invariant, mulDenominator) * (params.lambda * params.lambda / 10n ** 36n) * 40n / ONE_XP + 1n;
  if (invariant + err > MAX_INVARIANT)
    throw new Error("MAX INVARIANT EXCEEDED");
  return [invariant, err];
}
function calcOutGivenIn(balances, amountIn, tokenInIsToken0, params, derived, invariant) {
  if (amountIn < SMALL)
    return 0n;
  const ixIn = Number(!tokenInIsToken0);
  const ixOut = Number(tokenInIsToken0);
  const calcGiven = tokenInIsToken0 ? calcYGivenX : calcXGivenY;
  const balInNew = balances[ixIn] + amountIn;
  checkAssetBounds(params, derived, invariant, balInNew, ixIn);
  const balOutNew = calcGiven(balInNew, params, derived, invariant);
  const amountOut = balances[ixOut] - balOutNew;
  if (amountOut < 0) {
    throw new Error("ASSET BOUNDS EXCEEDED 1");
  }
  return amountOut;
}
function calcInGivenOut(balances, amountOut, tokenInIsToken0, params, derived, invariant) {
  if (amountOut < SMALL)
    return 0n;
  const ixIn = Number(!tokenInIsToken0);
  const ixOut = Number(tokenInIsToken0);
  const calcGiven = tokenInIsToken0 ? calcXGivenY : calcYGivenX;
  if (amountOut > balances[ixOut])
    throw new Error("ASSET BOUNDS EXCEEDED 2");
  const balOutNew = balances[ixOut] - amountOut;
  const balInNew = calcGiven(balOutNew, params, derived, invariant);
  checkAssetBounds(params, derived, invariant, balInNew, ixIn);
  const amountIn = balInNew - balances[ixIn];
  if (amountIn < 0)
    throw new Error("ASSET BOUNDS EXCEEDED 3");
  return amountIn;
}

// src/entities/pools/gyroE/gyroEPool.ts
var GyroEPoolToken = class extends TokenAmount {
  constructor(token, amount, rate, index) {
    super(token, amount);
    __publicField(this, "rate");
    __publicField(this, "index");
    this.rate = BigInt(rate);
    this.scale18 = this.amount * this.scalar * this.rate / WAD;
    this.index = index;
  }
  increase(amount) {
    this.amount = this.amount + amount;
    this.scale18 = this.amount * this.scalar * this.rate / WAD;
    return this;
  }
  decrease(amount) {
    this.amount = this.amount - amount;
    this.scale18 = this.amount * this.scalar * this.rate / WAD;
    return this;
  }
};
var GyroEPool = class {
  constructor(id, poolTypeVersion, swapFee, tokens, gyroEParams, derivedGyroEParams) {
    __publicField(this, "chainId");
    __publicField(this, "id");
    __publicField(this, "address");
    __publicField(this, "poolType", "GyroE" /* GyroE */);
    __publicField(this, "poolTypeVersion");
    __publicField(this, "swapFee");
    __publicField(this, "tokens");
    __publicField(this, "gyroEParams");
    __publicField(this, "derivedGyroEParams");
    __publicField(this, "tokenMap");
    this.chainId = tokens[0].token.chainId;
    this.id = id;
    this.poolTypeVersion = poolTypeVersion;
    this.swapFee = swapFee;
    this.address = getPoolAddress(id);
    this.tokens = tokens;
    this.tokenMap = new Map(
      this.tokens.map((token) => [token.token.address, token])
    );
    this.gyroEParams = gyroEParams;
    this.derivedGyroEParams = derivedGyroEParams;
  }
  static fromRawPool(chainId, pool) {
    const poolTokens = [];
    for (const t of pool.tokens) {
      const token = new Token(
        chainId,
        t.address,
        t.decimals,
        t.symbol,
        t.name
      );
      const tokenAmount = TokenAmount.fromHumanAmount(token, t.balance);
      const tokenRate = pool.tokenRates ? _viem.parseEther.call(void 0, pool.tokenRates[t.index]) : WAD;
      poolTokens.push(
        new GyroEPoolToken(
          token,
          tokenAmount.amount,
          tokenRate,
          t.index
        )
      );
    }
    const gyroEParams = {
      alpha: _viem.parseEther.call(void 0, pool.alpha),
      beta: _viem.parseEther.call(void 0, pool.beta),
      c: _viem.parseEther.call(void 0, pool.c),
      s: _viem.parseEther.call(void 0, pool.s),
      lambda: _viem.parseEther.call(void 0, pool.lambda)
    };
    const derivedGyroEParams = {
      tauAlpha: {
        x: _viem.parseUnits.call(void 0, pool.tauAlphaX, 38),
        y: _viem.parseUnits.call(void 0, pool.tauAlphaY, 38)
      },
      tauBeta: {
        x: _viem.parseUnits.call(void 0, pool.tauBetaX, 38),
        y: _viem.parseUnits.call(void 0, pool.tauBetaY, 38)
      },
      u: _viem.parseUnits.call(void 0, pool.u, 38),
      v: _viem.parseUnits.call(void 0, pool.v, 38),
      w: _viem.parseUnits.call(void 0, pool.w, 38),
      z: _viem.parseUnits.call(void 0, pool.z, 38),
      dSq: _viem.parseUnits.call(void 0, pool.dSq, 38)
    };
    return new GyroEPool(
      pool.id,
      pool.poolTypeVersion,
      _viem.parseEther.call(void 0, pool.swapFee),
      poolTokens,
      gyroEParams,
      derivedGyroEParams
    );
  }
  getNormalizedLiquidity(tokenIn, tokenOut) {
    const tIn = this.tokenMap.get(tokenIn.wrapped);
    const tOut = this.tokenMap.get(tokenOut.wrapped);
    if (!tIn || !tOut)
      throw new Error("Pool does not contain the tokens provided");
    return tOut.amount;
  }
  swapGivenIn(tokenIn, tokenOut, swapAmount, mutateBalances) {
    const { tIn, tOut } = this.getRequiredTokenPair(tokenIn, tokenOut);
    const orderedNormalizedBalances = balancesFromTokenInOut(
      tIn.scale18,
      tOut.scale18,
      tIn.index === 0
    );
    const [currentInvariant, invErr] = calculateInvariantWithError(
      orderedNormalizedBalances,
      this.gyroEParams,
      this.derivedGyroEParams
    );
    const invariant = {
      x: currentInvariant + invErr * 2n,
      y: currentInvariant
    };
    const inAmount = GyroEPoolToken.fromRawAmount(
      tokenIn,
      swapAmount.amount
    );
    const inAmountLessFee = this.subtractSwapFeeAmount(inAmount);
    const inAmountWithRate = inAmountLessFee.mulDownFixed(tIn.rate);
    const outAmountScale18 = calcOutGivenIn(
      orderedNormalizedBalances,
      inAmountWithRate.scale18,
      tIn.index === 0,
      this.gyroEParams,
      this.derivedGyroEParams,
      invariant
    );
    const outAmountWithRate = TokenAmount.fromScale18Amount(
      tokenOut,
      outAmountScale18
    );
    const outAmount = outAmountWithRate.divDownFixed(tOut.rate);
    if (mutateBalances) {
      tIn.increase(swapAmount.amount);
      tOut.decrease(outAmount.amount);
    }
    return outAmount;
  }
  swapGivenOut(tokenIn, tokenOut, swapAmount, mutateBalances) {
    const { tIn, tOut } = this.getRequiredTokenPair(tokenIn, tokenOut);
    const orderedNormalizedBalances = balancesFromTokenInOut(
      tIn.scale18,
      tOut.scale18,
      tIn.index === 0
    );
    const [currentInvariant, invErr] = calculateInvariantWithError(
      orderedNormalizedBalances,
      this.gyroEParams,
      this.derivedGyroEParams
    );
    const invariant = {
      x: currentInvariant + invErr * 2n,
      y: currentInvariant
    };
    const inAmountLessFee = calcInGivenOut(
      orderedNormalizedBalances,
      swapAmount.scale18,
      tIn.index === 0,
      this.gyroEParams,
      this.derivedGyroEParams,
      invariant
    );
    const inAmount = this.addSwapFeeAmount(
      GyroEPoolToken.fromScale18Amount(tokenIn, inAmountLessFee)
    );
    const inAmountWithRate = inAmount.divUpFixed(tIn.rate);
    if (mutateBalances) {
      tIn.decrease(inAmountWithRate.amount);
      tOut.increase(swapAmount.amount);
    }
    return inAmountWithRate;
  }
  getLimitAmountSwap(tokenIn, tokenOut, swapKind) {
    const { tIn, tOut } = this.getRequiredTokenPair(tokenIn, tokenOut);
    if (swapKind === 0 /* GivenIn */) {
      const orderedNormalizedBalances = balancesFromTokenInOut(
        tIn.scale18,
        tOut.scale18,
        tIn.index === 0
      );
      const [currentInvariant, invErr] = calculateInvariantWithError(
        orderedNormalizedBalances,
        this.gyroEParams,
        this.derivedGyroEParams
      );
      const invariant = {
        x: currentInvariant + invErr * 2n,
        y: currentInvariant
      };
      const virtualOffsetFunc = tIn.index === 0 ? virtualOffset0 : virtualOffset1;
      const maxAmountInAssetInPool = virtualOffsetFunc(
        this.gyroEParams,
        this.derivedGyroEParams,
        invariant
      ) - virtualOffsetFunc(
        this.gyroEParams,
        this.derivedGyroEParams,
        invariant,
        true
      );
      const limitAmountIn = MathGyro.divDown(
        maxAmountInAssetInPool - tIn.scale18,
        tIn.rate
      );
      const limitAmountInPlusSwapFee = MathGyro.divDown(
        limitAmountIn,
        WAD - this.swapFee
      );
      return MathGyro.mulDown(
        limitAmountInPlusSwapFee,
        SWAP_LIMIT_FACTOR
      );
    }
    return MathGyro.mulDown(tOut.amount, SWAP_LIMIT_FACTOR);
  }
  subtractSwapFeeAmount(amount) {
    const feeAmount = amount.mulUpFixed(this.swapFee);
    return amount.sub(feeAmount);
  }
  addSwapFeeAmount(amount) {
    return amount.divUpFixed(MathSol.complementFixed(this.swapFee));
  }
  getRequiredTokenPair(tokenIn, tokenOut) {
    const tIn = this.tokenMap.get(tokenIn.wrapped);
    const tOut = this.tokenMap.get(tokenOut.wrapped);
    if (!tIn || !tOut) {
      throw new Error("Pool does not contain the tokens provided");
    }
    return { tIn, tOut };
  }
};

// src/entities/pools/gyroE/gyroEFactory.ts
var GyroEPoolFactory = class {
  isPoolForFactory(pool) {
    return pool.poolType.includes("GyroE");
  }
  create(chainId, pool) {
    return GyroEPool.fromRawPool(chainId, pool);
  }
};

// src/entities/pools/parser.ts
var PoolParser = class {
  constructor(chainId, customPoolFactories) {
    __publicField(this, "poolFactories");
    __publicField(this, "chainId");
    this.chainId = chainId;
    this.poolFactories = [
      // custom pool factories take precedence over base factories
      ...customPoolFactories,
      new WeightedPoolFactory(),
      new StablePoolFactory(),
      new MetaStablePoolFactory(),
      new LinearPoolFactory(),
      new FxPoolFactory(),
      new Gyro2PoolFactory(),
      new Gyro3PoolFactory(),
      new GyroEPoolFactory()
    ];
  }
  parseRawPools(rawPools) {
    const pools = [];
    for (const rawPool of rawPools) {
      for (const factory of this.poolFactories) {
        if (factory.isPoolForFactory(rawPool)) {
          pools.push(factory.create(this.chainId, rawPool));
          break;
        }
      }
    }
    return pools;
  }
};

// src/data/poolDataService.ts

var PoolDataService = class {
  constructor(providers, enrichers, rpcUrl) {
    this.providers = providers;
    this.enrichers = enrichers;
    this.rpcUrl = rpcUrl;
  }
  async fetchEnrichedPools(blockNumber) {
    const providerOptions = {
      block: blockNumber,
      timestamp: await this.getTimestampForBlockNumber(blockNumber)
    };
    const responses = await Promise.all(
      this.providers.map(
        (provider) => provider.getPools(providerOptions)
      )
    );
    const providerData = {
      pools: responses.flatMap((response) => response.pools),
      //we take the smallest block number from the set
      syncedToBlockNumber: responses.map((response) => response.syncedToBlockNumber || 0n).sort()[0],
      poolsWithActiveWeightUpdates: responses.flatMap(
        (response) => response.poolsWithActiveWeightUpdates || []
      ),
      poolsWithActiveAmpUpdates: responses.flatMap(
        (response) => response.poolsWithActiveAmpUpdates || []
      )
    };
    return {
      rawPools: await this.enrichPools(providerData, providerOptions),
      providerData
    };
  }
  async enrichPools(data, providerOptions) {
    let pools = data.pools;
    const additionalPoolData = await Promise.all(
      this.enrichers.map(
        (provider) => provider.fetchAdditionalPoolData(data, providerOptions)
      )
    );
    for (let i = 0; i < this.enrichers.length; i++) {
      pools = this.enrichers[i].enrichPoolsWithData(
        pools,
        additionalPoolData[i]
      );
    }
    return pools;
  }
  async getTimestampForBlockNumber(blockNumber) {
    if (blockNumber) {
      const client = _viem.createPublicClient.call(void 0, {
        transport: _viem.http.call(void 0, this.rpcUrl)
      });
      return (await client.getBlock({ blockNumber })).timestamp;
    }
    return BigInt(Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3));
  }
};

// src/sor.ts
var SmartOrderRouter = class {
  constructor({
    chainId,
    rpcUrl,
    poolDataProviders,
    poolDataEnrichers,
    customPoolFactories = []
  }) {
    __publicField(this, "chainId");
    __publicField(this, "router");
    __publicField(this, "poolParser");
    __publicField(this, "poolDataService");
    __publicField(this, "pools", []);
    __publicField(this, "blockNumber", null);
    __publicField(this, "poolsProviderData", null);
    this.chainId = chainId;
    this.router = new Router();
    this.poolParser = new PoolParser(chainId, customPoolFactories);
    poolDataProviders = poolDataProviders || new SubgraphPoolProvider(chainId, SUBGRAPH_URLS[chainId]);
    poolDataEnrichers = poolDataEnrichers || new OnChainPoolDataEnricher(
      chainId,
      rpcUrl,
      BATCHSIZE[chainId],
      VAULT[chainId]
    );
    this.poolDataService = new PoolDataService(
      Array.isArray(poolDataProviders) ? poolDataProviders : [poolDataProviders],
      Array.isArray(poolDataEnrichers) ? poolDataEnrichers : [poolDataEnrichers],
      rpcUrl
    );
  }
  async fetchAndCachePools(blockNumber) {
    const { rawPools, providerData } = await this.poolDataService.fetchEnrichedPools(blockNumber);
    this.pools = this.poolParser.parseRawPools(rawPools);
    this.blockNumber = typeof blockNumber === "bigint" ? blockNumber : null;
    this.poolsProviderData = providerData;
    return this.pools;
  }
  async fetchAndCacheLatestPoolEnrichmentData(blockNumber) {
    if (!this.poolsProviderData) {
      throw new Error(
        "fetchAndCacheLatestPoolEnrichmentData can only be called after a successful call to fetchAndCachePools"
      );
    }
    const providerOptions = {
      block: blockNumber,
      timestamp: await this.poolDataService.getTimestampForBlockNumber(
        blockNumber
      )
    };
    const enriched = await this.poolDataService.enrichPools(
      this.poolsProviderData,
      providerOptions
    );
    this.pools = this.poolParser.parseRawPools(enriched);
  }
  get isInitialized() {
    return this.pools.length > 0;
  }
  async getSwaps(tokenIn, tokenOut, swapKind, swapAmount, swapOptions) {
    const checkedSwapAmount = checkInputs(
      tokenIn,
      tokenOut,
      swapKind,
      swapAmount
    );
    const candidatePaths = await this.getCandidatePaths(
      tokenIn,
      tokenOut,
      swapOptions
    );
    if (candidatePaths.length === 0)
      return null;
    const bestPaths = this.router.getBestPaths(
      candidatePaths,
      swapKind,
      checkedSwapAmount
    );
    if (!bestPaths)
      return null;
    return new Swap({ paths: bestPaths, swapKind });
  }
  async getCandidatePaths(tokenIn, tokenOut, options) {
    if (!this.isInitialized || _optionalChain([options, 'optionalAccess', _56 => _56.block]) && options.block !== this.blockNumber) {
      await this.fetchAndCachePools(_optionalChain([options, 'optionalAccess', _57 => _57.block]));
    }
    return this.router.getCandidatePaths(
      tokenIn,
      tokenOut,
      this.pools,
      _optionalChain([options, 'optionalAccess', _58 => _58.graphTraversalConfig])
    );
  }
};

// src/static.ts
function sorParseRawPools(chainId, pools, customPoolFactories = []) {
  const poolParser = new PoolParser(chainId, customPoolFactories);
  return poolParser.parseRawPools(pools);
}
async function sorGetSwapsWithPools(tokenIn, tokenOut, swapKind, swapAmount, pools, swapOptions) {
  const checkedSwapAmount = checkInputs(
    tokenIn,
    tokenOut,
    swapKind,
    swapAmount
  );
  const router = new Router();
  const candidatePaths = router.getCandidatePaths(
    tokenIn,
    tokenOut,
    pools,
    _optionalChain([swapOptions, 'optionalAccess', _59 => _59.graphTraversalConfig])
  );
  if (candidatePaths.length === 0)
    return null;
  const bestPaths = router.getBestPaths(
    candidatePaths,
    swapKind,
    checkedSwapAmount
  );
  if (!bestPaths)
    return null;
  return new Swap({ paths: bestPaths, swapKind });
}









































































exports.AddLiquidity = AddLiquidity; exports.AddLiquidityKind = AddLiquidityKind; exports.AddLiquidityNested = AddLiquidityNested; exports.BALANCER_QUERIES = BALANCER_QUERIES; exports.BALANCER_RELAYER = BALANCER_RELAYER; exports.BALANCER_VAULT = BALANCER_VAULT; exports.BATCHSIZE = BATCHSIZE; exports.BalancerApi = BalancerApi; exports.CHAINS = CHAINS; exports.COMPOSABLE_STABLE_POOL_FACTORY = COMPOSABLE_STABLE_POOL_FACTORY; exports.ChainId = ChainId; exports.CreatePool = CreatePool; exports.DECIMAL_SCALES = DECIMAL_SCALES; exports.DEFAULT_FUND_MANAGMENT = DEFAULT_FUND_MANAGMENT; exports.DEFAULT_USERDATA = DEFAULT_USERDATA; exports.ETH = ETH; exports.FOUR_WAD = FOUR_WAD; exports.HUNDRED_WAD = HUNDRED_WAD; exports.InitPool = InitPool; exports.MAX_UINT112 = MAX_UINT112; exports.MAX_UINT256 = MAX_UINT256; exports.MathSol = MathSol; exports.NATIVE_ADDRESS = NATIVE_ADDRESS; exports.NATIVE_ASSETS = NATIVE_ASSETS; exports.OnChainPoolDataEnricher = OnChainPoolDataEnricher; exports.PREMINTED_STABLE_BPT = PREMINTED_STABLE_BPT; exports.Path = Path; exports.PathWithAmount = PathWithAmount; exports.PoolKind = PoolKind; exports.PoolType = PoolType; exports.PriceImpact = PriceImpact; exports.PriceImpactAmount = PriceImpactAmount; exports.RAY = RAY; exports.RemoveLiquidity = RemoveLiquidity; exports.RemoveLiquidityKind = RemoveLiquidityKind; exports.RemoveLiquidityNested = RemoveLiquidityNested; exports.SECONDS_PER_YEAR = SECONDS_PER_YEAR; exports.SUBGRAPH_URLS = SUBGRAPH_URLS; exports.Slippage = Slippage; exports.SmartOrderRouter = SmartOrderRouter; exports.SubgraphPoolProvider = SubgraphPoolProvider; exports.Swap = Swap; exports.SwapKind = SwapKind; exports.TWO_WAD = TWO_WAD; exports.Token = Token; exports.TokenAmount = TokenAmount; exports.VAULT = VAULT; exports.WAD = WAD; exports.WEIGHTED_POOL_FACTORY = WEIGHTED_POOL_FACTORY; exports.WeightedEncoder = WeightedEncoder; exports.WeightedPoolExitKind = WeightedPoolExitKind; exports.WeightedPoolJoinKind = WeightedPoolJoinKind; exports.ZERO_ADDRESS = ZERO_ADDRESS; exports.abs = abs; exports.brickedPools = brickedPools; exports.checkInputs = checkInputs; exports.constraintValidation = constraintValidation; exports.doAddLiquidityQuery = doAddLiquidityQuery; exports.getAmounts = getAmounts; exports.getEncoder = getEncoder; exports.getPoolAddress = getPoolAddress; exports.getSortedTokens = getSortedTokens; exports.max = max; exports.min = min; exports.parseAddLiquidityArgs = parseAddLiquidityArgs; exports.poolHasActualSupply = poolHasActualSupply; exports.poolHasPercentFee = poolHasPercentFee; exports.poolHasVirtualSupply = poolHasVirtualSupply; exports.poolIsLinearPool = poolIsLinearPool; exports.replaceWrapped = replaceWrapped; exports.sorGetSwapsWithPools = sorGetSwapsWithPools; exports.sorParseRawPools = sorParseRawPools;
//# sourceMappingURL=index.cjs.map